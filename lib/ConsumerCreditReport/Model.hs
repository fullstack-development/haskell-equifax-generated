{-
   Consumer Credit Report

   # Introduction       Equifax’s Consumer Credit Report is the leading consumer credit resource enabling lenders to make faster, more informed credit-granting decisions, better manage their risk and maximize growth opportunities. The Consumer Credit Report unites the power of superior consumer dfata with best-in-class search and match logic capabilities to deliver higher match rates on more inquiries.    # Getting Started  1. **<a href=\"/user/applications\" target=\"_blank\">Create</a>** an application  2. **<a href=\"/user/applications\" target=\"_blank\">Subscribe</a>** to Consumer Credit Report API  3. **<a href=\"/products/consumer-credit-report\" target=\"_blank\">Explore</a>** the Sandbox environment mode # Promoting to UAT  To successfully submit test transactions through your application in the UAT environment, a test member number is required.  You may use your existing Equifax test member number(s).  Please contact your Equifax Account Representative if a new test member number is needed. The steps below can be used to test in the UAT environment.  Transactions generated using a test member number do not return identical results as a sandbox transaction.  A sandbox transaction will reflect everything that is exposed in the API whereas a test member number is configured to align with the specifications of your contract. Please contact us to ensure your test member number is configured to your expectations.      1. **<a href=\"/user/applications\" target=\"_blank\">Promote</a>** application to test  2. **<a href=\"/documentation\" target=\"_blank\">Update</a>** requests details for UAT  3. **<a href=\"/documentation\" target=\"_blank\">Test</a>** scenarios in UAT environment   # For More Details    * **<a href=\"/contact\" target=\"_blank\">Contact Us</a>** - Equifax Developer Center Support Website   * **ACRO Migration Support**       * phone: 1-888-407-0359; Option 2 followed by Option 5         * email:  BT.Acro.tech@equifax.com        

   OpenAPI Version: 3.0.0
   Consumer Credit Report API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ConsumerCreditReport.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ConsumerCreditReport.Model where

import ConsumerCreditReport.Core
import ConsumerCreditReport.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** PdfRequestId
newtype PdfRequestId = PdfRequestId { unPdfRequestId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** APIErrorResponse
-- | APIErrorResponse
data APIErrorResponse = APIErrorResponse
  { aPIErrorResponseEfxErrorCode :: !(Double) -- ^ /Required/ "efxErrorCode" - Error code
  , aPIErrorResponseDescription :: !(Text) -- ^ /Required/ "description"
  , aPIErrorResponseAdditionalErrorDetails :: !(Maybe AdditionalErrorDetails) -- ^ "additionalErrorDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON APIErrorResponse
instance A.FromJSON APIErrorResponse where
  parseJSON = A.withObject "APIErrorResponse" $ \o ->
    APIErrorResponse
      <$> (o .:  "efxErrorCode")
      <*> (o .:  "description")
      <*> (o .:? "additionalErrorDetails")

-- | ToJSON APIErrorResponse
instance A.ToJSON APIErrorResponse where
  toJSON APIErrorResponse {..} =
   _omitNulls
      [ "efxErrorCode" .= aPIErrorResponseEfxErrorCode
      , "description" .= aPIErrorResponseDescription
      , "additionalErrorDetails" .= aPIErrorResponseAdditionalErrorDetails
      ]


-- | Construct a value of type 'APIErrorResponse' (by applying it's required fields, if any)
mkAPIErrorResponse
  :: Double -- ^ 'aPIErrorResponseEfxErrorCode': Error code
  -> Text -- ^ 'aPIErrorResponseDescription' 
  -> APIErrorResponse
mkAPIErrorResponse aPIErrorResponseEfxErrorCode aPIErrorResponseDescription =
  APIErrorResponse
  { aPIErrorResponseEfxErrorCode
  , aPIErrorResponseDescription
  , aPIErrorResponseAdditionalErrorDetails = Nothing
  }

-- ** AccountDesignatorCode
-- | AccountDesignatorCode
-- Consumer relationship with account
data AccountDesignatorCode = AccountDesignatorCode
  { accountDesignatorCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , accountDesignatorCodeDescription :: !(Maybe Text) -- ^ "description" - - A: Authorized User – This is an authorized user of this account; another individual has contractual responsibility. - B: On behalf of another person – The subject has financial responsibility for an account, which is used exclusively by another person. - C: Co-maker – The subject has co-signed for a loan, and will be responsible for payment if the borrower should default. - I: Individual Account – The subject of the report has contractual responsibility for this account and is primarily responsible for its payment. - J: Joint Account – The subject and another person (or persons) are jointly responsible for payment on this account. - M: Maker – The subject is responsible for payment of a loan, but a co-maker will be responsible for payment if maker defaults. - S: Shared, but otherwise undesignated – This code is an indication that the credit grantor knows that the subject and at least one other person share the account, but not enough information is available to designate the account as “J” or “A”. - T: Terminated – The subject’s relationship to this account has ended, although other parties who once shared the account may continue to maintain the account. - U: Undesignated - X: Deceased (Not returned on Trade Lines) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountDesignatorCode
instance A.FromJSON AccountDesignatorCode where
  parseJSON = A.withObject "AccountDesignatorCode" $ \o ->
    AccountDesignatorCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON AccountDesignatorCode
instance A.ToJSON AccountDesignatorCode where
  toJSON AccountDesignatorCode {..} =
   _omitNulls
      [ "code" .= accountDesignatorCodeCode
      , "description" .= accountDesignatorCodeDescription
      ]


-- | Construct a value of type 'AccountDesignatorCode' (by applying it's required fields, if any)
mkAccountDesignatorCode
  :: AccountDesignatorCode
mkAccountDesignatorCode =
  AccountDesignatorCode
  { accountDesignatorCodeCode = Nothing
  , accountDesignatorCodeDescription = Nothing
  }

-- ** AccountTypeCode
-- | AccountTypeCode
-- Codes describing the account type
data AccountTypeCode = AccountTypeCode
  { accountTypeCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , accountTypeCodeDescription :: !(Maybe Text) -- ^ "description" - Account Type Codes:   - 00: Auto   - 01: Unsecured   - 02: Secured   - 03: Partially Secured   - 04: Home Improvement   - 05: Federal Housing Administration Home Improvement   - 06: Installment Sales Contract   - 07: Charge Account   - 08: Real Estate   - 10: Business Loan - Individual is personally liable   - 11: Recreational Merchandise   - 12: Education Loan   - 13: Lease   - 14: Co-Maker Not Borrower (Retired 9-18-09)   - 15: Line of Credit   - 17: Manufactured Housing   - 18: Credit Card   - 19: Federal Housing Administration Real Estate Mortgage   - 20: Note Loan   - 21: Note Loan With Co-Maker   - 22: Secured By Household Goods   - 23: Secured By Household Goods/Collateral   - 25: Veteran’s Administration Real Estate Mortgage   - 26: Conventional Real Estate Mortgage   - 27: Real Estate Mortgage   - 29: Rental Agreement   - 34: Debt Counseling Service   - 37: Combined Credit Plan (represents two credit plans being reported as one account)   - 43: Debit Card (used when backed by a line of credit or overdraft protection)   - 47: Credit Line Secured   - 48: Collection Agency/Attorney   - 49: Insurance Claim Pending   - 50: Family Support   - 65: Government Unsecured Guaranteed Loan   - 66: Government Secured Guaranteed Loan   - 67: Government Unsecured Direct Loan   - 68: Government Secured Direct Loan   - 69: Government Grant   - 70: Government Overpayment   - 71: Government Fine   - 72: Government Fee for Services   - 73: Government Employee Advance   - 74: Government Miscellaneous Debt   - 75: Government Benefit   - 77: Returned Check   - 78: Installment Loan   - 85: Bi-Monthly Mortgage Payment (every other month)   - 87: Semi-Monthly Mortgage Payment (twice per month)   - 89: Home Equity Line of Credit   - 90: Medical Debt   - 91: Debt Consolidation   - 92: Utility Company   - 93: Child Support   - 94: Spouse Support   - 95: Attorney Fees   - 0A: Time Share Loan (a purchased time share)   - 1A: Lender Placed Insurance   - 2A: Secured Credit Card   - 3A: Auto Lease   - 5A: Real Estate (junior liens and non-purchase money first)   - 6A: Commercial Installment Loan (Individual personally liable; company is guarantor)   - 7A: Commercial Line of Credit (Individual personally liable; company is guarantor)   - 8A: Business Credit Card (Individual has primary responsibility)   - 9A: Secured Home Improvement   - 5B: Second Mortgage   - 6B: Commercial Mortgage Loan (Individual is personally liable; company is guarantor)   - 7B: Agricultural   - 8B: Deposit Related (overdrawn account)   - 9B: Business Line Personally Guaranteed   - 0C: Debt Buyer Account   - 1C: Household Goods   - 2C: US Department of Agriculture Real Estate Mortgage Loan   - 4D: Telecommunication/Cellular   - 6D: Home Equity   - 0F: Construction Loan   - 0G: Flexible Spending Credit Card    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountTypeCode
instance A.FromJSON AccountTypeCode where
  parseJSON = A.withObject "AccountTypeCode" $ \o ->
    AccountTypeCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON AccountTypeCode
instance A.ToJSON AccountTypeCode where
  toJSON AccountTypeCode {..} =
   _omitNulls
      [ "code" .= accountTypeCodeCode
      , "description" .= accountTypeCodeDescription
      ]


-- | Construct a value of type 'AccountTypeCode' (by applying it's required fields, if any)
mkAccountTypeCode
  :: AccountTypeCode
mkAccountTypeCode =
  AccountTypeCode
  { accountTypeCodeCode = Nothing
  , accountTypeCodeDescription = Nothing
  }

-- ** AdditionalErrorDetails
-- | AdditionalErrorDetails
-- Additional error details
data AdditionalErrorDetails = AdditionalErrorDetails
  { additionalErrorDetailsStatus :: !(Double) -- ^ /Required/ "status" - HTTP status code
  , additionalErrorDetailsErrors :: !(Maybe [A.Value]) -- ^ "errors"
  , additionalErrorDetailsCode :: !(Maybe Double) -- ^ "code" - Internal code to identify the error
  , additionalErrorDetailsMessage :: !(Maybe Text) -- ^ "message" - Short error message
  , additionalErrorDetailsTimeStamp :: !(Maybe Text) -- ^ "timeStamp" - Date and time when the error occurred
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdditionalErrorDetails
instance A.FromJSON AdditionalErrorDetails where
  parseJSON = A.withObject "AdditionalErrorDetails" $ \o ->
    AdditionalErrorDetails
      <$> (o .:  "status")
      <*> (o .:? "errors")
      <*> (o .:? "code")
      <*> (o .:? "message")
      <*> (o .:? "timeStamp")

-- | ToJSON AdditionalErrorDetails
instance A.ToJSON AdditionalErrorDetails where
  toJSON AdditionalErrorDetails {..} =
   _omitNulls
      [ "status" .= additionalErrorDetailsStatus
      , "errors" .= additionalErrorDetailsErrors
      , "code" .= additionalErrorDetailsCode
      , "message" .= additionalErrorDetailsMessage
      , "timeStamp" .= additionalErrorDetailsTimeStamp
      ]


-- | Construct a value of type 'AdditionalErrorDetails' (by applying it's required fields, if any)
mkAdditionalErrorDetails
  :: Double -- ^ 'additionalErrorDetailsStatus': HTTP status code
  -> AdditionalErrorDetails
mkAdditionalErrorDetails additionalErrorDetailsStatus =
  AdditionalErrorDetails
  { additionalErrorDetailsStatus
  , additionalErrorDetailsErrors = Nothing
  , additionalErrorDetailsCode = Nothing
  , additionalErrorDetailsMessage = Nothing
  , additionalErrorDetailsTimeStamp = Nothing
  }

-- ** Address
-- | Address
-- Subject's address(es) information
data Address = Address
  { addressAddressType :: !(Maybe E'AddressType) -- ^ "addressType" - The address type:   - current: Current Address. A maximum of 1 current Address can be returned per report   - former: Former Address. A maximum of 1 former Address can be returned per report   - additional: Additional Address. A maximum of 8 additional Addresses can be returned per report 
  , addressHouseNumber :: !(Maybe Text) -- ^ "houseNumber" - Street Number/House number
  , addressStreetName :: !(Maybe Text) -- ^ "streetName" - Street name
  , addressStreetType :: !(Maybe Text) -- ^ "streetType" - Street type/Direction/Apartment number
  , addressCityName :: !(Maybe Text) -- ^ "cityName" - City name
  , addressStateAbbreviation :: !(Maybe Text) -- ^ "stateAbbreviation" - State abbreviation
  , addressZipCode :: !(Maybe Text) -- ^ "zipCode" - Zip code
  , addressRentOwnBuy :: !(Maybe Text) -- ^ "rentOwnBuy" - Rent/Own/Buy
  , addressSourceOfAddress :: !(Maybe AddressSourceOfAddress) -- ^ "sourceOfAddress"
  , addressTelephoneNumber :: !(Maybe Text) -- ^ "telephoneNumber" - Telephone number including a valid area code
  , addressSourceOfTelephoneNumber :: !(Maybe AddressSourceOfTelephoneNumber) -- ^ "sourceOfTelephoneNumber"
  , addressAddressVarianceIndicator :: !(Maybe AddressAddressVarianceIndicator) -- ^ "addressVarianceIndicator"
  , addressAddressLine1 :: !(Maybe Text) -- ^ "addressLine1" - Combination of address components
  , addressDateFirstReported :: !(Maybe Date) -- ^ "dateFirstReported" - First date the address was reported to Equifax
  , addressDateLastReported :: !(Maybe Date) -- ^ "dateLastReported" - Last date the address was reported to Equifax
  , addressDateTelephoneReported :: !(Maybe Date) -- ^ "dateTelephoneReported" - Date the telephone number was reported to Equifax
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Address
instance A.FromJSON Address where
  parseJSON = A.withObject "Address" $ \o ->
    Address
      <$> (o .:? "addressType")
      <*> (o .:? "houseNumber")
      <*> (o .:? "streetName")
      <*> (o .:? "streetType")
      <*> (o .:? "cityName")
      <*> (o .:? "stateAbbreviation")
      <*> (o .:? "zipCode")
      <*> (o .:? "rentOwnBuy")
      <*> (o .:? "sourceOfAddress")
      <*> (o .:? "telephoneNumber")
      <*> (o .:? "sourceOfTelephoneNumber")
      <*> (o .:? "addressVarianceIndicator")
      <*> (o .:? "addressLine1")
      <*> (o .:? "dateFirstReported")
      <*> (o .:? "dateLastReported")
      <*> (o .:? "dateTelephoneReported")

-- | ToJSON Address
instance A.ToJSON Address where
  toJSON Address {..} =
   _omitNulls
      [ "addressType" .= addressAddressType
      , "houseNumber" .= addressHouseNumber
      , "streetName" .= addressStreetName
      , "streetType" .= addressStreetType
      , "cityName" .= addressCityName
      , "stateAbbreviation" .= addressStateAbbreviation
      , "zipCode" .= addressZipCode
      , "rentOwnBuy" .= addressRentOwnBuy
      , "sourceOfAddress" .= addressSourceOfAddress
      , "telephoneNumber" .= addressTelephoneNumber
      , "sourceOfTelephoneNumber" .= addressSourceOfTelephoneNumber
      , "addressVarianceIndicator" .= addressAddressVarianceIndicator
      , "addressLine1" .= addressAddressLine1
      , "dateFirstReported" .= addressDateFirstReported
      , "dateLastReported" .= addressDateLastReported
      , "dateTelephoneReported" .= addressDateTelephoneReported
      ]


-- | Construct a value of type 'Address' (by applying it's required fields, if any)
mkAddress
  :: Address
mkAddress =
  Address
  { addressAddressType = Nothing
  , addressHouseNumber = Nothing
  , addressStreetName = Nothing
  , addressStreetType = Nothing
  , addressCityName = Nothing
  , addressStateAbbreviation = Nothing
  , addressZipCode = Nothing
  , addressRentOwnBuy = Nothing
  , addressSourceOfAddress = Nothing
  , addressTelephoneNumber = Nothing
  , addressSourceOfTelephoneNumber = Nothing
  , addressAddressVarianceIndicator = Nothing
  , addressAddressLine1 = Nothing
  , addressDateFirstReported = Nothing
  , addressDateLastReported = Nothing
  , addressDateTelephoneReported = Nothing
  }

-- ** AddressAddressVarianceIndicator
-- | AddressAddressVarianceIndicator
-- The Address Variance Indicator will alert you to the differences between the address submitted current and other addresses displayed on the consumer report.The Address Variance Indicator will return a code, for each address displayed on the report, informing you of the degree to which the first address submitted in the inquiry matched the address on the Equifax database. Address Variance Indicator is an optional feature offered by Equifax.  Please contact your Equifax Sales Associate for additional information and activation. 
data AddressAddressVarianceIndicator = AddressAddressVarianceIndicator
  { addressAddressVarianceIndicatorCode :: !(Maybe Text) -- ^ "code" - Code value
  , addressAddressVarianceIndicatorDescription :: !(Maybe Text) -- ^ "description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressAddressVarianceIndicator
instance A.FromJSON AddressAddressVarianceIndicator where
  parseJSON = A.withObject "AddressAddressVarianceIndicator" $ \o ->
    AddressAddressVarianceIndicator
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON AddressAddressVarianceIndicator
instance A.ToJSON AddressAddressVarianceIndicator where
  toJSON AddressAddressVarianceIndicator {..} =
   _omitNulls
      [ "code" .= addressAddressVarianceIndicatorCode
      , "description" .= addressAddressVarianceIndicatorDescription
      ]


-- | Construct a value of type 'AddressAddressVarianceIndicator' (by applying it's required fields, if any)
mkAddressAddressVarianceIndicator
  :: AddressAddressVarianceIndicator
mkAddressAddressVarianceIndicator =
  AddressAddressVarianceIndicator
  { addressAddressVarianceIndicatorCode = Nothing
  , addressAddressVarianceIndicatorDescription = Nothing
  }

-- ** AddressRequest
-- | AddressRequest
data AddressRequest = AddressRequest
  { addressRequestIdentifier :: !(Text) -- ^ /Required/ "identifier" - Address type of the report subject
  , addressRequestHouseNumber :: !(Maybe Text) -- ^ "houseNumber" - House number
  , addressRequestQuadrant :: !(Maybe Text) -- ^ "quadrant" - Quadrant
  , addressRequestStreetName :: !(Maybe Text) -- ^ "streetName" - Street name
  , addressRequestStreetType :: !(Maybe Text) -- ^ "streetType" - Street type
  , addressRequestApartmentNumber :: !(Maybe Text) -- ^ "apartmentNumber" - Apartment/Condo/Unit number
  , addressRequestCity :: !(Text) -- ^ /Required/ "city" - City name
  , addressRequestState :: !(Text) -- ^ /Required/ "state" - State abbreviation
  , addressRequestZip :: !(Maybe Text) -- ^ "zip" - Zip code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressRequest
instance A.FromJSON AddressRequest where
  parseJSON = A.withObject "AddressRequest" $ \o ->
    AddressRequest
      <$> (o .:  "identifier")
      <*> (o .:? "houseNumber")
      <*> (o .:? "quadrant")
      <*> (o .:? "streetName")
      <*> (o .:? "streetType")
      <*> (o .:? "apartmentNumber")
      <*> (o .:  "city")
      <*> (o .:  "state")
      <*> (o .:? "zip")

-- | ToJSON AddressRequest
instance A.ToJSON AddressRequest where
  toJSON AddressRequest {..} =
   _omitNulls
      [ "identifier" .= addressRequestIdentifier
      , "houseNumber" .= addressRequestHouseNumber
      , "quadrant" .= addressRequestQuadrant
      , "streetName" .= addressRequestStreetName
      , "streetType" .= addressRequestStreetType
      , "apartmentNumber" .= addressRequestApartmentNumber
      , "city" .= addressRequestCity
      , "state" .= addressRequestState
      , "zip" .= addressRequestZip
      ]


-- | Construct a value of type 'AddressRequest' (by applying it's required fields, if any)
mkAddressRequest
  :: Text -- ^ 'addressRequestIdentifier': Address type of the report subject
  -> Text -- ^ 'addressRequestCity': City name
  -> Text -- ^ 'addressRequestState': State abbreviation
  -> AddressRequest
mkAddressRequest addressRequestIdentifier addressRequestCity addressRequestState =
  AddressRequest
  { addressRequestIdentifier
  , addressRequestHouseNumber = Nothing
  , addressRequestQuadrant = Nothing
  , addressRequestStreetName = Nothing
  , addressRequestStreetType = Nothing
  , addressRequestApartmentNumber = Nothing
  , addressRequestCity
  , addressRequestState
  , addressRequestZip = Nothing
  }

-- ** AddressSourceOfAddress
-- | AddressSourceOfAddress
-- The source of address data
data AddressSourceOfAddress = AddressSourceOfAddress
  { addressSourceOfAddressCode :: !(Maybe Text) -- ^ "code" - Code value
  , addressSourceOfAddressDescription :: !(Maybe Text) -- ^ "description" - Sources of address:   - C: EQUIFAX   - D: OTH/Sys-Sys   - T: AUT 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressSourceOfAddress
instance A.FromJSON AddressSourceOfAddress where
  parseJSON = A.withObject "AddressSourceOfAddress" $ \o ->
    AddressSourceOfAddress
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON AddressSourceOfAddress
instance A.ToJSON AddressSourceOfAddress where
  toJSON AddressSourceOfAddress {..} =
   _omitNulls
      [ "code" .= addressSourceOfAddressCode
      , "description" .= addressSourceOfAddressDescription
      ]


-- | Construct a value of type 'AddressSourceOfAddress' (by applying it's required fields, if any)
mkAddressSourceOfAddress
  :: AddressSourceOfAddress
mkAddressSourceOfAddress =
  AddressSourceOfAddress
  { addressSourceOfAddressCode = Nothing
  , addressSourceOfAddressDescription = Nothing
  }

-- ** AddressSourceOfTelephoneNumber
-- | AddressSourceOfTelephoneNumber
-- Source of Telephone data
data AddressSourceOfTelephoneNumber = AddressSourceOfTelephoneNumber
  { addressSourceOfTelephoneNumberCode :: !(Maybe Text) -- ^ "code" - Code value
  , addressSourceOfTelephoneNumberDescription :: !(Maybe Text) -- ^ "description" - Sources of telephone number:   - 1: Special Vendor        - 2: Equifax        - 3: OTH/Sys-Sys        - 4: Automated Update Indicator 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressSourceOfTelephoneNumber
instance A.FromJSON AddressSourceOfTelephoneNumber where
  parseJSON = A.withObject "AddressSourceOfTelephoneNumber" $ \o ->
    AddressSourceOfTelephoneNumber
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON AddressSourceOfTelephoneNumber
instance A.ToJSON AddressSourceOfTelephoneNumber where
  toJSON AddressSourceOfTelephoneNumber {..} =
   _omitNulls
      [ "code" .= addressSourceOfTelephoneNumberCode
      , "description" .= addressSourceOfTelephoneNumberDescription
      ]


-- | Construct a value of type 'AddressSourceOfTelephoneNumber' (by applying it's required fields, if any)
mkAddressSourceOfTelephoneNumber
  :: AddressSourceOfTelephoneNumber
mkAddressSourceOfTelephoneNumber =
  AddressSourceOfTelephoneNumber
  { addressSourceOfTelephoneNumberCode = Nothing
  , addressSourceOfTelephoneNumberDescription = Nothing
  }

-- ** AlertContactAddress
-- | AlertContactAddress
-- Contact's address information
data AlertContactAddress = AlertContactAddress
  { alertContactAddressAddressLine1 :: !(Maybe Text) -- ^ "addressLine1" - House number, street name &amp; street type
  , alertContactAddressAddressLine2 :: !(Maybe Text) -- ^ "addressLine2" - Apartment, condo, suite, or unit number
  , alertContactAddressCityName :: !(Maybe Text) -- ^ "cityName" - City name
  , alertContactAddressStateAbbreviation :: !(Maybe Text) -- ^ "stateAbbreviation" - State name&#39;s abbreviation
  , alertContactAddressZipCode :: !(Maybe Text) -- ^ "zipCode" - Zip code
  , alertContactAddressCountryCode :: !(Maybe Text) -- ^ "countryCode" - Country code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertContactAddress
instance A.FromJSON AlertContactAddress where
  parseJSON = A.withObject "AlertContactAddress" $ \o ->
    AlertContactAddress
      <$> (o .:? "addressLine1")
      <*> (o .:? "addressLine2")
      <*> (o .:? "cityName")
      <*> (o .:? "stateAbbreviation")
      <*> (o .:? "zipCode")
      <*> (o .:? "countryCode")

-- | ToJSON AlertContactAddress
instance A.ToJSON AlertContactAddress where
  toJSON AlertContactAddress {..} =
   _omitNulls
      [ "addressLine1" .= alertContactAddressAddressLine1
      , "addressLine2" .= alertContactAddressAddressLine2
      , "cityName" .= alertContactAddressCityName
      , "stateAbbreviation" .= alertContactAddressStateAbbreviation
      , "zipCode" .= alertContactAddressZipCode
      , "countryCode" .= alertContactAddressCountryCode
      ]


-- | Construct a value of type 'AlertContactAddress' (by applying it's required fields, if any)
mkAlertContactAddress
  :: AlertContactAddress
mkAlertContactAddress =
  AlertContactAddress
  { alertContactAddressAddressLine1 = Nothing
  , alertContactAddressAddressLine2 = Nothing
  , alertContactAddressCityName = Nothing
  , alertContactAddressStateAbbreviation = Nothing
  , alertContactAddressZipCode = Nothing
  , alertContactAddressCountryCode = Nothing
  }

-- ** Bankruptcy
-- | Bankruptcy
-- Details associated with bankruptcy
data Bankruptcy = Bankruptcy
  { bankruptcyCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - Court customer number
  , bankruptcyType :: !(Maybe Text) -- ^ "type" - Type of bankruptcy: - B: Business - I: Individual 
  , bankruptcyFiler :: !(Maybe Text) -- ^ "filer" - How filed: - I: Individual - J: Joint - W: Spouse 
  , bankruptcyIndustryCode :: !(Maybe Text) -- ^ "industryCode" - Industry code
  , bankruptcyCurrentIntentOrDispositionCode :: !(Maybe BankruptcyCurrentIntentOrDispositionCode) -- ^ "currentIntentOrDispositionCode"
  , bankruptcyNarrativeCodes :: !(Maybe [A.Value]) -- ^ "narrativeCodes"
  , bankruptcyRawNarrativeCodes :: !(Maybe [Text]) -- ^ "rawNarrativeCodes" - Raw narrative codes included in the report
  , bankruptcyCaseNumber :: !(Maybe Text) -- ^ "caseNumber" - Case number
  , bankruptcyDispositionDate :: !(Maybe Text) -- ^ "dispositionDate" - Disposition Date
  , bankruptcyDateFiled :: !(Maybe Date) -- ^ "dateFiled" - Date Last Filed
  , bankruptcyCurrentDispositionDate :: !(Maybe Date) -- ^ "currentDispositionDate" - Contains the date of the final status of the case whether discharged or dismissed
  , bankruptcyVerifiedDate :: !(Maybe Date) -- ^ "verifiedDate" - Date of verification for any updates to the bankruptcy disposition according to court records.
  , bankruptcyPriorIntentOrDispositionCode :: !(Maybe BankruptcyPriorIntentOrDispositionCode) -- ^ "priorIntentOrDispositionCode"
  , bankruptcyDateReported :: !(Maybe Date) -- ^ "dateReported" - Date the bankruptcy was reported to Equifax
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Bankruptcy
instance A.FromJSON Bankruptcy where
  parseJSON = A.withObject "Bankruptcy" $ \o ->
    Bankruptcy
      <$> (o .:? "customerNumber")
      <*> (o .:? "type")
      <*> (o .:? "filer")
      <*> (o .:? "industryCode")
      <*> (o .:? "currentIntentOrDispositionCode")
      <*> (o .:? "narrativeCodes")
      <*> (o .:? "rawNarrativeCodes")
      <*> (o .:? "caseNumber")
      <*> (o .:? "dispositionDate")
      <*> (o .:? "dateFiled")
      <*> (o .:? "currentDispositionDate")
      <*> (o .:? "verifiedDate")
      <*> (o .:? "priorIntentOrDispositionCode")
      <*> (o .:? "dateReported")

-- | ToJSON Bankruptcy
instance A.ToJSON Bankruptcy where
  toJSON Bankruptcy {..} =
   _omitNulls
      [ "customerNumber" .= bankruptcyCustomerNumber
      , "type" .= bankruptcyType
      , "filer" .= bankruptcyFiler
      , "industryCode" .= bankruptcyIndustryCode
      , "currentIntentOrDispositionCode" .= bankruptcyCurrentIntentOrDispositionCode
      , "narrativeCodes" .= bankruptcyNarrativeCodes
      , "rawNarrativeCodes" .= bankruptcyRawNarrativeCodes
      , "caseNumber" .= bankruptcyCaseNumber
      , "dispositionDate" .= bankruptcyDispositionDate
      , "dateFiled" .= bankruptcyDateFiled
      , "currentDispositionDate" .= bankruptcyCurrentDispositionDate
      , "verifiedDate" .= bankruptcyVerifiedDate
      , "priorIntentOrDispositionCode" .= bankruptcyPriorIntentOrDispositionCode
      , "dateReported" .= bankruptcyDateReported
      ]


-- | Construct a value of type 'Bankruptcy' (by applying it's required fields, if any)
mkBankruptcy
  :: Bankruptcy
mkBankruptcy =
  Bankruptcy
  { bankruptcyCustomerNumber = Nothing
  , bankruptcyType = Nothing
  , bankruptcyFiler = Nothing
  , bankruptcyIndustryCode = Nothing
  , bankruptcyCurrentIntentOrDispositionCode = Nothing
  , bankruptcyNarrativeCodes = Nothing
  , bankruptcyRawNarrativeCodes = Nothing
  , bankruptcyCaseNumber = Nothing
  , bankruptcyDispositionDate = Nothing
  , bankruptcyDateFiled = Nothing
  , bankruptcyCurrentDispositionDate = Nothing
  , bankruptcyVerifiedDate = Nothing
  , bankruptcyPriorIntentOrDispositionCode = Nothing
  , bankruptcyDateReported = Nothing
  }

-- ** BankruptcyCurrentIntentOrDispositionCode
-- | BankruptcyCurrentIntentOrDispositionCode
-- Indicates the chapter type and the current status of the bankruptcy
data BankruptcyCurrentIntentOrDispositionCode = BankruptcyCurrentIntentOrDispositionCode
  { bankruptcyCurrentIntentOrDispositionCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , bankruptcyCurrentIntentOrDispositionCodeDescription :: !(Maybe Text) -- ^ "description" - Chapter types and current status: - A: DISCHARGED CH-7 The amount owed was included in the “order of relief.” Debtor no longer liable for debts listed in “order of relief.” - C: CH-13 FILED Adjustment of debts of an individual with consistent income. Debtor petitions the court for permission to pay a percent of his income over a period of years until debt is satisfied (usually not over three years). - D: CH-11 FILED Business Reorganization. Business debtor is granted relief from payment under terms of initial contract reorganization period. - E: DISMSD/CLSD CH11 Petition for reorganization of debt has been withdrawn by debtor or honored - subject liable for debts. - F: DISCHARGED CH-11 Petition by debtor for complete relief of all debts is honored. Debtor no longer liable for debts listed in “order of relief.” - G: CH-12 FILED The Chapter 12 plan applies only to family farmers who have regular annual incomes sufficient to make payments under a proposed plan. Payment under the plan must be completed in three years. In certain situations, payment of no longer than five years is permitted. - H: DISCHARGED CH-12 A discharge is entered after the completion of all payments under the plan. However, certain payments on some long term claims, which are due after the last payment under the plan, will continue after the date of discharge. - I: INVOLUNTARY CH-7 The debtor is forced into bankruptcy by the petition of a sufficient number of his creditors. - J: DISMSD/CLSD CH12 The court may dismiss the plan or terminate the plan for various reasons, including unreasonable delays, gross mismanagement, non payment of any fees and charges, failure to file a plan in a timely manner, failure to make timely payments required by a confirmed plan, denial of confirmation or request made for additional time, and so forth. - K: DISMSD/CLSD CH13 The petition by debtor for permission to pay a percent of his income over a period of years has been withdrawn by debtor or has not been followed by debtor. Debtor remains liable for his debts under initial terms of the contract. - L: DISCHARGED CH-13 Plan by debtor to pay percent of income over a period of years has been completed. Debtor no longer liable for debts listed in payment plan. - M: DISMSD/CLSD CH7 The bankruptcy petition has been withdrawn by or has not been honored by the court. Subject remains liable for his debts under the terms of the initial contract. - V: VOLUNTARY CH-7 Bankruptcy proceeding is initiated by the debtor&#39;s own petition to be declared bankrupt and have benefit of the law. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankruptcyCurrentIntentOrDispositionCode
instance A.FromJSON BankruptcyCurrentIntentOrDispositionCode where
  parseJSON = A.withObject "BankruptcyCurrentIntentOrDispositionCode" $ \o ->
    BankruptcyCurrentIntentOrDispositionCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON BankruptcyCurrentIntentOrDispositionCode
instance A.ToJSON BankruptcyCurrentIntentOrDispositionCode where
  toJSON BankruptcyCurrentIntentOrDispositionCode {..} =
   _omitNulls
      [ "code" .= bankruptcyCurrentIntentOrDispositionCodeCode
      , "description" .= bankruptcyCurrentIntentOrDispositionCodeDescription
      ]


-- | Construct a value of type 'BankruptcyCurrentIntentOrDispositionCode' (by applying it's required fields, if any)
mkBankruptcyCurrentIntentOrDispositionCode
  :: BankruptcyCurrentIntentOrDispositionCode
mkBankruptcyCurrentIntentOrDispositionCode =
  BankruptcyCurrentIntentOrDispositionCode
  { bankruptcyCurrentIntentOrDispositionCodeCode = Nothing
  , bankruptcyCurrentIntentOrDispositionCodeDescription = Nothing
  }

-- ** BankruptcyPriorIntentOrDispositionCode
-- | BankruptcyPriorIntentOrDispositionCode
-- Chapter type and status of the bankruptcy just prior to that in the Current Intent/Disposition Code field
data BankruptcyPriorIntentOrDispositionCode = BankruptcyPriorIntentOrDispositionCode
  { bankruptcyPriorIntentOrDispositionCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , bankruptcyPriorIntentOrDispositionCodeDescription :: !(Maybe Text) -- ^ "description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankruptcyPriorIntentOrDispositionCode
instance A.FromJSON BankruptcyPriorIntentOrDispositionCode where
  parseJSON = A.withObject "BankruptcyPriorIntentOrDispositionCode" $ \o ->
    BankruptcyPriorIntentOrDispositionCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON BankruptcyPriorIntentOrDispositionCode
instance A.ToJSON BankruptcyPriorIntentOrDispositionCode where
  toJSON BankruptcyPriorIntentOrDispositionCode {..} =
   _omitNulls
      [ "code" .= bankruptcyPriorIntentOrDispositionCodeCode
      , "description" .= bankruptcyPriorIntentOrDispositionCodeDescription
      ]


-- | Construct a value of type 'BankruptcyPriorIntentOrDispositionCode' (by applying it's required fields, if any)
mkBankruptcyPriorIntentOrDispositionCode
  :: BankruptcyPriorIntentOrDispositionCode
mkBankruptcyPriorIntentOrDispositionCode =
  BankruptcyPriorIntentOrDispositionCode
  { bankruptcyPriorIntentOrDispositionCodeCode = Nothing
  , bankruptcyPriorIntentOrDispositionCodeDescription = Nothing
  }

-- ** Collection
-- | Collection
-- Provides information about any collection item
data Collection = Collection
  { collectionIndustryCode :: !(Maybe Text) -- ^ "industryCode" - Industry code
  , collectionCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - Collection agency customer number
  , collectionClientNameOrNumber :: !(Maybe Text) -- ^ "clientNameOrNumber" - Original creditor name/number
  , collectionStatusCode :: !(Maybe CollectionStatusCode) -- ^ "statusCode"
  , collectionNarrativeCodes :: !(Maybe [A.Value]) -- ^ "narrativeCodes"
  , collectionRawNarrativeCodes :: !(Maybe [Text]) -- ^ "rawNarrativeCodes" - Raw narrative codes included in the report
  , collectionIndicator :: !(Maybe Text) -- ^ "indicator" - Automated Update Indicator
  , collectionDateReported :: !(Maybe Date) -- ^ "dateReported" - Date the collection was reported to Equifax
  , collectionDateAssigned :: !(Maybe Date) -- ^ "dateAssigned" - Date Assigned
  , collectionOriginalAmount :: !(Maybe Text) -- ^ "originalAmount" - Original amount in USD
  , collectionStatusDate :: !(Maybe Date) -- ^ "statusDate" - Current Status Date
  , collectionBalance :: !(Maybe Text) -- ^ "balance" - Balance in USD
  , collectionLastPaymentDate :: !(Maybe Date) -- ^ "lastPaymentDate" - Date of most recent payment
  , collectionDateOfFirstDelinquency :: !(Maybe Date) -- ^ "dateOfFirstDelinquency" - Indicates the date of first delinquency as reported by the original creditor
  , collectionAccountNumber :: !(Maybe Text) -- ^ "accountNumber" - Account number
  , collectionAccountDesignatorCode :: !(Maybe AccountDesignatorCode) -- ^ "accountDesignatorCode"
  , collectionCreditorClassificationCode :: !(Maybe CreditorClassificationCode) -- ^ "creditorClassificationCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Collection
instance A.FromJSON Collection where
  parseJSON = A.withObject "Collection" $ \o ->
    Collection
      <$> (o .:? "industryCode")
      <*> (o .:? "customerNumber")
      <*> (o .:? "clientNameOrNumber")
      <*> (o .:? "statusCode")
      <*> (o .:? "narrativeCodes")
      <*> (o .:? "rawNarrativeCodes")
      <*> (o .:? "indicator")
      <*> (o .:? "dateReported")
      <*> (o .:? "dateAssigned")
      <*> (o .:? "originalAmount")
      <*> (o .:? "statusDate")
      <*> (o .:? "balance")
      <*> (o .:? "lastPaymentDate")
      <*> (o .:? "dateOfFirstDelinquency")
      <*> (o .:? "accountNumber")
      <*> (o .:? "accountDesignatorCode")
      <*> (o .:? "creditorClassificationCode")

-- | ToJSON Collection
instance A.ToJSON Collection where
  toJSON Collection {..} =
   _omitNulls
      [ "industryCode" .= collectionIndustryCode
      , "customerNumber" .= collectionCustomerNumber
      , "clientNameOrNumber" .= collectionClientNameOrNumber
      , "statusCode" .= collectionStatusCode
      , "narrativeCodes" .= collectionNarrativeCodes
      , "rawNarrativeCodes" .= collectionRawNarrativeCodes
      , "indicator" .= collectionIndicator
      , "dateReported" .= collectionDateReported
      , "dateAssigned" .= collectionDateAssigned
      , "originalAmount" .= collectionOriginalAmount
      , "statusDate" .= collectionStatusDate
      , "balance" .= collectionBalance
      , "lastPaymentDate" .= collectionLastPaymentDate
      , "dateOfFirstDelinquency" .= collectionDateOfFirstDelinquency
      , "accountNumber" .= collectionAccountNumber
      , "accountDesignatorCode" .= collectionAccountDesignatorCode
      , "creditorClassificationCode" .= collectionCreditorClassificationCode
      ]


-- | Construct a value of type 'Collection' (by applying it's required fields, if any)
mkCollection
  :: Collection
mkCollection =
  Collection
  { collectionIndustryCode = Nothing
  , collectionCustomerNumber = Nothing
  , collectionClientNameOrNumber = Nothing
  , collectionStatusCode = Nothing
  , collectionNarrativeCodes = Nothing
  , collectionRawNarrativeCodes = Nothing
  , collectionIndicator = Nothing
  , collectionDateReported = Nothing
  , collectionDateAssigned = Nothing
  , collectionOriginalAmount = Nothing
  , collectionStatusDate = Nothing
  , collectionBalance = Nothing
  , collectionLastPaymentDate = Nothing
  , collectionDateOfFirstDelinquency = Nothing
  , collectionAccountNumber = Nothing
  , collectionAccountDesignatorCode = Nothing
  , collectionCreditorClassificationCode = Nothing
  }

-- ** CollectionStatusCode
-- | CollectionStatusCode
-- Current status of the collection
data CollectionStatusCode = CollectionStatusCode
  { collectionStatusCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , collectionStatusCodeDescription :: !(Maybe Text) -- ^ "description" - - D: UNPAID Subject has not satisfied debt. - F: FINANCIAL COUNSELOR Identifies that a subject is receiving professional guidance on financial matters, and is under a payment plan. - J: ADJUSTMENT Settlement of a debt in which full payment is not made or when the amount involved is not certain. - M: WAGE EARNER Chapter 13 (Debtors with regular income). This chapter allows an individual to reorganize finances and protect assets while a court approved repayment plan is in effect. - N: NEW LISTING Collection account which has just been turned over for collection of past due debt. - P: PAID Subject has satisfied debt. - S: ACCOUNT DISPUTED Merchant and consumer disagree on various particulars regarding merchandise, terms of agreement or amount owing. - T: PAYMENT Subject submits portion of money owing. - U: STATUS UNKNOWN Indicates status is not verified. - X: CHECKED As of the date reported, the balance was not paid and the account was verified at the request of the consumer via a dispute. - Z: IN BANKRUPTCY The legal process under the Federal Bankruptcy Act by which debtors are granted some form of relief from their financial obligations. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CollectionStatusCode
instance A.FromJSON CollectionStatusCode where
  parseJSON = A.withObject "CollectionStatusCode" $ \o ->
    CollectionStatusCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON CollectionStatusCode
instance A.ToJSON CollectionStatusCode where
  toJSON CollectionStatusCode {..} =
   _omitNulls
      [ "code" .= collectionStatusCodeCode
      , "description" .= collectionStatusCodeDescription
      ]


-- | Construct a value of type 'CollectionStatusCode' (by applying it's required fields, if any)
mkCollectionStatusCode
  :: CollectionStatusCode
mkCollectionStatusCode =
  CollectionStatusCode
  { collectionStatusCodeCode = Nothing
  , collectionStatusCodeDescription = Nothing
  }

-- ** ConsumerCreditReport
-- | ConsumerCreditReport
data ConsumerCreditReport = ConsumerCreditReport
  { consumerCreditReportEquifaxUsConsumerCreditReport :: !(Maybe [ConsumerCreditReportEquifaxUSConsumerCreditReport]) -- ^ "equifaxUSConsumerCreditReport"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReport
instance A.FromJSON ConsumerCreditReport where
  parseJSON = A.withObject "ConsumerCreditReport" $ \o ->
    ConsumerCreditReport
      <$> (o .:? "equifaxUSConsumerCreditReport")

-- | ToJSON ConsumerCreditReport
instance A.ToJSON ConsumerCreditReport where
  toJSON ConsumerCreditReport {..} =
   _omitNulls
      [ "equifaxUSConsumerCreditReport" .= consumerCreditReportEquifaxUsConsumerCreditReport
      ]


-- | Construct a value of type 'ConsumerCreditReport' (by applying it's required fields, if any)
mkConsumerCreditReport
  :: ConsumerCreditReport
mkConsumerCreditReport =
  ConsumerCreditReport
  { consumerCreditReportEquifaxUsConsumerCreditReport = Nothing
  }

-- ** ConsumerCreditReportAlertContacts
-- | ConsumerCreditReportAlertContacts
data ConsumerCreditReportAlertContacts = ConsumerCreditReportAlertContacts
  { consumerCreditReportAlertContactsAlertType :: !(Maybe ConsumerCreditReportAlertType) -- ^ "alertType"
  , consumerCreditReportAlertContactsDateReported :: !(Maybe Date) -- ^ "dateReported" - Date of reported alert
  , consumerCreditReportAlertContactsEffectiveDate :: !(Maybe Date) -- ^ "effectiveDate" - Date the contact info became effective
  , consumerCreditReportAlertContactsStatus :: !(Maybe Text) -- ^ "status" -  - N: No Contact Information Provided 
  , consumerCreditReportAlertContactsTelephoneNumbers :: !(Maybe [ConsumerCreditReportTelephoneNumbers]) -- ^ "telephoneNumbers"
  , consumerCreditReportAlertContactsAddress :: !(Maybe AlertContactAddress) -- ^ "address"
  , consumerCreditReportAlertContactsAdditionalInformation :: !(Maybe Text) -- ^ "additionalInformation" - Free text with extra info regarding the contact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlertContacts
instance A.FromJSON ConsumerCreditReportAlertContacts where
  parseJSON = A.withObject "ConsumerCreditReportAlertContacts" $ \o ->
    ConsumerCreditReportAlertContacts
      <$> (o .:? "alertType")
      <*> (o .:? "dateReported")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "status")
      <*> (o .:? "telephoneNumbers")
      <*> (o .:? "address")
      <*> (o .:? "additionalInformation")

-- | ToJSON ConsumerCreditReportAlertContacts
instance A.ToJSON ConsumerCreditReportAlertContacts where
  toJSON ConsumerCreditReportAlertContacts {..} =
   _omitNulls
      [ "alertType" .= consumerCreditReportAlertContactsAlertType
      , "dateReported" .= consumerCreditReportAlertContactsDateReported
      , "effectiveDate" .= consumerCreditReportAlertContactsEffectiveDate
      , "status" .= consumerCreditReportAlertContactsStatus
      , "telephoneNumbers" .= consumerCreditReportAlertContactsTelephoneNumbers
      , "address" .= consumerCreditReportAlertContactsAddress
      , "additionalInformation" .= consumerCreditReportAlertContactsAdditionalInformation
      ]


-- | Construct a value of type 'ConsumerCreditReportAlertContacts' (by applying it's required fields, if any)
mkConsumerCreditReportAlertContacts
  :: ConsumerCreditReportAlertContacts
mkConsumerCreditReportAlertContacts =
  ConsumerCreditReportAlertContacts
  { consumerCreditReportAlertContactsAlertType = Nothing
  , consumerCreditReportAlertContactsDateReported = Nothing
  , consumerCreditReportAlertContactsEffectiveDate = Nothing
  , consumerCreditReportAlertContactsStatus = Nothing
  , consumerCreditReportAlertContactsTelephoneNumbers = Nothing
  , consumerCreditReportAlertContactsAddress = Nothing
  , consumerCreditReportAlertContactsAdditionalInformation = Nothing
  }

-- ** ConsumerCreditReportAlertType
-- | ConsumerCreditReportAlertType
-- Types of reported alerts
data ConsumerCreditReportAlertType = ConsumerCreditReportAlertType
  { consumerCreditReportAlertTypeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportAlertTypeDescription :: !(Maybe Text) -- ^ "description" -  - E: Extended Fraud - L: Initial Fraud - M: Military 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlertType
instance A.FromJSON ConsumerCreditReportAlertType where
  parseJSON = A.withObject "ConsumerCreditReportAlertType" $ \o ->
    ConsumerCreditReportAlertType
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportAlertType
instance A.ToJSON ConsumerCreditReportAlertType where
  toJSON ConsumerCreditReportAlertType {..} =
   _omitNulls
      [ "code" .= consumerCreditReportAlertTypeCode
      , "description" .= consumerCreditReportAlertTypeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportAlertType' (by applying it's required fields, if any)
mkConsumerCreditReportAlertType
  :: ConsumerCreditReportAlertType
mkConsumerCreditReportAlertType =
  ConsumerCreditReportAlertType
  { consumerCreditReportAlertTypeCode = Nothing
  , consumerCreditReportAlertTypeDescription = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSources
-- | ConsumerCreditReportAlternateDataSources
-- Contains the output data for the Optional Alternate Data Sources. These Alternate Data Sources are: - Military Lending Covered Borrower Status - North American Link - FraudIQ® Synthetic ID Alert 
data ConsumerCreditReportAlternateDataSources = ConsumerCreditReportAlternateDataSources
  { consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage :: !(Maybe [ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage]) -- ^ "alternateDataSourceErrorMessage" - It&#39;s returned whenever it encounters a communication problem or an error with the request of an Alternate Data Source. A separate \&quot;DERR\&quot; element will be returned per Data Source.  DERR: Alternate Data Source Message Response   CODE DESCRIPTION:   - 2001: COMMUNICATION ERROR   - 2002: COMMUNICATION ERROR   - 2003: COMMUNICATION ERROR   - 2004: COMMUNICATION ERROR   - 2005: COMMUNICATION ERROR   - 2006: COMMUNICATION ERROR   - 2007: COMMUNICATION ERROR   - 2008: COMMUNICATION ERROR   - 2009: COMMUNICATION ERROR   - 2010: COMMUNICATION ERROR   - 2011: COMMUNICATION ERROR   - 2012: COMMUNICATION ERROR   - 2013: COMMUNICATION ERROR   - 2014: COMMUNICATION ERROR   - 2015: COMMUNICATION ERROR   - 2016: COMMUNICATION ERROR   - 2017: COMMUNICATION ERROR   - 2018: COMMUNICATION ERROR   - 2019: COMMUNICATION ERROR   - 2020: COMMUNICATION ERROR   - 2021: COMMUNICATION ERROR   - 2022: COMMUNICATION ERROR   - 2023: COMMUNICATION ERROR   - 2024: COMMUNICATION ERROR   - 2025: COMMUNICATION ERROR 
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower :: !(Maybe ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower) -- ^ "militaryLendingCoveredBorrower"
  , consumerCreditReportAlternateDataSourcesNorthAmericanLink :: !(Maybe ConsumerCreditReportAlternateDataSourcesNorthAmericanLink) -- ^ "northAmericanLink"
  , consumerCreditReportAlternateDataSourcesFraudIqSyntheticIdAlerts :: !(Maybe ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts) -- ^ "fraudIQSyntheticIDAlerts"
  , consumerCreditReportAlternateDataSourcesFraudIqSyntheticIdv2Alerts :: !(Maybe ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts) -- ^ "fraudIQSyntheticIDV2Alerts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSources
instance A.FromJSON ConsumerCreditReportAlternateDataSources where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSources" $ \o ->
    ConsumerCreditReportAlternateDataSources
      <$> (o .:? "alternateDataSourceErrorMessage")
      <*> (o .:? "militaryLendingCoveredBorrower")
      <*> (o .:? "northAmericanLink")
      <*> (o .:? "fraudIQSyntheticIDAlerts")
      <*> (o .:? "fraudIQSyntheticIDV2Alerts")

-- | ToJSON ConsumerCreditReportAlternateDataSources
instance A.ToJSON ConsumerCreditReportAlternateDataSources where
  toJSON ConsumerCreditReportAlternateDataSources {..} =
   _omitNulls
      [ "alternateDataSourceErrorMessage" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
      , "militaryLendingCoveredBorrower" .= consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
      , "northAmericanLink" .= consumerCreditReportAlternateDataSourcesNorthAmericanLink
      , "fraudIQSyntheticIDAlerts" .= consumerCreditReportAlternateDataSourcesFraudIqSyntheticIdAlerts
      , "fraudIQSyntheticIDV2Alerts" .= consumerCreditReportAlternateDataSourcesFraudIqSyntheticIdv2Alerts
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSources' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSources
  :: ConsumerCreditReportAlternateDataSources
mkConsumerCreditReportAlternateDataSources =
  ConsumerCreditReportAlternateDataSources
  { consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage = Nothing
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower = Nothing
  , consumerCreditReportAlternateDataSourcesNorthAmericanLink = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIqSyntheticIdAlerts = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIqSyntheticIdv2Alerts = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
-- | ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
data ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode = ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
  { consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeDescription :: !(Maybe Text) -- ^ "description" - Description for the given code
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeErrorCodes :: !(Maybe [ConsumerCreditReportAlternateDataSourcesErrorCodes]) -- ^ "errorCodes" - Container for all the errors returned by the Alternate Data Sources
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode" $ \o ->
    ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
      <$> (o .:? "code")
      <*> (o .:? "description")
      <*> (o .:? "errorCodes")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode where
  toJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeCode
      , "description" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeDescription
      , "errorCodes" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeErrorCodes
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
  :: ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
mkConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode =
  ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode
  { consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeCode = Nothing
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeDescription = Nothing
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceCodeErrorCodes = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
-- | ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
-- Returned if an error occurs
data ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage = ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
  { consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageCustomerReferenceNumber :: !(Maybe Text) -- ^ "customerReferenceNumber" - This field will return the same value provided in the request
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - This field returns the same value provided in the request
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageErrorType :: !(Maybe Text) -- ^ "errorType"
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageAlternateDataSourceCode :: !(Maybe [ConsumerCreditReportAlternateDataSourcesAlternateDataSourceCode]) -- ^ "alternateDataSourceCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage" $ \o ->
    ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
      <$> (o .:? "customerReferenceNumber")
      <*> (o .:? "customerNumber")
      <*> (o .:? "errorType")
      <*> (o .:? "alternateDataSourceCode")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage where
  toJSON ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage {..} =
   _omitNulls
      [ "customerReferenceNumber" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageCustomerReferenceNumber
      , "customerNumber" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageCustomerNumber
      , "errorType" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageErrorType
      , "alternateDataSourceCode" .= consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageAlternateDataSourceCode
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
  :: ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
mkConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage =
  ConsumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessage
  { consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageCustomerReferenceNumber = Nothing
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageCustomerNumber = Nothing
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageErrorType = Nothing
  , consumerCreditReportAlternateDataSourcesAlternateDataSourceErrorMessageAlternateDataSourceCode = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesErrorCodes
-- | ConsumerCreditReportAlternateDataSourcesErrorCodes
-- Describes the error
data ConsumerCreditReportAlternateDataSourcesErrorCodes = ConsumerCreditReportAlternateDataSourcesErrorCodes
  { consumerCreditReportAlternateDataSourcesErrorCodesVerbiage :: !(Maybe Text) -- ^ "verbiage" - Verbiage returned for error code
  , consumerCreditReportAlternateDataSourcesErrorCodesErrorText :: !(Maybe Text) -- ^ "errorText" - Error description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesErrorCodes
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesErrorCodes where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesErrorCodes" $ \o ->
    ConsumerCreditReportAlternateDataSourcesErrorCodes
      <$> (o .:? "verbiage")
      <*> (o .:? "errorText")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesErrorCodes
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesErrorCodes where
  toJSON ConsumerCreditReportAlternateDataSourcesErrorCodes {..} =
   _omitNulls
      [ "verbiage" .= consumerCreditReportAlternateDataSourcesErrorCodesVerbiage
      , "errorText" .= consumerCreditReportAlternateDataSourcesErrorCodesErrorText
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesErrorCodes' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesErrorCodes
  :: ConsumerCreditReportAlternateDataSourcesErrorCodes
mkConsumerCreditReportAlternateDataSourcesErrorCodes =
  ConsumerCreditReportAlternateDataSourcesErrorCodes
  { consumerCreditReportAlternateDataSourcesErrorCodesVerbiage = Nothing
  , consumerCreditReportAlternateDataSourcesErrorCodesErrorText = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
-- | ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
-- FraudIQ Synthetic ID Alerts provide real‐time alerts that help determine if the identity presented is real or synthetic
data ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts = ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
  { consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNonRegulatedIdentifier :: !(Maybe Text) -- ^ "nonRegulatedIdentifier" - \\&#39;NR\\&#39; Non Regulated Data Source
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsHitNohitIndicator :: !(Maybe Text) -- ^ "hitNohitIndicator" - If there was a response back from the data source or not
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsDisclaimer :: !(Maybe Text) -- ^ "disclaimer" - DISCLAIMER:[SYNTHETIC ID ALERT]  Indicator is for identity fraud risk alert purposes only and is not to be used for determining an individual’s eligibility for any credit or any other FCRA permissible purpose. Client shall use the [SYNTHETIC ID ALERT]  exclusively within Client’s own organization for the purpose of identity fraud prevention.  Accordingly, Client will not use an alert or warning message from the [SYNTHETIC ID ALERT] system in its decision-making process for denying credit, but will use the message as an indication that the consumer&#39;s identity and personally identifiable information should be independently verified to form a reasonable belief that it knows the true identity of the consumer. Client understands that the information supplied by [SYNTHETIC ID ALERT] may or may not apply to the consumer who has applied to Client for credit, service, dealings, or other financial transactions. Client also understands and agrees that data from the [SYNTHETIC ID ALERT] system is proprietary to Equifax and shall not be used as a component of any database or file built or maintained by Client. The use of such data shall be limited to the specific transaction for which the [SYNTHETIC ID ALERT] message is provided. Equifax may, by written notice to Client, immediately terminate the Client’s agreement for service or suspend the [SYNTHETIC ID ALERT] service if Equifax has a reasonable belief that Client has violated the terms of this disclaimer or the agreement for service. 
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsFinalAssessmentFlag :: !(Maybe Text) -- ^ "finalAssessmentFlag" - Final Synthetic ID Alert assessment will be Y if either Authorized User Velocity (AUV) Flag or ID Discrepancy Flag are Y 
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsAuthorizedUserVelocityFlag :: !(Maybe Text) -- ^ "authorizedUserVelocityFlag" - Flag will be Y if combination of Number Authorized users &amp; Number Terminated trades meets the defined criteria for the AUV Flag 
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsIdDiscrepancyFlag :: !(Maybe Text) -- ^ "idDiscrepancyFlag" - Flag will be Y if it meets the defined criteria for the current Identity discrepancy attributes (based on patterns exhibited by synthetic fraudsters and identity mismatches between authorized users and primary account holders like count of last name mismatches, etc) 
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNumberOfAuthorizedUsers :: !(Maybe Text) -- ^ "numberOfAuthorizedUsers" - Count of active Authorized Users potentially associated with consumer
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNumberOfTerminatedUsers :: !(Maybe Text) -- ^ "numberOfTerminatedUsers" - Count of Terminated Trades potentially associated with consumer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts" $ \o ->
    ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
      <$> (o .:? "nonRegulatedIdentifier")
      <*> (o .:? "hitNohitIndicator")
      <*> (o .:? "disclaimer")
      <*> (o .:? "finalAssessmentFlag")
      <*> (o .:? "authorizedUserVelocityFlag")
      <*> (o .:? "idDiscrepancyFlag")
      <*> (o .:? "numberOfAuthorizedUsers")
      <*> (o .:? "numberOfTerminatedUsers")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts where
  toJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts {..} =
   _omitNulls
      [ "nonRegulatedIdentifier" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNonRegulatedIdentifier
      , "hitNohitIndicator" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsHitNohitIndicator
      , "disclaimer" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsDisclaimer
      , "finalAssessmentFlag" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsFinalAssessmentFlag
      , "authorizedUserVelocityFlag" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsAuthorizedUserVelocityFlag
      , "idDiscrepancyFlag" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsIdDiscrepancyFlag
      , "numberOfAuthorizedUsers" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNumberOfAuthorizedUsers
      , "numberOfTerminatedUsers" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNumberOfTerminatedUsers
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
  :: ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
mkConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts =
  ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlerts
  { consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNonRegulatedIdentifier = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsHitNohitIndicator = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsDisclaimer = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsFinalAssessmentFlag = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsAuthorizedUserVelocityFlag = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsIdDiscrepancyFlag = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNumberOfAuthorizedUsers = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDAlertsNumberOfTerminatedUsers = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
-- | ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
-- FraudIQ Synthetic ID Ver 2 Alerts (Expanded) provide real‐time alerts that help determine if the identity presented is real or synthetic. The syntheticIDVer2 object will be returned in JSON only and includes a Disclaimer, Alert Flags and a Billing Code.
data ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts = ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
  { consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsNonRegulatedIdentifier :: !(Maybe Text) -- ^ "nonRegulatedIdentifier" - \\&#39;NR\\&#39; Non Regulated Data Source
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsHitNohitIndicator :: !(Maybe Text) -- ^ "hitNohitIndicator" - If there was a response back from the data source or not
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsSyntheticIdVer2 :: !(Maybe Text) -- ^ "syntheticIdVer2" - FraudIQ Synthetic ID Ver 2 Alerts (Expanded) provide real‐time alerts that help determine if the identity presented is real or synthetic.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts" $ \o ->
    ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
      <$> (o .:? "nonRegulatedIdentifier")
      <*> (o .:? "hitNohitIndicator")
      <*> (o .:? "syntheticIdVer2")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts where
  toJSON ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts {..} =
   _omitNulls
      [ "nonRegulatedIdentifier" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsNonRegulatedIdentifier
      , "hitNohitIndicator" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsHitNohitIndicator
      , "syntheticIdVer2" .= consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsSyntheticIdVer2
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
  :: ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
mkConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts =
  ConsumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2Alerts
  { consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsNonRegulatedIdentifier = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsHitNohitIndicator = Nothing
  , consumerCreditReportAlternateDataSourcesFraudIQSyntheticIDV2AlertsSyntheticIdVer2 = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
-- | ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
-- Provides information relating to the Military Lending Act – MLA Covered Borrower Status.
data ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower = ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
  { consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerRegulatedIdentifier :: !(Maybe Text) -- ^ "regulatedIdentifier" - RG - indicates that this is Regulated Data
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerDisclaimer :: !(Maybe Text) -- ^ "disclaimer" - Diclaimer Text THE DEPARTMENT OF DEFENSE (\&quot;DOD\&quot;) COVERED BORROWER DATA (\&quot;DATA\&quot;) IS FROM THE DEFENSE MANPOWER DATA CENTER (\&quot;DMDC\&quot;) BY WAY OF CONTRACT BETWEEN EQUIFAX INFORMATION SERVICES LLC (\&quot;EQUIFAX\&quot;) AND DOD. ALL DOD DATA IS USED AND STORED BY EQUIFAX IN ACCORDANCE WITH ITS LEGAL AND CONTRACTUAL OBLIGATIONS. THE DOD DATA IS NOT PART OF EQUIFAX’S NATIONWIDE CREDIT DATABASE, AND EQUIFAX IS REQUIRED TO MAINTAIN THE DOD DATA SEPARATE FROM AND NOT COMMINGLED WITH ANY CREDIT DATA MAINTAINED BY EQUIFAX. 
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerCoveredBorrowerStatus :: !(Maybe Text) -- ^ "coveredBorrowerStatus" - Yes or No in Military
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerInsufficientDataProvidedForMatch :: !(Maybe Text) -- ^ "insufficientDataProvidedForMatch" - Insufficient data provided for match
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerReferralContactNumber :: !(Maybe Text) -- ^ "referralContactNumber" - Contact number for MLA
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower" $ \o ->
    ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
      <$> (o .:? "regulatedIdentifier")
      <*> (o .:? "disclaimer")
      <*> (o .:? "coveredBorrowerStatus")
      <*> (o .:? "insufficientDataProvidedForMatch")
      <*> (o .:? "referralContactNumber")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower where
  toJSON ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower {..} =
   _omitNulls
      [ "regulatedIdentifier" .= consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerRegulatedIdentifier
      , "disclaimer" .= consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerDisclaimer
      , "coveredBorrowerStatus" .= consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerCoveredBorrowerStatus
      , "insufficientDataProvidedForMatch" .= consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerInsufficientDataProvidedForMatch
      , "referralContactNumber" .= consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerReferralContactNumber
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
  :: ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
mkConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower =
  ConsumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrower
  { consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerRegulatedIdentifier = Nothing
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerDisclaimer = Nothing
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerCoveredBorrowerStatus = Nothing
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerInsufficientDataProvidedForMatch = Nothing
  , consumerCreditReportAlternateDataSourcesMilitaryLendingCoveredBorrowerReferralContactNumber = Nothing
  }

-- ** ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
-- | ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
-- NAL - Canadian Credit Report for Consumer's Canadian Address
data ConsumerCreditReportAlternateDataSourcesNorthAmericanLink = ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
  { consumerCreditReportAlternateDataSourcesNorthAmericanLinkRegulatedIdentifier :: !(Maybe Text) -- ^ "regulatedIdentifier" - \\&#39;RG\\&#39; for Regulated Data Source
  , consumerCreditReportAlternateDataSourcesNorthAmericanLinkHitNohitIndicator :: !(Maybe Text) -- ^ "hitNohitIndicator" - If there was a responce back from the data source or not
  , consumerCreditReportAlternateDataSourcesNorthAmericanLinkIntl5FffConsumerReport :: !(Maybe Text) -- ^ "INTL5FFFConsumerReport" - Contents of the Canadian Report returned
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
instance A.FromJSON ConsumerCreditReportAlternateDataSourcesNorthAmericanLink where
  parseJSON = A.withObject "ConsumerCreditReportAlternateDataSourcesNorthAmericanLink" $ \o ->
    ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
      <$> (o .:? "regulatedIdentifier")
      <*> (o .:? "hitNohitIndicator")
      <*> (o .:? "INTL5FFFConsumerReport")

-- | ToJSON ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
instance A.ToJSON ConsumerCreditReportAlternateDataSourcesNorthAmericanLink where
  toJSON ConsumerCreditReportAlternateDataSourcesNorthAmericanLink {..} =
   _omitNulls
      [ "regulatedIdentifier" .= consumerCreditReportAlternateDataSourcesNorthAmericanLinkRegulatedIdentifier
      , "hitNohitIndicator" .= consumerCreditReportAlternateDataSourcesNorthAmericanLinkHitNohitIndicator
      , "INTL5FFFConsumerReport" .= consumerCreditReportAlternateDataSourcesNorthAmericanLinkIntl5FffConsumerReport
      ]


-- | Construct a value of type 'ConsumerCreditReportAlternateDataSourcesNorthAmericanLink' (by applying it's required fields, if any)
mkConsumerCreditReportAlternateDataSourcesNorthAmericanLink
  :: ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
mkConsumerCreditReportAlternateDataSourcesNorthAmericanLink =
  ConsumerCreditReportAlternateDataSourcesNorthAmericanLink
  { consumerCreditReportAlternateDataSourcesNorthAmericanLinkRegulatedIdentifier = Nothing
  , consumerCreditReportAlternateDataSourcesNorthAmericanLinkHitNohitIndicator = Nothing
  , consumerCreditReportAlternateDataSourcesNorthAmericanLinkIntl5FffConsumerReport = Nothing
  }

-- ** ConsumerCreditReportAttributes
-- | ConsumerCreditReportAttributes
data ConsumerCreditReportAttributes = ConsumerCreditReportAttributes
  { consumerCreditReportAttributesIdentifier :: !(Maybe Text) -- ^ "identifier" - Variable identifier
  , consumerCreditReportAttributesValue :: !(Maybe Text) -- ^ "value" - Value of the variable
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAttributes
instance A.FromJSON ConsumerCreditReportAttributes where
  parseJSON = A.withObject "ConsumerCreditReportAttributes" $ \o ->
    ConsumerCreditReportAttributes
      <$> (o .:? "identifier")
      <*> (o .:? "value")

-- | ToJSON ConsumerCreditReportAttributes
instance A.ToJSON ConsumerCreditReportAttributes where
  toJSON ConsumerCreditReportAttributes {..} =
   _omitNulls
      [ "identifier" .= consumerCreditReportAttributesIdentifier
      , "value" .= consumerCreditReportAttributesValue
      ]


-- | Construct a value of type 'ConsumerCreditReportAttributes' (by applying it's required fields, if any)
mkConsumerCreditReportAttributes
  :: ConsumerCreditReportAttributes
mkConsumerCreditReportAttributes =
  ConsumerCreditReportAttributes
  { consumerCreditReportAttributesIdentifier = Nothing
  , consumerCreditReportAttributesValue = Nothing
  }

-- ** ConsumerCreditReportAttributes1
-- | ConsumerCreditReportAttributes1
-- Model Attribute data
data ConsumerCreditReportAttributes1 = ConsumerCreditReportAttributes1
  { consumerCreditReportAttributes1ModelNumber :: !(Maybe Text) -- ^ "modelNumber" - Model number
  , consumerCreditReportAttributes1NumberOfVariableFields :: !(Maybe Text) -- ^ "numberOfVariableFields" - Indicates the number of fields with variables being returned
  , consumerCreditReportAttributes1Attributes :: !(Maybe [ConsumerCreditReportAttributes]) -- ^ "attributes" - Fields with variables being returned
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportAttributes1
instance A.FromJSON ConsumerCreditReportAttributes1 where
  parseJSON = A.withObject "ConsumerCreditReportAttributes1" $ \o ->
    ConsumerCreditReportAttributes1
      <$> (o .:? "modelNumber")
      <*> (o .:? "numberOfVariableFields")
      <*> (o .:? "attributes")

-- | ToJSON ConsumerCreditReportAttributes1
instance A.ToJSON ConsumerCreditReportAttributes1 where
  toJSON ConsumerCreditReportAttributes1 {..} =
   _omitNulls
      [ "modelNumber" .= consumerCreditReportAttributes1ModelNumber
      , "numberOfVariableFields" .= consumerCreditReportAttributes1NumberOfVariableFields
      , "attributes" .= consumerCreditReportAttributes1Attributes
      ]


-- | Construct a value of type 'ConsumerCreditReportAttributes1' (by applying it's required fields, if any)
mkConsumerCreditReportAttributes1
  :: ConsumerCreditReportAttributes1
mkConsumerCreditReportAttributes1 =
  ConsumerCreditReportAttributes1
  { consumerCreditReportAttributes1ModelNumber = Nothing
  , consumerCreditReportAttributes1NumberOfVariableFields = Nothing
  , consumerCreditReportAttributes1Attributes = Nothing
  }

-- ** ConsumerCreditReportConsumerReferralLocation
-- | ConsumerCreditReportConsumerReferralLocation
-- Provides contact information regarding the data contained in the report
data ConsumerCreditReportConsumerReferralLocation = ConsumerCreditReportConsumerReferralLocation
  { consumerCreditReportConsumerReferralLocationBureauCode :: !(Maybe Text) -- ^ "bureauCode" - Refereal Bureau Code
  , consumerCreditReportConsumerReferralLocationBureauName :: !(Maybe Text) -- ^ "bureauName" - Referral Bureau Name
  , consumerCreditReportConsumerReferralLocationAddress :: !(Maybe ConsumerCreditReportConsumerReferralLocationAddress) -- ^ "address"
  , consumerCreditReportConsumerReferralLocationTelephoneNumber :: !(Maybe ConsumerCreditReportConsumerReferralLocationTelephoneNumber) -- ^ "telephoneNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportConsumerReferralLocation
instance A.FromJSON ConsumerCreditReportConsumerReferralLocation where
  parseJSON = A.withObject "ConsumerCreditReportConsumerReferralLocation" $ \o ->
    ConsumerCreditReportConsumerReferralLocation
      <$> (o .:? "bureauCode")
      <*> (o .:? "bureauName")
      <*> (o .:? "address")
      <*> (o .:? "telephoneNumber")

-- | ToJSON ConsumerCreditReportConsumerReferralLocation
instance A.ToJSON ConsumerCreditReportConsumerReferralLocation where
  toJSON ConsumerCreditReportConsumerReferralLocation {..} =
   _omitNulls
      [ "bureauCode" .= consumerCreditReportConsumerReferralLocationBureauCode
      , "bureauName" .= consumerCreditReportConsumerReferralLocationBureauName
      , "address" .= consumerCreditReportConsumerReferralLocationAddress
      , "telephoneNumber" .= consumerCreditReportConsumerReferralLocationTelephoneNumber
      ]


-- | Construct a value of type 'ConsumerCreditReportConsumerReferralLocation' (by applying it's required fields, if any)
mkConsumerCreditReportConsumerReferralLocation
  :: ConsumerCreditReportConsumerReferralLocation
mkConsumerCreditReportConsumerReferralLocation =
  ConsumerCreditReportConsumerReferralLocation
  { consumerCreditReportConsumerReferralLocationBureauCode = Nothing
  , consumerCreditReportConsumerReferralLocationBureauName = Nothing
  , consumerCreditReportConsumerReferralLocationAddress = Nothing
  , consumerCreditReportConsumerReferralLocationTelephoneNumber = Nothing
  }

-- ** ConsumerCreditReportConsumerReferralLocationAddress
-- | ConsumerCreditReportConsumerReferralLocationAddress
data ConsumerCreditReportConsumerReferralLocationAddress = ConsumerCreditReportConsumerReferralLocationAddress
  { consumerCreditReportConsumerReferralLocationAddressPrimaryAddress :: !(Maybe Text) -- ^ "primaryAddress" - Referral Bureau primary address
  , consumerCreditReportConsumerReferralLocationAddressSecondaryAddress :: !(Maybe Text) -- ^ "secondaryAddress" - Referral Bureau secondary address
  , consumerCreditReportConsumerReferralLocationAddressCityName :: !(Maybe Text) -- ^ "cityName" - City name
  , consumerCreditReportConsumerReferralLocationAddressStateAbbreviation :: !(Maybe Text) -- ^ "stateAbbreviation" - State name&#39;s abbreviation
  , consumerCreditReportConsumerReferralLocationAddressZipCode :: !(Maybe Text) -- ^ "zipCode" - Zip code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportConsumerReferralLocationAddress
instance A.FromJSON ConsumerCreditReportConsumerReferralLocationAddress where
  parseJSON = A.withObject "ConsumerCreditReportConsumerReferralLocationAddress" $ \o ->
    ConsumerCreditReportConsumerReferralLocationAddress
      <$> (o .:? "primaryAddress")
      <*> (o .:? "secondaryAddress")
      <*> (o .:? "cityName")
      <*> (o .:? "stateAbbreviation")
      <*> (o .:? "zipCode")

-- | ToJSON ConsumerCreditReportConsumerReferralLocationAddress
instance A.ToJSON ConsumerCreditReportConsumerReferralLocationAddress where
  toJSON ConsumerCreditReportConsumerReferralLocationAddress {..} =
   _omitNulls
      [ "primaryAddress" .= consumerCreditReportConsumerReferralLocationAddressPrimaryAddress
      , "secondaryAddress" .= consumerCreditReportConsumerReferralLocationAddressSecondaryAddress
      , "cityName" .= consumerCreditReportConsumerReferralLocationAddressCityName
      , "stateAbbreviation" .= consumerCreditReportConsumerReferralLocationAddressStateAbbreviation
      , "zipCode" .= consumerCreditReportConsumerReferralLocationAddressZipCode
      ]


-- | Construct a value of type 'ConsumerCreditReportConsumerReferralLocationAddress' (by applying it's required fields, if any)
mkConsumerCreditReportConsumerReferralLocationAddress
  :: ConsumerCreditReportConsumerReferralLocationAddress
mkConsumerCreditReportConsumerReferralLocationAddress =
  ConsumerCreditReportConsumerReferralLocationAddress
  { consumerCreditReportConsumerReferralLocationAddressPrimaryAddress = Nothing
  , consumerCreditReportConsumerReferralLocationAddressSecondaryAddress = Nothing
  , consumerCreditReportConsumerReferralLocationAddressCityName = Nothing
  , consumerCreditReportConsumerReferralLocationAddressStateAbbreviation = Nothing
  , consumerCreditReportConsumerReferralLocationAddressZipCode = Nothing
  }

-- ** ConsumerCreditReportConsumerReferralLocationTelephoneNumber
-- | ConsumerCreditReportConsumerReferralLocationTelephoneNumber
-- Telephone number including a valid area code
data ConsumerCreditReportConsumerReferralLocationTelephoneNumber = ConsumerCreditReportConsumerReferralLocationTelephoneNumber
  { consumerCreditReportConsumerReferralLocationTelephoneNumberTelephoneNumber :: !(Maybe Text) -- ^ "TelephoneNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportConsumerReferralLocationTelephoneNumber
instance A.FromJSON ConsumerCreditReportConsumerReferralLocationTelephoneNumber where
  parseJSON = A.withObject "ConsumerCreditReportConsumerReferralLocationTelephoneNumber" $ \o ->
    ConsumerCreditReportConsumerReferralLocationTelephoneNumber
      <$> (o .:? "TelephoneNumber")

-- | ToJSON ConsumerCreditReportConsumerReferralLocationTelephoneNumber
instance A.ToJSON ConsumerCreditReportConsumerReferralLocationTelephoneNumber where
  toJSON ConsumerCreditReportConsumerReferralLocationTelephoneNumber {..} =
   _omitNulls
      [ "TelephoneNumber" .= consumerCreditReportConsumerReferralLocationTelephoneNumberTelephoneNumber
      ]


-- | Construct a value of type 'ConsumerCreditReportConsumerReferralLocationTelephoneNumber' (by applying it's required fields, if any)
mkConsumerCreditReportConsumerReferralLocationTelephoneNumber
  :: ConsumerCreditReportConsumerReferralLocationTelephoneNumber
mkConsumerCreditReportConsumerReferralLocationTelephoneNumber =
  ConsumerCreditReportConsumerReferralLocationTelephoneNumber
  { consumerCreditReportConsumerReferralLocationTelephoneNumberTelephoneNumber = Nothing
  }

-- ** ConsumerCreditReportConsumerStatements
-- | ConsumerCreditReportConsumerStatements
data ConsumerCreditReportConsumerStatements = ConsumerCreditReportConsumerStatements
  { consumerCreditReportConsumerStatementsDateReported :: !(Maybe Text) -- ^ "dateReported" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , consumerCreditReportConsumerStatementsDatePurged :: !(Maybe Text) -- ^ "datePurged" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , consumerCreditReportConsumerStatementsStatement :: !(Maybe Text) -- ^ "statement" - Consumer Statement text
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportConsumerStatements
instance A.FromJSON ConsumerCreditReportConsumerStatements where
  parseJSON = A.withObject "ConsumerCreditReportConsumerStatements" $ \o ->
    ConsumerCreditReportConsumerStatements
      <$> (o .:? "dateReported")
      <*> (o .:? "datePurged")
      <*> (o .:? "statement")

-- | ToJSON ConsumerCreditReportConsumerStatements
instance A.ToJSON ConsumerCreditReportConsumerStatements where
  toJSON ConsumerCreditReportConsumerStatements {..} =
   _omitNulls
      [ "dateReported" .= consumerCreditReportConsumerStatementsDateReported
      , "datePurged" .= consumerCreditReportConsumerStatementsDatePurged
      , "statement" .= consumerCreditReportConsumerStatementsStatement
      ]


-- | Construct a value of type 'ConsumerCreditReportConsumerStatements' (by applying it's required fields, if any)
mkConsumerCreditReportConsumerStatements
  :: ConsumerCreditReportConsumerStatements
mkConsumerCreditReportConsumerStatements =
  ConsumerCreditReportConsumerStatements
  { consumerCreditReportConsumerStatementsDateReported = Nothing
  , consumerCreditReportConsumerStatementsDatePurged = Nothing
  , consumerCreditReportConsumerStatementsStatement = Nothing
  }

-- ** ConsumerCreditReportEDASIndicatorCode
-- | ConsumerCreditReportEDASIndicatorCode
-- The EDAS/FEDAS indicator
data ConsumerCreditReportEDASIndicatorCode = ConsumerCreditReportEDASIndicatorCode
  { consumerCreditReportEDASIndicatorCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportEDASIndicatorCodeDescription :: !(Maybe Text) -- ^ "description" -  - E: Enhanced DAS - F: FACTA EDAS Enhanced Delinquency Alert System (EDAS) and FACTA Enhanced Delinquency Alert System (EDAS) are optional products offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation of the Enhanced Delinquency Alert System (EDAS) option you desire. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportEDASIndicatorCode
instance A.FromJSON ConsumerCreditReportEDASIndicatorCode where
  parseJSON = A.withObject "ConsumerCreditReportEDASIndicatorCode" $ \o ->
    ConsumerCreditReportEDASIndicatorCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportEDASIndicatorCode
instance A.ToJSON ConsumerCreditReportEDASIndicatorCode where
  toJSON ConsumerCreditReportEDASIndicatorCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportEDASIndicatorCodeCode
      , "description" .= consumerCreditReportEDASIndicatorCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportEDASIndicatorCode' (by applying it's required fields, if any)
mkConsumerCreditReportEDASIndicatorCode
  :: ConsumerCreditReportEDASIndicatorCode
mkConsumerCreditReportEDASIndicatorCode =
  ConsumerCreditReportEDASIndicatorCode
  { consumerCreditReportEDASIndicatorCodeCode = Nothing
  , consumerCreditReportEDASIndicatorCodeDescription = Nothing
  }

-- ** ConsumerCreditReportEDASRegionalIndicatorCode
-- | ConsumerCreditReportEDASRegionalIndicatorCode
-- Numeric code associated with a geographic region
data ConsumerCreditReportEDASRegionalIndicatorCode = ConsumerCreditReportEDASRegionalIndicatorCode
  { consumerCreditReportEDASRegionalIndicatorCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportEDASRegionalIndicatorCodeDescription :: !(Maybe Text) -- ^ "description" -  - 1: SOUTH - 2: WEST - 3: CENTRAL - 4: NORTHEAST 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportEDASRegionalIndicatorCode
instance A.FromJSON ConsumerCreditReportEDASRegionalIndicatorCode where
  parseJSON = A.withObject "ConsumerCreditReportEDASRegionalIndicatorCode" $ \o ->
    ConsumerCreditReportEDASRegionalIndicatorCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportEDASRegionalIndicatorCode
instance A.ToJSON ConsumerCreditReportEDASRegionalIndicatorCode where
  toJSON ConsumerCreditReportEDASRegionalIndicatorCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportEDASRegionalIndicatorCodeCode
      , "description" .= consumerCreditReportEDASRegionalIndicatorCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportEDASRegionalIndicatorCode' (by applying it's required fields, if any)
mkConsumerCreditReportEDASRegionalIndicatorCode
  :: ConsumerCreditReportEDASRegionalIndicatorCode
mkConsumerCreditReportEDASRegionalIndicatorCode =
  ConsumerCreditReportEDASRegionalIndicatorCode
  { consumerCreditReportEDASRegionalIndicatorCodeCode = Nothing
  , consumerCreditReportEDASRegionalIndicatorCodeDescription = Nothing
  }

-- ** ConsumerCreditReportEmployments
-- | ConsumerCreditReportEmployments
data ConsumerCreditReportEmployments = ConsumerCreditReportEmployments
  { consumerCreditReportEmploymentsIdentifier :: !(Maybe Text) -- ^ "identifier" - It describes the type of employment
  , consumerCreditReportEmploymentsOccupation :: !(Maybe Text) -- ^ "occupation" - Subject&#39;s occupation
  , consumerCreditReportEmploymentsEmployer :: !(Maybe Text) -- ^ "employer" - Employer&#39;s name
  , consumerCreditReportEmploymentsDateLastReported :: !(Maybe Text) -- ^ "dateLastReported" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , consumerCreditReportEmploymentsDateFirstReported :: !(Maybe Text) -- ^ "dateFirstReported" - Date in format MMYYYY where MM is the Month and YYYY is the year
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportEmployments
instance A.FromJSON ConsumerCreditReportEmployments where
  parseJSON = A.withObject "ConsumerCreditReportEmployments" $ \o ->
    ConsumerCreditReportEmployments
      <$> (o .:? "identifier")
      <*> (o .:? "occupation")
      <*> (o .:? "employer")
      <*> (o .:? "dateLastReported")
      <*> (o .:? "dateFirstReported")

-- | ToJSON ConsumerCreditReportEmployments
instance A.ToJSON ConsumerCreditReportEmployments where
  toJSON ConsumerCreditReportEmployments {..} =
   _omitNulls
      [ "identifier" .= consumerCreditReportEmploymentsIdentifier
      , "occupation" .= consumerCreditReportEmploymentsOccupation
      , "employer" .= consumerCreditReportEmploymentsEmployer
      , "dateLastReported" .= consumerCreditReportEmploymentsDateLastReported
      , "dateFirstReported" .= consumerCreditReportEmploymentsDateFirstReported
      ]


-- | Construct a value of type 'ConsumerCreditReportEmployments' (by applying it's required fields, if any)
mkConsumerCreditReportEmployments
  :: ConsumerCreditReportEmployments
mkConsumerCreditReportEmployments =
  ConsumerCreditReportEmployments
  { consumerCreditReportEmploymentsIdentifier = Nothing
  , consumerCreditReportEmploymentsOccupation = Nothing
  , consumerCreditReportEmploymentsEmployer = Nothing
  , consumerCreditReportEmploymentsDateLastReported = Nothing
  , consumerCreditReportEmploymentsDateFirstReported = Nothing
  }

-- ** ConsumerCreditReportEquifaxUSConsumerCreditReport
-- | ConsumerCreditReportEquifaxUSConsumerCreditReport
data ConsumerCreditReportEquifaxUSConsumerCreditReport = ConsumerCreditReportEquifaxUSConsumerCreditReport
  { consumerCreditReportEquifaxUSConsumerCreditReportIdentifier :: !(Maybe Text) -- ^ "identifier"
  , consumerCreditReportEquifaxUSConsumerCreditReportCustomerReferenceNumber :: !(Maybe Text) -- ^ "customerReferenceNumber" - This field will return a value sent in the request
  , consumerCreditReportEquifaxUSConsumerCreditReportCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - This field returns the same value provided in the request
  , consumerCreditReportEquifaxUSConsumerCreditReportConsumerReferralCode :: !(Maybe Text) -- ^ "consumerReferralCode" - Credit Reporting Agency Number
  , consumerCreditReportEquifaxUSConsumerCreditReportMultipleReportIndicator :: !(Maybe Text) -- ^ "multipleReportIndicator" - Indicates if the report contains more than 1 credit report file
  , consumerCreditReportEquifaxUSConsumerCreditReportEcoaInquiryType :: !(Maybe Text) -- ^ "ECOAInquiryType" - Type of inquiry
  , consumerCreditReportEquifaxUSConsumerCreditReportNumberOfMonthsToCountInquiries :: !(Maybe Text) -- ^ "numberOfMonthsToCountInquiries" - Number of months inquiried
  , consumerCreditReportEquifaxUSConsumerCreditReportHitCode :: !(Maybe ConsumerCreditReportHitCode) -- ^ "hitCode"
  , consumerCreditReportEquifaxUSConsumerCreditReportFileSinceDate :: !(Maybe Date) -- ^ "fileSinceDate" - Date file was established.  The File Since Date is not intended to represent the date the consumer first became credit active 
  , consumerCreditReportEquifaxUSConsumerCreditReportLastActivityDate :: !(Maybe Date) -- ^ "lastActivityDate" - Date of Last Activity, (i.e. Header Date of most recent activity in file.)
  , consumerCreditReportEquifaxUSConsumerCreditReportReportDate :: !(Maybe Date) -- ^ "reportDate" - Date of this report
  , consumerCreditReportEquifaxUSConsumerCreditReportSubjectName :: !(Maybe ConsumerCreditReportSubjectName) -- ^ "subjectName"
  , consumerCreditReportEquifaxUSConsumerCreditReportSubjectSocialNum :: !(Maybe Text) -- ^ "subjectSocialNum" - Subject&#39;s Social Security Number (SSN)
  , consumerCreditReportEquifaxUSConsumerCreditReportBirthDate :: !(Maybe Date) -- ^ "birthDate" - Date of birth of the primary applicant
  , consumerCreditReportEquifaxUSConsumerCreditReportAge :: !(Maybe Text) -- ^ "age" - Subject&#39;s age
  , consumerCreditReportEquifaxUSConsumerCreditReportNameMatchFlags :: !(Maybe ConsumerCreditReportNameMatchFlags) -- ^ "nameMatchFlags"
  , consumerCreditReportEquifaxUSConsumerCreditReportLinkIndicator :: !(Maybe Text) -- ^ "linkIndicator" - The result of various conditions by the database search using the data submitted in the inquiry, such as   - A file with the same name and address is not found, but the social search finds a file believed to be the subject of the search.    - Results from a marriage or divorce. The consumer&#39;s file has the maiden name and the inquiry has the married name. The same holds true in a divorce case where the consumer reverts to a maiden name    - Results of a consumer using a middle name when applying for credit instead of the first name which is the name that resides on the data base.    - Results of a consumer using an address that does not currently reside on the consumer&#39;s credit file. 
  , consumerCreditReportEquifaxUSConsumerCreditReportDoNotCombineIndicator :: !(Maybe Text) -- ^ "doNotCombineIndicator" - This indicator may appear on the report for various reasons, such as:   - The system encountered a condition where a father/son, brother/brother, or non‐related consumer/consumer files have been mixed by applying a consumer&#39;s data to the wrong file.    - When a fraud indicator (Q, R, T or V) is placed on the file, the Do Not Combine indicator is placed on the file to avoid the file from combining with a file that may have been created as a result of fraud. 
  , consumerCreditReportEquifaxUSConsumerCreditReportAddressDiscrepancyIndicator :: !(Maybe Text) -- ^ "addressDiscrepancyIndicator" - Indicates if a substantial difference was found between address(es) submitted in the inquiry and the address(es) already existing on a credit file.  The Address Discrepancy Indicator codes that can be returned in the Header element are:   - Y: a substantial difference occurred    - N: no substantial difference occurred 
  , consumerCreditReportEquifaxUSConsumerCreditReportFraudSocialNumAlertCode :: !(Maybe ConsumerCreditReportFraudSocialNumAlertCode) -- ^ "fraudSocialNumAlertCode"
  , consumerCreditReportEquifaxUSConsumerCreditReportFraudIDScanAlertCode :: !(Maybe [ConsumerCreditReportFraudIDScanAlertCode]) -- ^ "fraudSocialNumAlertCode"
  , consumerCreditReportEquifaxUSConsumerCreditReportFraudVictimIndicator :: !(Maybe ConsumerCreditReportFraudVictimIndicator) -- ^ "fraudVictimIndicator"
  , consumerCreditReportEquifaxUSConsumerCreditReportAddresses :: !(Maybe [Address]) -- ^ "addresses" - It contains Equifax report data pertaining to the subject&#39;s addresses
  , consumerCreditReportEquifaxUSConsumerCreditReportIdentityScan :: !(Maybe ConsumerCreditReportIdentityScan) -- ^ "identityScan"
  , consumerCreditReportEquifaxUSConsumerCreditReportFormerNames :: !(Maybe [ConsumerCreditReportFormerNames]) -- ^ "formerNames" - It contains any former name of the subject
  , consumerCreditReportEquifaxUSConsumerCreditReportDeathDate :: !(Maybe Text) -- ^ "deathDate" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , consumerCreditReportEquifaxUSConsumerCreditReportEmployments :: !(Maybe [ConsumerCreditReportEmployments]) -- ^ "employments" - It contains information to the subject&#39;s employments
  , consumerCreditReportEquifaxUSConsumerCreditReportOtherIdentification :: !(Maybe [ConsumerCreditReportOtherIdentification]) -- ^ "otherIdentification" - It contains information related to other identification
  , consumerCreditReportEquifaxUSConsumerCreditReportBankruptcies :: !(Maybe [Bankruptcy]) -- ^ "bankruptcies" - Public record information as it pertains to bankruptcy
  , consumerCreditReportEquifaxUSConsumerCreditReportCollections :: !(Maybe [Collection]) -- ^ "collections"
  , consumerCreditReportEquifaxUSConsumerCreditReportFileIdentificationNumber :: !(Maybe Text) -- ^ "fileIdentificationNumber" - Provides the consumer&#39;s unique file identification number.  The return of the File Identification Number is an optional feature offered by Equifax.  Contact your Equifax Sales Associate for additional information and activation. 
  , consumerCreditReportEquifaxUSConsumerCreditReportAlertContacts :: !(Maybe [ConsumerCreditReportAlertContacts]) -- ^ "alertContacts" - Contains contact information for the consumer when a Fraud or Active Duty Alert is on the report. If the credit file contains a Consumer Statement, the Alert Contact information will follow the Consumer Statement on file. A Consumer Statement may be returned regardless of a Fraud or Active Duty Alert being on file (such as when a consumer is explaining his/her circumstances for filing bankruptcy). The Consumer Statement will continue to be returned on those consumer reports. 
  , consumerCreditReportEquifaxUSConsumerCreditReportTrades :: !(Maybe [Trade]) -- ^ "trades"
  , consumerCreditReportEquifaxUSConsumerCreditReportInquiries :: !(Maybe [ConsumerCreditReportInquiries]) -- ^ "inquiries"
  , consumerCreditReportEquifaxUSConsumerCreditReportConsumerStatements :: !(Maybe [ConsumerCreditReportConsumerStatements]) -- ^ "consumerStatements" - Show consumer comments about the report information. A maximum of 99 Consumer Statements can be returned
  , consumerCreditReportEquifaxUSConsumerCreditReportModels :: !(Maybe [ConsumerCreditReportModels]) -- ^ "models" - Specific Scoring Model being requested by the customer (optional) Risk-Based Pricing score information, Dodd Frank, MarketMax, Models and ID Score - Risk are optional services.  Please contact your Equifax Sales Associate for additional information and activation of optional services. 
  , consumerCreditReportEquifaxUSConsumerCreditReportOnlineDirectory :: !(Maybe [ConsumerCreditReportOnlineDirectory]) -- ^ "onlineDirectory" - It is a convenient, value added feature that automatically delivers telephone numbers and upon request, addresses, of all collection, inquiries and trade segment companies shown on the report.  ON-LINE DIRECTORY is an optional product offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation of your desired ON-LINE DIRECTORY option. 
  , consumerCreditReportEquifaxUSConsumerCreditReportIdentification :: !(Maybe ConsumerCreditReportIdentification) -- ^ "identification"
  , consumerCreditReportEquifaxUSConsumerCreditReportAttributes :: !(Maybe [ConsumerCreditReportAttributes1]) -- ^ "attributes" - Contains attributes associated with customer specific models. A maximum of 99 Data Attribute can be returned.  Please contact your Equifax Sales Associate for additional information. 
  , consumerCreditReportEquifaxUSConsumerCreditReportOnlineGeoCode :: !(Maybe [ConsumerCreditReportOnlineGeoCode]) -- ^ "onlineGeoCode" - Delivers the folowing codes:   - Geo S M S A Code      - Geo State Code      - Geo County Code      - Geo Census Tract      - Geo Block Group   These codes will be returned for the current address.  Equifax will also return the Property Address Geo Code when it is included in the inquiry.  On Line GEO Code and Micro Vision are optional services offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation. 
  , consumerCreditReportEquifaxUSConsumerCreditReportOfacAlerts :: !(Maybe [A.Value]) -- ^ "OFACAlerts" - It will contain data from the Compliance Data Center (CDC)  Multiple reports on the same consumer are not available with OFAC Alert. Only the first report is returned. OFAC Alert can be only returned with a Consumer Report and when a No‐Hit on the credit file occurs. 
  , consumerCreditReportEquifaxUSConsumerCreditReportConsumerReferralLocation :: !(Maybe ConsumerCreditReportConsumerReferralLocation) -- ^ "consumerReferralLocation"
  , consumerCreditReportEquifaxUSConsumerCreditReportAlternateDataSources :: !(Maybe ConsumerCreditReportAlternateDataSources) -- ^ "alternateDataSources"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportEquifaxUSConsumerCreditReport
instance A.FromJSON ConsumerCreditReportEquifaxUSConsumerCreditReport where
  parseJSON = A.withObject "ConsumerCreditReportEquifaxUSConsumerCreditReport" $ \o ->
    ConsumerCreditReportEquifaxUSConsumerCreditReport
      <$> (o .:? "identifier")
      <*> (o .:? "customerReferenceNumber")
      <*> (o .:? "customerNumber")
      <*> (o .:? "consumerReferralCode")
      <*> (o .:? "multipleReportIndicator")
      <*> (o .:? "ECOAInquiryType")
      <*> (o .:? "numberOfMonthsToCountInquiries")
      <*> (o .:? "hitCode")
      <*> (o .:? "fileSinceDate")
      <*> (o .:? "lastActivityDate")
      <*> (o .:? "reportDate")
      <*> (o .:? "subjectName")
      <*> (o .:? "subjectSocialNum")
      <*> (o .:? "birthDate")
      <*> (o .:? "age")
      <*> (o .:? "nameMatchFlags")
      <*> (o .:? "linkIndicator")
      <*> (o .:? "doNotCombineIndicator")
      <*> (o .:? "addressDiscrepancyIndicator")
      <*> (o .:? "fraudSocialNumAlertCode")
      <*> (o .:? "fraudIDScanAlertCodes")
      <*> (o .:? "fraudVictimIndicator")
      <*> (o .:? "addresses")
      <*> (o .:? "identityScan")
      <*> (o .:? "formerNames")
      <*> (o .:? "deathDate")
      <*> (o .:? "employments")
      <*> (o .:? "otherIdentification")
      <*> (o .:? "bankruptcies")
      <*> (o .:? "collections")
      <*> (o .:? "fileIdentificationNumber")
      <*> (o .:? "alertContacts")
      <*> (o .:? "trades")
      <*> (o .:? "inquiries")
      <*> (o .:? "consumerStatements")
      <*> (o .:? "models")
      <*> (o .:? "onlineDirectory")
      <*> (o .:? "identification")
      <*> (o .:? "attributes")
      <*> (o .:? "onlineGeoCode")
      <*> (o .:? "OFACAlerts")
      <*> (o .:? "consumerReferralLocation")
      <*> (o .:? "alternateDataSources")

-- | ToJSON ConsumerCreditReportEquifaxUSConsumerCreditReport
instance A.ToJSON ConsumerCreditReportEquifaxUSConsumerCreditReport where
  toJSON ConsumerCreditReportEquifaxUSConsumerCreditReport {..} =
   _omitNulls
      [ "identifier" .= consumerCreditReportEquifaxUSConsumerCreditReportIdentifier
      , "customerReferenceNumber" .= consumerCreditReportEquifaxUSConsumerCreditReportCustomerReferenceNumber
      , "customerNumber" .= consumerCreditReportEquifaxUSConsumerCreditReportCustomerNumber
      , "consumerReferralCode" .= consumerCreditReportEquifaxUSConsumerCreditReportConsumerReferralCode
      , "multipleReportIndicator" .= consumerCreditReportEquifaxUSConsumerCreditReportMultipleReportIndicator
      , "ECOAInquiryType" .= consumerCreditReportEquifaxUSConsumerCreditReportEcoaInquiryType
      , "numberOfMonthsToCountInquiries" .= consumerCreditReportEquifaxUSConsumerCreditReportNumberOfMonthsToCountInquiries
      , "hitCode" .= consumerCreditReportEquifaxUSConsumerCreditReportHitCode
      , "fileSinceDate" .= consumerCreditReportEquifaxUSConsumerCreditReportFileSinceDate
      , "lastActivityDate" .= consumerCreditReportEquifaxUSConsumerCreditReportLastActivityDate
      , "reportDate" .= consumerCreditReportEquifaxUSConsumerCreditReportReportDate
      , "subjectName" .= consumerCreditReportEquifaxUSConsumerCreditReportSubjectName
      , "subjectSocialNum" .= consumerCreditReportEquifaxUSConsumerCreditReportSubjectSocialNum
      , "birthDate" .= consumerCreditReportEquifaxUSConsumerCreditReportBirthDate
      , "age" .= consumerCreditReportEquifaxUSConsumerCreditReportAge
      , "nameMatchFlags" .= consumerCreditReportEquifaxUSConsumerCreditReportNameMatchFlags
      , "linkIndicator" .= consumerCreditReportEquifaxUSConsumerCreditReportLinkIndicator
      , "doNotCombineIndicator" .= consumerCreditReportEquifaxUSConsumerCreditReportDoNotCombineIndicator
      , "addressDiscrepancyIndicator" .= consumerCreditReportEquifaxUSConsumerCreditReportAddressDiscrepancyIndicator
      , "fraudSocialNumAlertCode" .= consumerCreditReportEquifaxUSConsumerCreditReportFraudSocialNumAlertCode
      , "fraudIDScanAlertCode" .= consumerCreditReportEquifaxUSConsumerCreditReportFraudIDScanAlertCode
      , "fraudVictimIndicator" .= consumerCreditReportEquifaxUSConsumerCreditReportFraudVictimIndicator
      , "addresses" .= consumerCreditReportEquifaxUSConsumerCreditReportAddresses
      , "identityScan" .= consumerCreditReportEquifaxUSConsumerCreditReportIdentityScan
      , "formerNames" .= consumerCreditReportEquifaxUSConsumerCreditReportFormerNames
      , "deathDate" .= consumerCreditReportEquifaxUSConsumerCreditReportDeathDate
      , "employments" .= consumerCreditReportEquifaxUSConsumerCreditReportEmployments
      , "otherIdentification" .= consumerCreditReportEquifaxUSConsumerCreditReportOtherIdentification
      , "bankruptcies" .= consumerCreditReportEquifaxUSConsumerCreditReportBankruptcies
      , "collections" .= consumerCreditReportEquifaxUSConsumerCreditReportCollections
      , "fileIdentificationNumber" .= consumerCreditReportEquifaxUSConsumerCreditReportFileIdentificationNumber
      , "alertContacts" .= consumerCreditReportEquifaxUSConsumerCreditReportAlertContacts
      , "trades" .= consumerCreditReportEquifaxUSConsumerCreditReportTrades
      , "inquiries" .= consumerCreditReportEquifaxUSConsumerCreditReportInquiries
      , "consumerStatements" .= consumerCreditReportEquifaxUSConsumerCreditReportConsumerStatements
      , "models" .= consumerCreditReportEquifaxUSConsumerCreditReportModels
      , "onlineDirectory" .= consumerCreditReportEquifaxUSConsumerCreditReportOnlineDirectory
      , "identification" .= consumerCreditReportEquifaxUSConsumerCreditReportIdentification
      , "attributes" .= consumerCreditReportEquifaxUSConsumerCreditReportAttributes
      , "onlineGeoCode" .= consumerCreditReportEquifaxUSConsumerCreditReportOnlineGeoCode
      , "OFACAlerts" .= consumerCreditReportEquifaxUSConsumerCreditReportOfacAlerts
      , "consumerReferralLocation" .= consumerCreditReportEquifaxUSConsumerCreditReportConsumerReferralLocation
      , "alternateDataSources" .= consumerCreditReportEquifaxUSConsumerCreditReportAlternateDataSources
      ]


-- | Construct a value of type 'ConsumerCreditReportEquifaxUSConsumerCreditReport' (by applying it's required fields, if any)
mkConsumerCreditReportEquifaxUSConsumerCreditReport
  :: ConsumerCreditReportEquifaxUSConsumerCreditReport
mkConsumerCreditReportEquifaxUSConsumerCreditReport =
  ConsumerCreditReportEquifaxUSConsumerCreditReport
  { consumerCreditReportEquifaxUSConsumerCreditReportIdentifier = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportCustomerReferenceNumber = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportCustomerNumber = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportConsumerReferralCode = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportMultipleReportIndicator = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportEcoaInquiryType = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportNumberOfMonthsToCountInquiries = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportHitCode = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportFileSinceDate = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportLastActivityDate = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportReportDate = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportSubjectName = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportSubjectSocialNum = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportBirthDate = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportAge = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportNameMatchFlags = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportLinkIndicator = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportDoNotCombineIndicator = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportAddressDiscrepancyIndicator = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportFraudSocialNumAlertCode = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportFraudIDScanAlertCode = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportFraudVictimIndicator = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportAddresses = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportIdentityScan = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportFormerNames = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportDeathDate = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportEmployments = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportOtherIdentification = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportBankruptcies = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportCollections = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportFileIdentificationNumber = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportAlertContacts = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportTrades = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportInquiries = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportConsumerStatements = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportModels = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportOnlineDirectory = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportIdentification = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportAttributes = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportOnlineGeoCode = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportOfacAlerts = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportConsumerReferralLocation = Nothing
  , consumerCreditReportEquifaxUSConsumerCreditReportAlternateDataSources = Nothing
  }

-- ** ConsumerCreditReportFICOScoreIndicatorCode
-- | ConsumerCreditReportFICOScoreIndicatorCode
-- FICO Score Indicator
data ConsumerCreditReportFICOScoreIndicatorCode = ConsumerCreditReportFICOScoreIndicatorCode
  { consumerCreditReportFICOScoreIndicatorCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportFICOScoreIndicatorCodeDescription :: !(Maybe Text) -- ^ "description" - NF &#x3D; Non‐FACTA; F &#x3D; FACTA version   - S: FICO® Score 9 based on Equifax Data (NF)   - 4: FICO® Auto Score 9 based on Equifax Data (NF)   - 8: FICO® Bankcard Score 9 based on Equifax Data (NF)   - V: FICO® Risk Score 9 based on Equifax Data (F)   - @: FICO® Auto Score 9 based on Equifax Data (F)   - $: FICO® Bankcard Score 9 based on Equifax Data (F)   - 9: FICO® Score 8 based on Equifax Data (NF)   - C: FICO® Auto Score 8 based on Equifax Data (NF)   - D: FICO® Bankcard Score 8 based on Equifax Data (NF)   - O: FICO® Mortgage Score 8 based on Equifax Data (NF)   - G: FICO® Score 8 based on Equifax Data (F)   - H: FICO® Auto Score 8 based on Equifax Data (F)   - X: FICO® Bankcard Score 8 based on Equifax Data (F)   - Q: FICO® Mortgage Score 8 based on Equifax Data (F)   - J: FICO® Score 5 based on Equifax Data (NF)   - K: FICO® Auto Score 5 based on Equifax Data (NF)   - L: FICO® Bankcard Score 5 based on Equifax Data (NF)   - M: FICO® Personal Finance Score 5 based on Equifax Data (NF)   - N: FICO® Installment Score 5 based on Equifax Data (NF)   - Z: FICO® Score 5 based on Equifax Data (F)   - R: FICO® Auto Score 5 based on Equifax Data (F)   - W: FICO® Bankcard Score 5 based on Equifax Data (F)   - U: FICO® Personal Finance Score 5 based on Equifax Data (F)   - P: FICO® Installment Score 5 based on Equifax Data (F)     
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportFICOScoreIndicatorCode
instance A.FromJSON ConsumerCreditReportFICOScoreIndicatorCode where
  parseJSON = A.withObject "ConsumerCreditReportFICOScoreIndicatorCode" $ \o ->
    ConsumerCreditReportFICOScoreIndicatorCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportFICOScoreIndicatorCode
instance A.ToJSON ConsumerCreditReportFICOScoreIndicatorCode where
  toJSON ConsumerCreditReportFICOScoreIndicatorCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportFICOScoreIndicatorCodeCode
      , "description" .= consumerCreditReportFICOScoreIndicatorCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportFICOScoreIndicatorCode' (by applying it's required fields, if any)
mkConsumerCreditReportFICOScoreIndicatorCode
  :: ConsumerCreditReportFICOScoreIndicatorCode
mkConsumerCreditReportFICOScoreIndicatorCode =
  ConsumerCreditReportFICOScoreIndicatorCode
  { consumerCreditReportFICOScoreIndicatorCodeCode = Nothing
  , consumerCreditReportFICOScoreIndicatorCodeDescription = Nothing
  }

-- ** ConsumerCreditReportFormerNames
-- | ConsumerCreditReportFormerNames
data ConsumerCreditReportFormerNames = ConsumerCreditReportFormerNames
  { consumerCreditReportFormerNamesLastName :: !(Maybe Text) -- ^ "lastName" - Subject&#39;s former last name
  , consumerCreditReportFormerNamesFirstName :: !(Maybe Text) -- ^ "firstName" - Subject&#39;s former first name
  , consumerCreditReportFormerNamesMiddleInitial :: !(Maybe Text) -- ^ "middleInitial" - Subject&#39;s former middle name
  , consumerCreditReportFormerNamesSuffix :: !(Maybe Text) -- ^ "suffix" - Subject&#39;s former suffix
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportFormerNames
instance A.FromJSON ConsumerCreditReportFormerNames where
  parseJSON = A.withObject "ConsumerCreditReportFormerNames" $ \o ->
    ConsumerCreditReportFormerNames
      <$> (o .:? "lastName")
      <*> (o .:? "firstName")
      <*> (o .:? "middleInitial")
      <*> (o .:? "suffix")

-- | ToJSON ConsumerCreditReportFormerNames
instance A.ToJSON ConsumerCreditReportFormerNames where
  toJSON ConsumerCreditReportFormerNames {..} =
   _omitNulls
      [ "lastName" .= consumerCreditReportFormerNamesLastName
      , "firstName" .= consumerCreditReportFormerNamesFirstName
      , "middleInitial" .= consumerCreditReportFormerNamesMiddleInitial
      , "suffix" .= consumerCreditReportFormerNamesSuffix
      ]


-- | Construct a value of type 'ConsumerCreditReportFormerNames' (by applying it's required fields, if any)
mkConsumerCreditReportFormerNames
  :: ConsumerCreditReportFormerNames
mkConsumerCreditReportFormerNames =
  ConsumerCreditReportFormerNames
  { consumerCreditReportFormerNamesLastName = Nothing
  , consumerCreditReportFormerNamesFirstName = Nothing
  , consumerCreditReportFormerNamesMiddleInitial = Nothing
  , consumerCreditReportFormerNamesSuffix = Nothing
  }

-- ** ConsumerCreditReportFraudSocialNumAlertCode
-- | ConsumerCreditReportFraudSocialNumAlertCode
-- FraudIQ™ SSN Alert compares the inquiry social security number and returns a flag to alert customers
data ConsumerCreditReportFraudSocialNumAlertCode = ConsumerCreditReportFraudSocialNumAlertCode
  { consumerCreditReportFraudSocialNumAlertCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportFraudSocialNumAlertCodeDescription :: !(Maybe Text) -- ^ "description" - FLAG FLAG VERBIAGE DESCRIPTION - A: Inquiry SSN is associated with another consumer - SSN Mismatch   The social security number provided in the inquiry matches   to another consumer on the Equifax database. A credit file   is returned for the consumer name and address provided,   however the social security number on that file is different   from the social security number provided on the inquiry.    - B: Inquiry SSN not present    Inquiry did not contain a social security number,    therefore no comparison can be made.      - N: No Alert available   The social security number provided in the inquiry    cannot be matched to a specific consumer based   on the Equifax proprietary comparison algorithm.    - P: Inquiry SSN is associated with the consumer   The social security number provided in the inquiry   matches to the requested consumer.    - V*: SSN affirm variation    Inquiry ssn has a slight variation with consumer.    The social security number provided in the inquiry   has a slight variation to the requested consumer.    - W: Inquiry SSN is associated with another consumer   The social security number provided in the inquiry   matches to another consumer in the Equifax database.    No credit file is available for the requested consumer.    - *: Optional code – requires that your Equifax Customer Number be activated to   be returned when encountered.  
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportFraudSocialNumAlertCode
instance A.FromJSON ConsumerCreditReportFraudSocialNumAlertCode where
  parseJSON = A.withObject "ConsumerCreditReportFraudSocialNumAlertCode" $ \o ->
    ConsumerCreditReportFraudSocialNumAlertCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportFraudSocialNumAlertCode
instance A.ToJSON ConsumerCreditReportFraudSocialNumAlertCode where
  toJSON ConsumerCreditReportFraudSocialNumAlertCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportFraudSocialNumAlertCodeCode
      , "description" .= consumerCreditReportFraudSocialNumAlertCodeDescription
      ]

data ConsumerCreditReportFraudIDScanAlertCode = ConsumerCreditReportFraudIDScanAlertCode
  { -- | "code" - Code value
    consumerCreditReportFraudIDScanAlertCodeCode :: !(Maybe Text),
    -- | "description" - FLAG FLAG VERBIAGE DESCRIPTION - A: Inquiry SSN is associated with another consumer - SSN Mismatch   The social security number provided in the inquiry matches   to another consumer on the Equifax database. A credit file   is returned for the consumer name and address provided,   however the social security number on that file is different   from the social security number provided on the inquiry.    - B: Inquiry SSN not present    Inquiry did not contain a social security number,    therefore no comparison can be made.      - N: No Alert available   The social security number provided in the inquiry    cannot be matched to a specific consumer based   on the Equifax proprietary comparison algorithm.    - P: Inquiry SSN is associated with the consumer   The social security number provided in the inquiry   matches to the requested consumer.    - V*: SSN affirm variation    Inquiry ssn has a slight variation with consumer.    The social security number provided in the inquiry   has a slight variation to the requested consumer.    - W: Inquiry SSN is associated with another consumer   The social security number provided in the inquiry   matches to another consumer in the Equifax database.    No credit file is available for the requested consumer.    - *: Optional code – requires that your Equifax Customer Number be activated to   be returned when encountered.
    consumerCreditReportFraudIDScanAlertCodeDescription :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

instance A.FromJSON ConsumerCreditReportFraudIDScanAlertCode where
  parseJSON = A.withObject "ConsumerCreditReportFraudIDScanAlertCode" $ \o ->
    ConsumerCreditReportFraudIDScanAlertCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportFraudIDScanAlertCodes
instance A.ToJSON ConsumerCreditReportFraudIDScanAlertCode where
  toJSON ConsumerCreditReportFraudIDScanAlertCode {..} =
    _omitNulls
      [ "code" .= consumerCreditReportFraudIDScanAlertCodeCode,
        "description" .= consumerCreditReportFraudIDScanAlertCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportFraudSocialNumAlertCode' (by applying it's required fields, if any)
mkConsumerCreditReportFraudSocialNumAlertCode
  :: ConsumerCreditReportFraudSocialNumAlertCode
mkConsumerCreditReportFraudSocialNumAlertCode =
  ConsumerCreditReportFraudSocialNumAlertCode
  { consumerCreditReportFraudSocialNumAlertCodeCode = Nothing
  , consumerCreditReportFraudSocialNumAlertCodeDescription = Nothing
  }

-- ** ConsumerCreditReportFraudVictimIndicator
-- | ConsumerCreditReportFraudVictimIndicator
-- Indicates fraud victim alert type
data ConsumerCreditReportFraudVictimIndicator = ConsumerCreditReportFraudVictimIndicator
  { consumerCreditReportFraudVictimIndicatorCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportFraudVictimIndicatorDescription :: !(Maybe Text) -- ^ "description" - The following indicator codes can be returned in the Header segment:    - N: Active Duty Alert    - Q: Active Duty Alert with Fraud Victim “Initial Alert”    - R: Active Duty Alert with Fraud Victim T (police report)    - T: Fraud Victim (associated with trade)    - V: Fraud Victim “Initial Alert”    - W: Active Duty Alert with Fraud Victim “Extended Alert”    - X: Fraud Victim “Extended Alert”  Consumers or their representatives may request that an Initial Fraud Alert or, if the consumer is a member of the military on active duty, an Active Duty Alert be placed on their credit file. The Initial Fraud Alert will remain on the credit file for one year (366 days); the Active Duty Alert will remain on file for twelve months. Equifax will return an “N”, “Q”, or “V”, as applicable, in the Header segment. A user receiving a report containing an Initial Fraud Alert or Active Duty Alert may not grant credit without first determining the identity of the person making the request. If the consumer has provided a telephone number, it will be returned in a second Consumer Narrative Statement segment or Alert Contact segment and must be used for identity verification purposes before granting credit. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportFraudVictimIndicator
instance A.FromJSON ConsumerCreditReportFraudVictimIndicator where
  parseJSON = A.withObject "ConsumerCreditReportFraudVictimIndicator" $ \o ->
    ConsumerCreditReportFraudVictimIndicator
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportFraudVictimIndicator
instance A.ToJSON ConsumerCreditReportFraudVictimIndicator where
  toJSON ConsumerCreditReportFraudVictimIndicator {..} =
   _omitNulls
      [ "code" .= consumerCreditReportFraudVictimIndicatorCode
      , "description" .= consumerCreditReportFraudVictimIndicatorDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportFraudVictimIndicator' (by applying it's required fields, if any)
mkConsumerCreditReportFraudVictimIndicator
  :: ConsumerCreditReportFraudVictimIndicator
mkConsumerCreditReportFraudVictimIndicator =
  ConsumerCreditReportFraudVictimIndicator
  { consumerCreditReportFraudVictimIndicatorCode = Nothing
  , consumerCreditReportFraudVictimIndicatorDescription = Nothing
  }

-- ** ConsumerCreditReportHitCode
-- | ConsumerCreditReportHitCode
-- Hit code
data ConsumerCreditReportHitCode = ConsumerCreditReportHitCode
  { consumerCreditReportHitCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportHitCodeDescription :: !(Maybe Text) -- ^ "description" - - 1: Hit - 2: No-Hit - 3: Manual File (Returned if credit report has been designated by Equifax as manual return only or in response to an on-line prescreen transaction when the file contains a promo block.) - 4: Manual File Review Required - Due to reasons such as unable to deliver Consumer Narrative(s), Fraud/Active Duty Alert(s), or Address Discrepancy Indicator - 5: Referred File (File is under review or file is being referred to another) - 6: Hit and Automated Consumer Narrative - 7: Fraud/Verification Product Being Requested Without Requesting a Credit File - 8: \&quot;Thin File\&quot; when using Fraud/Verification Products - 9: No-Hit/Auto-DTEC** - A: Consumer Requested Security Freeze on His/Her Credit File Report Unavailable (See Attachment 15 Legislative Information) - C: No-Hit With Information From Additional Data Source(s) Returned - D: Manual File With Information From Additional Data Source(s) Returned - E: Manual Consumer Narrative With Information From Additional Data Source(s) Returned - F: Referred File With Information from Additional Data Source(s) Returned - G: Consumer Requested Security Freeze on His/Her Credit File – Report Unavailable With Information From Additional Data Source(s) Returned (except MarketMax)  - I*: Information from your inquiry has been identified as potentially fraudulent or misused, therefore the credit report is not available for delivery  - J*: Information from your inquiry has been identified as potentially fraudulent or misused, therefore the credit report is not available for delivery – with information from additional data source(s) returned - L*: Consumer Requested Equifax Lock on His/Her Credit File – Report Unavailable - M*: Consumer Requested Equifax Lock on His/Her Credit File – Report Unavailable With Information From Additional Data Source(s) Returned - T: Additional data source being returned without requesting a consumer report  - *:Optional Hit Codes require your customer number to be activated through your Sales Representative. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportHitCode
instance A.FromJSON ConsumerCreditReportHitCode where
  parseJSON = A.withObject "ConsumerCreditReportHitCode" $ \o ->
    ConsumerCreditReportHitCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportHitCode
instance A.ToJSON ConsumerCreditReportHitCode where
  toJSON ConsumerCreditReportHitCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportHitCodeCode
      , "description" .= consumerCreditReportHitCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportHitCode' (by applying it's required fields, if any)
mkConsumerCreditReportHitCode
  :: ConsumerCreditReportHitCode
mkConsumerCreditReportHitCode =
  ConsumerCreditReportHitCode
  { consumerCreditReportHitCodeCode = Nothing
  , consumerCreditReportHitCodeDescription = Nothing
  }

-- ** ConsumerCreditReportIdentification
-- | ConsumerCreditReportIdentification
-- Information as to the subject's consumer report SSN and subject's SSN submitted in the inquiry
data ConsumerCreditReportIdentification = ConsumerCreditReportIdentification
  { consumerCreditReportIdentificationSubjectAge :: !(Maybe Text) -- ^ "subjectAge" - Subject&#39;s age
  , consumerCreditReportIdentificationSubjectSocialNum :: !(Maybe Text) -- ^ "subjectSocialNum" - Last four digits of the Social Security Number may be masked with zeros for specific customers or industry codes to secure the consumers SSN
  , consumerCreditReportIdentificationSocialNumConfirmed :: !(Maybe Text) -- ^ "socialNumConfirmed" - \&quot;Confirmation\&quot; of the Social Security Number is defined as having been received by three (3) major data suppliers. The SSN Confirmed indicator does not mean or imply the Social Security number has been validated through the Social Security Administration&#39;s records.      - Y: Yes      - N: No      - Blank: No inquiry SSN/Not available 
  , consumerCreditReportIdentificationSocialMatchFlags :: !(Maybe Text) -- ^ "socialMatchFlags" - Social Match Flags* (one per SSN digit)    - Y: Byte (digit) match    - N: Byte (digit) Not a match    - Blank: No inquiry SSN/Not available    The field will not be returned on reports when the customer number is activated for \&quot;Social Security Number Protect\&quot; and the social security number in the inquiry does not match what is on the consumer report.  Social Match Flags is an optional service offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation of the service. 
  , consumerCreditReportIdentificationInquirySocialNum :: !(Maybe Text) -- ^ "inquirySocialNum" - Inquiry social security number
  , consumerCreditReportIdentificationInquirySocialNumStateIssued :: !(Maybe Text) -- ^ "inquirySocialNumStateIssued" - State code where the SSN was issued.  It may contain a \&quot;RR\&quot;, indicating that the SSN was issued to a railroad employe. Discontinued July 1, 1963. 
  , consumerCreditReportIdentificationInquirySocialNumYearIssued :: !(Maybe Text) -- ^ "inquirySocialNumYearIssued" - Inquiry SSN date issued   The actual year or \&quot;Prior to\&quot;.   P 51 means Prior to 1951 
  , consumerCreditReportIdentificationInquirySocialNumYearOfDeath :: !(Maybe Text) -- ^ "inquirySocialNumYearOfDeath" - Inquiry SSN death date.   The actual year or \&quot;Prior to\&quot;.   P 91 means Prior to 1991 
  , consumerCreditReportIdentificationInquirySocialNumStateOfDeath :: !(Maybe Text) -- ^ "inquirySocialNumStateOfDeath" - If party is deceased this is the state it was reported in
  , consumerCreditReportIdentificationSocialNumMatch :: !(Maybe Text) -- ^ "socialNumMatch" - Shows if the SSN match byte-to-byte   - Y: Match    - N: Not a match  The field will not be returned on reports when the customer number is activated for \&quot;Social Security Number Protect\&quot; and the social security number in the inquiry does not match what is on the consumer report. SSN Match is an optional service offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation of the service. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportIdentification
instance A.FromJSON ConsumerCreditReportIdentification where
  parseJSON = A.withObject "ConsumerCreditReportIdentification" $ \o ->
    ConsumerCreditReportIdentification
      <$> (o .:? "subjectAge")
      <*> (o .:? "subjectSocialNum")
      <*> (o .:? "socialNumConfirmed")
      <*> (o .:? "socialMatchFlags")
      <*> (o .:? "inquirySocialNum")
      <*> (o .:? "inquirySocialNumStateIssued")
      <*> (o .:? "inquirySocialNumYearIssued")
      <*> (o .:? "inquirySocialNumYearOfDeath")
      <*> (o .:? "inquirySocialNumStateOfDeath")
      <*> (o .:? "socialNumMatch")

-- | ToJSON ConsumerCreditReportIdentification
instance A.ToJSON ConsumerCreditReportIdentification where
  toJSON ConsumerCreditReportIdentification {..} =
   _omitNulls
      [ "subjectAge" .= consumerCreditReportIdentificationSubjectAge
      , "subjectSocialNum" .= consumerCreditReportIdentificationSubjectSocialNum
      , "socialNumConfirmed" .= consumerCreditReportIdentificationSocialNumConfirmed
      , "socialMatchFlags" .= consumerCreditReportIdentificationSocialMatchFlags
      , "inquirySocialNum" .= consumerCreditReportIdentificationInquirySocialNum
      , "inquirySocialNumStateIssued" .= consumerCreditReportIdentificationInquirySocialNumStateIssued
      , "inquirySocialNumYearIssued" .= consumerCreditReportIdentificationInquirySocialNumYearIssued
      , "inquirySocialNumYearOfDeath" .= consumerCreditReportIdentificationInquirySocialNumYearOfDeath
      , "inquirySocialNumStateOfDeath" .= consumerCreditReportIdentificationInquirySocialNumStateOfDeath
      , "socialNumMatch" .= consumerCreditReportIdentificationSocialNumMatch
      ]


-- | Construct a value of type 'ConsumerCreditReportIdentification' (by applying it's required fields, if any)
mkConsumerCreditReportIdentification
  :: ConsumerCreditReportIdentification
mkConsumerCreditReportIdentification =
  ConsumerCreditReportIdentification
  { consumerCreditReportIdentificationSubjectAge = Nothing
  , consumerCreditReportIdentificationSubjectSocialNum = Nothing
  , consumerCreditReportIdentificationSocialNumConfirmed = Nothing
  , consumerCreditReportIdentificationSocialMatchFlags = Nothing
  , consumerCreditReportIdentificationInquirySocialNum = Nothing
  , consumerCreditReportIdentificationInquirySocialNumStateIssued = Nothing
  , consumerCreditReportIdentificationInquirySocialNumYearIssued = Nothing
  , consumerCreditReportIdentificationInquirySocialNumYearOfDeath = Nothing
  , consumerCreditReportIdentificationInquirySocialNumStateOfDeath = Nothing
  , consumerCreditReportIdentificationSocialNumMatch = Nothing
  }

-- ** ConsumerCreditReportIdentityScan
-- | ConsumerCreditReportIdentityScan
-- It contains the FraudIQ Identity Scan Alert information.  FraudIQ Identity Scan Alert is an optional product offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation of your Identity Scan Alert option. 
data ConsumerCreditReportIdentityScan = ConsumerCreditReportIdentityScan
  { consumerCreditReportIdentityScanAlertCodes :: !(Maybe [ConsumerCreditReportIdentityScanAlertCodes]) -- ^ "alertCodes" - It contains up to 15 Identity Scan Alert codes
  , consumerCreditReportIdentityScanIdentityScanRegulated :: !(Maybe Text) -- ^ "identityScanRegulated" - byte that distinguished ID Scan is Non-regulated
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportIdentityScan
instance A.FromJSON ConsumerCreditReportIdentityScan where
  parseJSON = A.withObject "ConsumerCreditReportIdentityScan" $ \o ->
    ConsumerCreditReportIdentityScan
      <$> (o .:? "alertCodes")
      <*> (o .:? "identityScanRegulated")

-- | ToJSON ConsumerCreditReportIdentityScan
instance A.ToJSON ConsumerCreditReportIdentityScan where
  toJSON ConsumerCreditReportIdentityScan {..} =
   _omitNulls
      [ "alertCodes" .= consumerCreditReportIdentityScanAlertCodes
      , "identityScanRegulated" .= consumerCreditReportIdentityScanIdentityScanRegulated
      ]


-- | Construct a value of type 'ConsumerCreditReportIdentityScan' (by applying it's required fields, if any)
mkConsumerCreditReportIdentityScan
  :: ConsumerCreditReportIdentityScan
mkConsumerCreditReportIdentityScan =
  ConsumerCreditReportIdentityScan
  { consumerCreditReportIdentityScanAlertCodes = Nothing
  , consumerCreditReportIdentityScanIdentityScanRegulated = Nothing
  }

-- ** ConsumerCreditReportIdentityScanAlertCodes
-- | ConsumerCreditReportIdentityScanAlertCodes
-- Describes the Identity Scan Alerts
data ConsumerCreditReportIdentityScanAlertCodes = ConsumerCreditReportIdentityScanAlertCodes
  { consumerCreditReportIdentityScanAlertCodesCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportIdentityScanAlertCodesDescription :: !(Maybe Text) -- ^ "description" - Description for the given code   - A: INQUIRY SSN HAS NEVER BEEN ISSUED OR WAS ISSUED AFTER JUNE 2011   - B: INQUIRY SSN REPORTED AS MISUSED   - C: INQUIRY ADDRESS ASSOCIATED WITH MORE THAN ONE NAME OR SSN   - D: INQUIRY ADDRESS UNVERIFIABLE   - G: INQUIRY ADDRESS IS LISTED AS A U.S. POST OFFICE STREET ADDRESS   - H: INQUIRY ADDRESS IS LISTED AS A CAMPGROUND   - I: INQUIRY SSN ASSOCIATED WITH PERSON REPORTED AS DECEASED   - J: INQUIRY ADDRESS IS LISTED AS A HOTEL/MOTEL   - L: FRAUD VICTIM ALERT PRESENT IN DATABASE   - M: INQUIRY SSN ISSUED RECENTLY   - N: ACTIVE DUTY ALERT PRESENT IN DATABASE   - O: INQUIRY SSN ISSUED PRIOR TO INQUIRY DATE OF BIRTH   - P: INQUIRY ADDRESS IS LISTED AS A CORRECTIONAL INSTITUTION ADDRESS   - Q: INQUIRY SSN REPORTED AS DECEASED AND LAST NAME DOES NOT MATCH   - R: INQUIRY ADDRESS IS NOT ASSOCIATED WITH THIS CONSUMER NAME   - S: IDENTITY SCAN DID NOT DETECT ANY ALERTS   - W: INQUIRY ADDRESS IS LISTED AS A NON-RESIDENTIAL ADDRESS   - X: INQUIRY ADDRESS ASSOCIATED WITH REPORTED FRAUD   - Y: INQUIRY TELEPHONE NUMBER LISTED AS A COMMERCIAL PHONE   - Z: INQUIRY ADDRESS IS LISTED AS A MAIL RECEIVING SERVICE   - 0: INCOMPLETE SCAN - LIMITED DATA SOURCES AVAILABLE   - 1: INQUIRY ADDRESS IS LISTED AS A MULTI-DWELLING UNIT   - 2: INQUIRY ADDRESS HAS BEEN REPORTED AS MISUSED   - 4: INQUIRY SSN MAY BE A TAX ID NUMBER   - 5: INQUIRY TELEPHONE NUMBER MAY BELONG TO A MOBILE PHONE   - 7: UNABLE TO PERFORM SSN VALIDATION DUE TO INSUFFICIENT SSN INPUT   - 8: UNABLE TO PERFORM TELEPHONE VALIDATION DUE TO INSUFFICIENT TELEPHONE INPUT   - 9: INQUIRY SSN IS INVALID                                
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportIdentityScanAlertCodes
instance A.FromJSON ConsumerCreditReportIdentityScanAlertCodes where
  parseJSON = A.withObject "ConsumerCreditReportIdentityScanAlertCodes" $ \o ->
    ConsumerCreditReportIdentityScanAlertCodes
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportIdentityScanAlertCodes
instance A.ToJSON ConsumerCreditReportIdentityScanAlertCodes where
  toJSON ConsumerCreditReportIdentityScanAlertCodes {..} =
   _omitNulls
      [ "code" .= consumerCreditReportIdentityScanAlertCodesCode
      , "description" .= consumerCreditReportIdentityScanAlertCodesDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportIdentityScanAlertCodes' (by applying it's required fields, if any)
mkConsumerCreditReportIdentityScanAlertCodes
  :: ConsumerCreditReportIdentityScanAlertCodes
mkConsumerCreditReportIdentityScanAlertCodes =
  ConsumerCreditReportIdentityScanAlertCodes
  { consumerCreditReportIdentityScanAlertCodesCode = Nothing
  , consumerCreditReportIdentityScanAlertCodesDescription = Nothing
  }

-- ** ConsumerCreditReportInquiries
-- | ConsumerCreditReportInquiries
data ConsumerCreditReportInquiries = ConsumerCreditReportInquiries
  { consumerCreditReportInquiriesType :: !(Maybe Text) -- ^ "type" - Inquiries from customers requesting Equifax credit reports and other products
  , consumerCreditReportInquiriesIndustryCode :: !(Maybe Text) -- ^ "industryCode" - Customer&#39;s industry code
  , consumerCreditReportInquiriesInquiryDate :: !(Maybe Date) -- ^ "inquiryDate" - Date of inquiry
  , consumerCreditReportInquiriesCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - Customer&#39;s member number who made the inquiry
  , consumerCreditReportInquiriesCustomerName :: !(Maybe Text) -- ^ "customerName" - Customer&#39;s name who made the inquiry
  , consumerCreditReportInquiriesExpandedAccountTypeOrInquiryIntent :: !(Maybe AccountTypeCode) -- ^ "expandedAccountTypeOrInquiryIntent"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportInquiries
instance A.FromJSON ConsumerCreditReportInquiries where
  parseJSON = A.withObject "ConsumerCreditReportInquiries" $ \o ->
    ConsumerCreditReportInquiries
      <$> (o .:? "type")
      <*> (o .:? "industryCode")
      <*> (o .:? "inquiryDate")
      <*> (o .:? "customerNumber")
      <*> (o .:? "customerName")
      <*> (o .:? "expandedAccountTypeOrInquiryIntent")

-- | ToJSON ConsumerCreditReportInquiries
instance A.ToJSON ConsumerCreditReportInquiries where
  toJSON ConsumerCreditReportInquiries {..} =
   _omitNulls
      [ "type" .= consumerCreditReportInquiriesType
      , "industryCode" .= consumerCreditReportInquiriesIndustryCode
      , "inquiryDate" .= consumerCreditReportInquiriesInquiryDate
      , "customerNumber" .= consumerCreditReportInquiriesCustomerNumber
      , "customerName" .= consumerCreditReportInquiriesCustomerName
      , "expandedAccountTypeOrInquiryIntent" .= consumerCreditReportInquiriesExpandedAccountTypeOrInquiryIntent
      ]


-- | Construct a value of type 'ConsumerCreditReportInquiries' (by applying it's required fields, if any)
mkConsumerCreditReportInquiries
  :: ConsumerCreditReportInquiries
mkConsumerCreditReportInquiries =
  ConsumerCreditReportInquiries
  { consumerCreditReportInquiriesType = Nothing
  , consumerCreditReportInquiriesIndustryCode = Nothing
  , consumerCreditReportInquiriesInquiryDate = Nothing
  , consumerCreditReportInquiriesCustomerNumber = Nothing
  , consumerCreditReportInquiriesCustomerName = Nothing
  , consumerCreditReportInquiriesExpandedAccountTypeOrInquiryIntent = Nothing
  }

-- ** ConsumerCreditReportInquiryKeyFactor
-- | ConsumerCreditReportInquiryKeyFactor
data ConsumerCreditReportInquiryKeyFactor = ConsumerCreditReportInquiryKeyFactor
  { consumerCreditReportInquiryKeyFactorCode :: !(Maybe Text) -- ^ "code"
  , consumerCreditReportInquiryKeyFactorDescription :: !(Maybe Text) -- ^ "description" - FACTA 5th Reason Code Regarding Inquiries
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportInquiryKeyFactor
instance A.FromJSON ConsumerCreditReportInquiryKeyFactor where
  parseJSON = A.withObject "ConsumerCreditReportInquiryKeyFactor" $ \o ->
    ConsumerCreditReportInquiryKeyFactor
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportInquiryKeyFactor
instance A.ToJSON ConsumerCreditReportInquiryKeyFactor where
  toJSON ConsumerCreditReportInquiryKeyFactor {..} =
   _omitNulls
      [ "code" .= consumerCreditReportInquiryKeyFactorCode
      , "description" .= consumerCreditReportInquiryKeyFactorDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportInquiryKeyFactor' (by applying it's required fields, if any)
mkConsumerCreditReportInquiryKeyFactor
  :: ConsumerCreditReportInquiryKeyFactor
mkConsumerCreditReportInquiryKeyFactor =
  ConsumerCreditReportInquiryKeyFactor
  { consumerCreditReportInquiryKeyFactorCode = Nothing
  , consumerCreditReportInquiryKeyFactorDescription = Nothing
  }

-- ** ConsumerCreditReportModels
-- | ConsumerCreditReportModels
data ConsumerCreditReportModels = ConsumerCreditReportModels
  { consumerCreditReportModelsType :: !(Maybe E'Type) -- ^ "type" - Determine what type of model is
  , consumerCreditReportModelsModelNumber :: !(Maybe Text) -- ^ "modelNumber" - Model number code
  , consumerCreditReportModelsFicoScoreIndicatorCode :: !(Maybe ConsumerCreditReportFICOScoreIndicatorCode) -- ^ "FICOScoreIndicatorCode"
  , consumerCreditReportModelsScore :: !(Maybe Int) -- ^ "score" - Numeric score returned by the model requested by the customer
  , consumerCreditReportModelsReasons :: !(Maybe [ConsumerCreditReportReasons]) -- ^ "reasons" - Reason codes for the score that was returned
  , consumerCreditReportModelsInquiryKeyFactor :: !(Maybe ConsumerCreditReportInquiryKeyFactor) -- ^ "inquiryKeyFactor"
  , consumerCreditReportModelsRiskBasedPricingOrModel :: !(Maybe ConsumerCreditReportRiskBasedPricingOrModel) -- ^ "riskBasedPricingOrModel"
  , consumerCreditReportModelsRejects :: !(Maybe [ConsumerCreditReportRejects]) -- ^ "rejects" - Model unable to score file; requested reject code return instead
  , consumerCreditReportModelsEdasRegionalIndicatorCode :: !(Maybe ConsumerCreditReportEDASRegionalIndicatorCode) -- ^ "EDASRegionalIndicatorCode"
  , consumerCreditReportModelsEdasIndicatorCode :: !(Maybe ConsumerCreditReportEDASIndicatorCode) -- ^ "EDASIndicatorCode"
  , consumerCreditReportModelsModelIdorScorecard :: !(Maybe Text) -- ^ "modelIDOrScorecard" - Scorecard that was used to produce the score returned
  , consumerCreditReportModelsScoreNumberOrMarketMaxIndustryCode :: !(Maybe ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode) -- ^ "scoreNumberOrMarketMaxIndustryCode"
  , consumerCreditReportModelsNumericScoreIndicator :: !(Maybe Text) -- ^ "numericScoreIndicator" - Indicates whether the score is positive or negative
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportModels
instance A.FromJSON ConsumerCreditReportModels where
  parseJSON = A.withObject "ConsumerCreditReportModels" $ \o ->
    ConsumerCreditReportModels
      <$> (o .:? "type")
      <*> (o .:? "modelNumber")
      <*> (o .:? "FICOScoreIndicatorCode")
      <*> (o .:? "score")
      <*> (o .:? "reasons")
      <*> (o .:? "inquiryKeyFactor")
      <*> (o .:? "riskBasedPricingOrModel")
      <*> (o .:? "rejects")
      <*> (o .:? "EDASRegionalIndicatorCode")
      <*> (o .:? "EDASIndicatorCode")
      <*> (o .:? "modelIDOrScorecard")
      <*> (o .:? "scoreNumberOrMarketMaxIndustryCode")
      <*> (o .:? "numericScoreIndicator")

-- | ToJSON ConsumerCreditReportModels
instance A.ToJSON ConsumerCreditReportModels where
  toJSON ConsumerCreditReportModels {..} =
   _omitNulls
      [ "type" .= consumerCreditReportModelsType
      , "modelNumber" .= consumerCreditReportModelsModelNumber
      , "FICOScoreIndicatorCode" .= consumerCreditReportModelsFicoScoreIndicatorCode
      , "score" .= consumerCreditReportModelsScore
      , "reasons" .= consumerCreditReportModelsReasons
      , "inquiryKeyFactor" .= consumerCreditReportModelsInquiryKeyFactor
      , "riskBasedPricingOrModel" .= consumerCreditReportModelsRiskBasedPricingOrModel
      , "rejects" .= consumerCreditReportModelsRejects
      , "EDASRegionalIndicatorCode" .= consumerCreditReportModelsEdasRegionalIndicatorCode
      , "EDASIndicatorCode" .= consumerCreditReportModelsEdasIndicatorCode
      , "modelIDOrScorecard" .= consumerCreditReportModelsModelIdorScorecard
      , "scoreNumberOrMarketMaxIndustryCode" .= consumerCreditReportModelsScoreNumberOrMarketMaxIndustryCode
      , "numericScoreIndicator" .= consumerCreditReportModelsNumericScoreIndicator
      ]


-- | Construct a value of type 'ConsumerCreditReportModels' (by applying it's required fields, if any)
mkConsumerCreditReportModels
  :: ConsumerCreditReportModels
mkConsumerCreditReportModels =
  ConsumerCreditReportModels
  { consumerCreditReportModelsType = Nothing
  , consumerCreditReportModelsModelNumber = Nothing
  , consumerCreditReportModelsFicoScoreIndicatorCode = Nothing
  , consumerCreditReportModelsScore = Nothing
  , consumerCreditReportModelsReasons = Nothing
  , consumerCreditReportModelsInquiryKeyFactor = Nothing
  , consumerCreditReportModelsRiskBasedPricingOrModel = Nothing
  , consumerCreditReportModelsRejects = Nothing
  , consumerCreditReportModelsEdasRegionalIndicatorCode = Nothing
  , consumerCreditReportModelsEdasIndicatorCode = Nothing
  , consumerCreditReportModelsModelIdorScorecard = Nothing
  , consumerCreditReportModelsScoreNumberOrMarketMaxIndustryCode = Nothing
  , consumerCreditReportModelsNumericScoreIndicator = Nothing
  }

-- ** ConsumerCreditReportNameMatchFlags
-- | ConsumerCreditReportNameMatchFlags
-- Flags indicate if the subject's name matches
data ConsumerCreditReportNameMatchFlags = ConsumerCreditReportNameMatchFlags
  { consumerCreditReportNameMatchFlagsFirstNameMatchFlag :: !(Maybe E'FirstNameMatchFlag) -- ^ "firstNameMatchFlag" - Flag indicates if the subject&#39;s first name matches
  , consumerCreditReportNameMatchFlagsLastNameMatchFlag :: !(Maybe E'FirstNameMatchFlag) -- ^ "lastNameMatchFlag" - Flag indicates if the subject&#39;s last name matches
  , consumerCreditReportNameMatchFlagsMiddleNameMatchFlag :: !(Maybe E'FirstNameMatchFlag) -- ^ "middleNameMatchFlag" - Flag indicates if the subject&#39;s middle name matches
  , consumerCreditReportNameMatchFlagsSuffixMatchFlag :: !(Maybe E'FirstNameMatchFlag) -- ^ "suffixMatchFlag" - Flag indicates if the subject&#39;s suffix name matches
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportNameMatchFlags
instance A.FromJSON ConsumerCreditReportNameMatchFlags where
  parseJSON = A.withObject "ConsumerCreditReportNameMatchFlags" $ \o ->
    ConsumerCreditReportNameMatchFlags
      <$> (o .:? "firstNameMatchFlag")
      <*> (o .:? "lastNameMatchFlag")
      <*> (o .:? "middleNameMatchFlag")
      <*> (o .:? "suffixMatchFlag")

-- | ToJSON ConsumerCreditReportNameMatchFlags
instance A.ToJSON ConsumerCreditReportNameMatchFlags where
  toJSON ConsumerCreditReportNameMatchFlags {..} =
   _omitNulls
      [ "firstNameMatchFlag" .= consumerCreditReportNameMatchFlagsFirstNameMatchFlag
      , "lastNameMatchFlag" .= consumerCreditReportNameMatchFlagsLastNameMatchFlag
      , "middleNameMatchFlag" .= consumerCreditReportNameMatchFlagsMiddleNameMatchFlag
      , "suffixMatchFlag" .= consumerCreditReportNameMatchFlagsSuffixMatchFlag
      ]


-- | Construct a value of type 'ConsumerCreditReportNameMatchFlags' (by applying it's required fields, if any)
mkConsumerCreditReportNameMatchFlags
  :: ConsumerCreditReportNameMatchFlags
mkConsumerCreditReportNameMatchFlags =
  ConsumerCreditReportNameMatchFlags
  { consumerCreditReportNameMatchFlagsFirstNameMatchFlag = Nothing
  , consumerCreditReportNameMatchFlagsLastNameMatchFlag = Nothing
  , consumerCreditReportNameMatchFlagsMiddleNameMatchFlag = Nothing
  , consumerCreditReportNameMatchFlagsSuffixMatchFlag = Nothing
  }

-- ** ConsumerCreditReportOnlineDirectory
-- | ConsumerCreditReportOnlineDirectory
data ConsumerCreditReportOnlineDirectory = ConsumerCreditReportOnlineDirectory
  { consumerCreditReportOnlineDirectoryCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - Equifax customer number
  , consumerCreditReportOnlineDirectoryCustomerName :: !(Maybe Text) -- ^ "customerName" - Customer&#39;s name
  , consumerCreditReportOnlineDirectoryTelephoneNumber :: !(Maybe Text) -- ^ "telephoneNumber" - Telephone number including a valid area code
  , consumerCreditReportOnlineDirectoryAddressLine1 :: !(Maybe Text) -- ^ "addressLine1" - Customer address line 1
  , consumerCreditReportOnlineDirectoryAddressLine2 :: !(Maybe Text) -- ^ "addressLine2" - Customer address line 2
  , consumerCreditReportOnlineDirectoryCity :: !(Maybe Text) -- ^ "city" - The city name
  , consumerCreditReportOnlineDirectoryStateAbbreviation :: !(Maybe Text) -- ^ "stateAbbreviation" - State name&#39;s abbreviation
  , consumerCreditReportOnlineDirectoryZipCode :: !(Maybe Text) -- ^ "zipCode" - Zip code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportOnlineDirectory
instance A.FromJSON ConsumerCreditReportOnlineDirectory where
  parseJSON = A.withObject "ConsumerCreditReportOnlineDirectory" $ \o ->
    ConsumerCreditReportOnlineDirectory
      <$> (o .:? "customerNumber")
      <*> (o .:? "customerName")
      <*> (o .:? "telephoneNumber")
      <*> (o .:? "addressLine1")
      <*> (o .:? "addressLine2")
      <*> (o .:? "city")
      <*> (o .:? "stateAbbreviation")
      <*> (o .:? "zipCode")

-- | ToJSON ConsumerCreditReportOnlineDirectory
instance A.ToJSON ConsumerCreditReportOnlineDirectory where
  toJSON ConsumerCreditReportOnlineDirectory {..} =
   _omitNulls
      [ "customerNumber" .= consumerCreditReportOnlineDirectoryCustomerNumber
      , "customerName" .= consumerCreditReportOnlineDirectoryCustomerName
      , "telephoneNumber" .= consumerCreditReportOnlineDirectoryTelephoneNumber
      , "addressLine1" .= consumerCreditReportOnlineDirectoryAddressLine1
      , "addressLine2" .= consumerCreditReportOnlineDirectoryAddressLine2
      , "city" .= consumerCreditReportOnlineDirectoryCity
      , "stateAbbreviation" .= consumerCreditReportOnlineDirectoryStateAbbreviation
      , "zipCode" .= consumerCreditReportOnlineDirectoryZipCode
      ]


-- | Construct a value of type 'ConsumerCreditReportOnlineDirectory' (by applying it's required fields, if any)
mkConsumerCreditReportOnlineDirectory
  :: ConsumerCreditReportOnlineDirectory
mkConsumerCreditReportOnlineDirectory =
  ConsumerCreditReportOnlineDirectory
  { consumerCreditReportOnlineDirectoryCustomerNumber = Nothing
  , consumerCreditReportOnlineDirectoryCustomerName = Nothing
  , consumerCreditReportOnlineDirectoryTelephoneNumber = Nothing
  , consumerCreditReportOnlineDirectoryAddressLine1 = Nothing
  , consumerCreditReportOnlineDirectoryAddressLine2 = Nothing
  , consumerCreditReportOnlineDirectoryCity = Nothing
  , consumerCreditReportOnlineDirectoryStateAbbreviation = Nothing
  , consumerCreditReportOnlineDirectoryZipCode = Nothing
  }

-- ** ConsumerCreditReportOnlineGeoCode
-- | ConsumerCreditReportOnlineGeoCode
data ConsumerCreditReportOnlineGeoCode = ConsumerCreditReportOnlineGeoCode
  { consumerCreditReportOnlineGeoCodeGeoSmsaCode :: !(Maybe Text) -- ^ "geoSMSACode" - Metropolitan Statistical Area Code
  , consumerCreditReportOnlineGeoCodeGeoStateCode :: !(Maybe Text) -- ^ "geoStateCode" - State code
  , consumerCreditReportOnlineGeoCodeGeoCountyCode :: !(Maybe Text) -- ^ "geoCountyCode" - County code
  , consumerCreditReportOnlineGeoCodeGeoCensusTract :: !(Maybe Text) -- ^ "geoCensusTract" - Census tract code
  , consumerCreditReportOnlineGeoCodeGeoSuffix :: !(Maybe Text) -- ^ "geoSuffix" - Census tract code suffix
  , consumerCreditReportOnlineGeoCodeGeoBlockGroup :: !(Maybe Text) -- ^ "geoBlockGroup" - Block group code.
  , consumerCreditReportOnlineGeoCodeStreetNumber :: !(Maybe Text) -- ^ "streetNumber" - Street number
  , consumerCreditReportOnlineGeoCodeStreetName :: !(Maybe Text) -- ^ "streetName" - Street name
  , consumerCreditReportOnlineGeoCodeStreetTypeOrDirection :: !(Maybe Text) -- ^ "streetTypeOrDirection" - Street Type or Direction - Drive, Street, Road, etc. East, West, etc
  , consumerCreditReportOnlineGeoCodeGeoSmsa5DigitCode :: !(Maybe Text) -- ^ "geoSMSA5DigitCode" - Standard Metropolitan Statistical Area Code
  , consumerCreditReportOnlineGeoCodeCity :: !(Maybe Text) -- ^ "city" - City name
  , consumerCreditReportOnlineGeoCodeStateAbbreviation :: !(Maybe Text) -- ^ "stateAbbreviation" - State name&#39;s abbreviation
  , consumerCreditReportOnlineGeoCodeZipCode :: !(Maybe Text) -- ^ "zipCode" - Zip code
  , consumerCreditReportOnlineGeoCodeTypeOfAddress :: !(Maybe ConsumerCreditReportTypeOfAddress) -- ^ "typeOfAddress"
  , consumerCreditReportOnlineGeoCodeReturnCode1 :: !(Maybe ConsumerCreditReportReturnCode1) -- ^ "returnCode1"
  , consumerCreditReportOnlineGeoCodeReturnCode2 :: !(Maybe ConsumerCreditReportReturnCode2) -- ^ "returnCode2"
  , consumerCreditReportOnlineGeoCodeReturnCode3 :: !(Maybe ConsumerCreditReportReturnCode3) -- ^ "returnCode3"
  , consumerCreditReportOnlineGeoCodeReturnCode4 :: !(Maybe ConsumerCreditReportReturnCode4) -- ^ "returnCode4"
  , consumerCreditReportOnlineGeoCodeMicroVisionCode :: !(Maybe Text) -- ^ "microVisionCode"
  , consumerCreditReportOnlineGeoCodeMicroVisionReturnCode :: !(Maybe Text) -- ^ "microVisionReturnCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportOnlineGeoCode
instance A.FromJSON ConsumerCreditReportOnlineGeoCode where
  parseJSON = A.withObject "ConsumerCreditReportOnlineGeoCode" $ \o ->
    ConsumerCreditReportOnlineGeoCode
      <$> (o .:? "geoSMSACode")
      <*> (o .:? "geoStateCode")
      <*> (o .:? "geoCountyCode")
      <*> (o .:? "geoCensusTract")
      <*> (o .:? "geoSuffix")
      <*> (o .:? "geoBlockGroup")
      <*> (o .:? "streetNumber")
      <*> (o .:? "streetName")
      <*> (o .:? "streetTypeOrDirection")
      <*> (o .:? "geoSMSA5DigitCode")
      <*> (o .:? "city")
      <*> (o .:? "stateAbbreviation")
      <*> (o .:? "zipCode")
      <*> (o .:? "typeOfAddress")
      <*> (o .:? "returnCode1")
      <*> (o .:? "returnCode2")
      <*> (o .:? "returnCode3")
      <*> (o .:? "returnCode4")
      <*> (o .:? "microVisionCode")
      <*> (o .:? "microVisionReturnCode")

-- | ToJSON ConsumerCreditReportOnlineGeoCode
instance A.ToJSON ConsumerCreditReportOnlineGeoCode where
  toJSON ConsumerCreditReportOnlineGeoCode {..} =
   _omitNulls
      [ "geoSMSACode" .= consumerCreditReportOnlineGeoCodeGeoSmsaCode
      , "geoStateCode" .= consumerCreditReportOnlineGeoCodeGeoStateCode
      , "geoCountyCode" .= consumerCreditReportOnlineGeoCodeGeoCountyCode
      , "geoCensusTract" .= consumerCreditReportOnlineGeoCodeGeoCensusTract
      , "geoSuffix" .= consumerCreditReportOnlineGeoCodeGeoSuffix
      , "geoBlockGroup" .= consumerCreditReportOnlineGeoCodeGeoBlockGroup
      , "streetNumber" .= consumerCreditReportOnlineGeoCodeStreetNumber
      , "streetName" .= consumerCreditReportOnlineGeoCodeStreetName
      , "streetTypeOrDirection" .= consumerCreditReportOnlineGeoCodeStreetTypeOrDirection
      , "geoSMSA5DigitCode" .= consumerCreditReportOnlineGeoCodeGeoSmsa5DigitCode
      , "city" .= consumerCreditReportOnlineGeoCodeCity
      , "stateAbbreviation" .= consumerCreditReportOnlineGeoCodeStateAbbreviation
      , "zipCode" .= consumerCreditReportOnlineGeoCodeZipCode
      , "typeOfAddress" .= consumerCreditReportOnlineGeoCodeTypeOfAddress
      , "returnCode1" .= consumerCreditReportOnlineGeoCodeReturnCode1
      , "returnCode2" .= consumerCreditReportOnlineGeoCodeReturnCode2
      , "returnCode3" .= consumerCreditReportOnlineGeoCodeReturnCode3
      , "returnCode4" .= consumerCreditReportOnlineGeoCodeReturnCode4
      , "microVisionCode" .= consumerCreditReportOnlineGeoCodeMicroVisionCode
      , "microVisionReturnCode" .= consumerCreditReportOnlineGeoCodeMicroVisionReturnCode
      ]


-- | Construct a value of type 'ConsumerCreditReportOnlineGeoCode' (by applying it's required fields, if any)
mkConsumerCreditReportOnlineGeoCode
  :: ConsumerCreditReportOnlineGeoCode
mkConsumerCreditReportOnlineGeoCode =
  ConsumerCreditReportOnlineGeoCode
  { consumerCreditReportOnlineGeoCodeGeoSmsaCode = Nothing
  , consumerCreditReportOnlineGeoCodeGeoStateCode = Nothing
  , consumerCreditReportOnlineGeoCodeGeoCountyCode = Nothing
  , consumerCreditReportOnlineGeoCodeGeoCensusTract = Nothing
  , consumerCreditReportOnlineGeoCodeGeoSuffix = Nothing
  , consumerCreditReportOnlineGeoCodeGeoBlockGroup = Nothing
  , consumerCreditReportOnlineGeoCodeStreetNumber = Nothing
  , consumerCreditReportOnlineGeoCodeStreetName = Nothing
  , consumerCreditReportOnlineGeoCodeStreetTypeOrDirection = Nothing
  , consumerCreditReportOnlineGeoCodeGeoSmsa5DigitCode = Nothing
  , consumerCreditReportOnlineGeoCodeCity = Nothing
  , consumerCreditReportOnlineGeoCodeStateAbbreviation = Nothing
  , consumerCreditReportOnlineGeoCodeZipCode = Nothing
  , consumerCreditReportOnlineGeoCodeTypeOfAddress = Nothing
  , consumerCreditReportOnlineGeoCodeReturnCode1 = Nothing
  , consumerCreditReportOnlineGeoCodeReturnCode2 = Nothing
  , consumerCreditReportOnlineGeoCodeReturnCode3 = Nothing
  , consumerCreditReportOnlineGeoCodeReturnCode4 = Nothing
  , consumerCreditReportOnlineGeoCodeMicroVisionCode = Nothing
  , consumerCreditReportOnlineGeoCodeMicroVisionReturnCode = Nothing
  }

-- ** ConsumerCreditReportOtherIdentification
-- | ConsumerCreditReportOtherIdentification
data ConsumerCreditReportOtherIdentification = ConsumerCreditReportOtherIdentification
  { consumerCreditReportOtherIdentificationDateReported :: !(Maybe Date) -- ^ "dateReported" - Date the other identification was reported to Equifax
  , consumerCreditReportOtherIdentificationTypeCode :: !(Maybe ConsumerCreditReportTypeCode) -- ^ "typeCode"
  , consumerCreditReportOtherIdentificationIdentificationNumber :: !(Maybe Text) -- ^ "identificationNumber" - Identification number
  , consumerCreditReportOtherIdentificationReasonCode :: !(Maybe ConsumerCreditReportReasonCode) -- ^ "reasonCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportOtherIdentification
instance A.FromJSON ConsumerCreditReportOtherIdentification where
  parseJSON = A.withObject "ConsumerCreditReportOtherIdentification" $ \o ->
    ConsumerCreditReportOtherIdentification
      <$> (o .:? "dateReported")
      <*> (o .:? "typeCode")
      <*> (o .:? "identificationNumber")
      <*> (o .:? "reasonCode")

-- | ToJSON ConsumerCreditReportOtherIdentification
instance A.ToJSON ConsumerCreditReportOtherIdentification where
  toJSON ConsumerCreditReportOtherIdentification {..} =
   _omitNulls
      [ "dateReported" .= consumerCreditReportOtherIdentificationDateReported
      , "typeCode" .= consumerCreditReportOtherIdentificationTypeCode
      , "identificationNumber" .= consumerCreditReportOtherIdentificationIdentificationNumber
      , "reasonCode" .= consumerCreditReportOtherIdentificationReasonCode
      ]


-- | Construct a value of type 'ConsumerCreditReportOtherIdentification' (by applying it's required fields, if any)
mkConsumerCreditReportOtherIdentification
  :: ConsumerCreditReportOtherIdentification
mkConsumerCreditReportOtherIdentification =
  ConsumerCreditReportOtherIdentification
  { consumerCreditReportOtherIdentificationDateReported = Nothing
  , consumerCreditReportOtherIdentificationTypeCode = Nothing
  , consumerCreditReportOtherIdentificationIdentificationNumber = Nothing
  , consumerCreditReportOtherIdentificationReasonCode = Nothing
  }

-- ** ConsumerCreditReportReasonCode
-- | ConsumerCreditReportReasonCode
-- Reason code
data ConsumerCreditReportReasonCode = ConsumerCreditReportReasonCode
  { consumerCreditReportReasonCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportReasonCodeDescription :: !(Maybe Text) -- ^ "description" - Reason codes - B: Tax ID Number - C: Minor child - E: S.I.N. (Canadian Social Insurance Number) - V: Variation 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportReasonCode
instance A.FromJSON ConsumerCreditReportReasonCode where
  parseJSON = A.withObject "ConsumerCreditReportReasonCode" $ \o ->
    ConsumerCreditReportReasonCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportReasonCode
instance A.ToJSON ConsumerCreditReportReasonCode where
  toJSON ConsumerCreditReportReasonCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportReasonCodeCode
      , "description" .= consumerCreditReportReasonCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportReasonCode' (by applying it's required fields, if any)
mkConsumerCreditReportReasonCode
  :: ConsumerCreditReportReasonCode
mkConsumerCreditReportReasonCode =
  ConsumerCreditReportReasonCode
  { consumerCreditReportReasonCodeCode = Nothing
  , consumerCreditReportReasonCodeDescription = Nothing
  }

-- ** ConsumerCreditReportReasons
-- | ConsumerCreditReportReasons
data ConsumerCreditReportReasons = ConsumerCreditReportReasons
  { consumerCreditReportReasonsCode :: !(Maybe Text) -- ^ "code" - Code value
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportReasons
instance A.FromJSON ConsumerCreditReportReasons where
  parseJSON = A.withObject "ConsumerCreditReportReasons" $ \o ->
    ConsumerCreditReportReasons
      <$> (o .:? "code")

-- | ToJSON ConsumerCreditReportReasons
instance A.ToJSON ConsumerCreditReportReasons where
  toJSON ConsumerCreditReportReasons {..} =
   _omitNulls
      [ "code" .= consumerCreditReportReasonsCode
      ]


-- | Construct a value of type 'ConsumerCreditReportReasons' (by applying it's required fields, if any)
mkConsumerCreditReportReasons
  :: ConsumerCreditReportReasons
mkConsumerCreditReportReasons =
  ConsumerCreditReportReasons
  { consumerCreditReportReasonsCode = Nothing
  }

-- ** ConsumerCreditReportRejects
-- | ConsumerCreditReportRejects
-- Reject codes corresponding to the model
data ConsumerCreditReportRejects = ConsumerCreditReportRejects
  { consumerCreditReportRejectsCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportRejectsDescription :: !(Maybe Text) -- ^ "description" - Reject Codes corresponding to Model Number 02781   - A1: File Under Review   - B0: Insufficient Information to Score   - D0: Bankruptcy On File   - L0: Subject Deceased   - N1: Inquiry Only File   - X7: File Cannot Be Scored    Reject Codes corresponding to Model Number 02782   - A1: File Under Review   - B0: Insufficient Information to Score   - D0: Bankruptcy On File   - L0: Subject Deceased   - N1: Inquiry Only File   - X7: File Cannot Be Scored    Reject Codes corresponding to Model Number 02783   - A1: File Under Review   - B0: Insufficient Information to Score   - D0: Bankruptcy On File   - L0: Subject Deceased   - N1: Inquiry Only File   - X7: File Cannot Be Scored    Reject Codes corresponding to Model Number 02784   - A1: File Under Review   - B0: Insufficient Information to Score   - D0: Bankruptcy On File   - L0: Subject Deceased   - N1: Inquiry Only File   - X7: File Cannot Be Scored    Reject Codes corresponding to Model Number 05146   - A1: File Under Review   - C1: No Qualifying Accounts Present   - C2: Bankruptcy Occurrence Present   - L0: Consumer Deceased   - R0: Insufficient Information to Score   - X1: Model Delivery Temporarily Unavailable   - X3: Too Many Inquiries on File   - X5: No Input Fields Provided   - X7: Model Delivery Temporarily Unavailable, File Cannot Be Scored    Reject Codes corresponding to Model Number 05147   - A1: File Under Review   - C1: No Qualifying Accounts Present   - C2: Bankruptcy Occurrence Present   - L0: Consumer Deceased   - R0: Insufficient Information to Score   - X1: Model Delivery Temporarily Unavailable   - X3: Too Many Inquiries on File   - X5: No Input Fields Provided   - X7: Model Delivery Temporarily Unavailable, File Cannot Be Scored    Reject Codes corresponding to Model Number 05276   - A1: File Under Review   - C1: No Qualifying Accounts Present   - C2: Bankruptcy Occurrence Present   - L0: Consumer Deceased   - R0: Insufficient Information to Score   - X1: Model Delivery Temporarily Unavailable   - X3: Too Many Inquiries on File   - X5: No Input Fields Provided   - X7: Model Delivery Temporarily Unavailable, File Cannot Be Scored  Reject Codes corresponding to Model Number 05277   - A1: File Under Review   - C1: No Qualifying Accounts Present   - C2: Bankruptcy Occurrence Present   - L0: Consumer Deceased   - R0: Insufficient Information to Score   - X1: Model Delivery Temporarily Unavailable   - X3: Too Many Inquiries on File   - X5: No Input Fields Provided   - X7: Model Delivery Temporarily Unavailable, File Cannot Be Scored    Reject Codes corresponding to Model Number 02502   - B0: No trade or inquiry reported within the last 24 months   - B1: Subject Deceased   - D0: Bankruptcy on File   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02503   - B0: No trade or inquiry reported within the last 24 months   - B1: Subject Deceased   - D0: Bankruptcy on File   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02037   - B0: No trade or inquiry reported within 24 months   - B1: Subject deceased   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02525   - B0: No trade or inquiry reported within 24 months   - B1: Subject deceased   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02725   - B0: No trade or inquiry reported within 24 months   - B1: Subject deceased   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02874   - B0: Model Delivery is Not Available: Insufficient Information to Score   - L0: Model Delivery is Not Available: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available: File Under Review   - F1: Model Delivery is Not Available: No Qualifying Accounts Present    Reject Codes corresponding to Model Number 02875   - B0: Model Delivery is Not Available: Insufficient Information to Score   - L0: Model Delivery is Not Available: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available: File Under Review   - F1: Model Delivery is Not Available: No Qualifying Accounts Present    Reject Codes corresponding to Model Number 02893   - B0: Model Delivery is Not Available: Insufficient Information to Score   - L0: Model Delivery is Not Available: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available: File Under Review   - F1: Model Delivery is Not Available: No Qualifying Accounts Present    Reject Codes corresponding to Model Number 02481   - B0: No trade or inquiry reported within 24 months   - L0: Subject Deceased   - L1: No qualifying information present   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02527   - B0: No trade or inquiry reported within 24 months   - L0: Subject Deceased   - L1: No qualifying information present   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02575   - B0: No trade or inquiry reported within 24 months   - L0: Subject Deceased   - X7: File cannot be scored   - A1: File Under Review    Reject Codes corresponding to Model Number 02531   - P1: Subject deceased   - P2: No qualifying trades   - P3: Insufficient or unknown tradeline history   - P4: No recently reported tradelines   - P5: No recent trades w/o data suppression or disputed info   - P6: Unable to score   - X7: Model delivery is temporarily unavailable    Reject Codes corresponding to Model Number 02825   - P1: Subject deceased   - P2: No qualifying trades   - P3: Insufficient or unknown tradeline history   - P4: No recently reported tradelines   - P5: No recent trades w/o data suppression or disputed info   - P6: Unable to score   - X7: Model delivery is temporarily unavailable    Reject Codes corresponding to Model Number 02905   - P1: Subject deceased   - P2: No qualifying trades   - P3: Insufficient or unknown tradeline history   - P4: No recently reported tradelines   - P5: No recent trades w/o data suppression or disputed info   - P6: Unable to score   - X7: Model delivery is temporarily unavailable    Reject Codes corresponding to Model Number 02906   - P1: Subject deceased   - P2: No qualifying trades   - P3: Insufficient or unknown tradeline history   - P4: No recently reported tradelines   - P5: No recent trades w/o data suppression or disputed info   - P6: Unable to score   - X7: Model delivery is temporarily unavailable    Reject Codes corresponding to Model Number 02682   - A1: File Under Review   - B0: Insufficient Information to Score   - L0: Subject deceased   - X7: File Cannot Be Scored    Reject Codes corresponding to Model Number 02718   - A1: File Under Review   - B0: Insufficient Information to Score   - L0: Subject deceased   - X7: File Cannot Be Scored   - N1: Inquiry Only File    Reject Codes corresponding to Model Number 02485   - B0: No trade or inquiry reported within the last 24 months   - X7: File cannot be scored    Reject Codes corresponding to Model Number 02505   - B1: Subject Deceased   - F1: No qualifying accounts present   - F3: No recently reported account information   - A0: Not available, file cannot be scored    Reject Codes corresponding to Model Number 02558   - B1: Subject Deceased   - F1: No qualifying accounts present   - F3: No recently reported account information   - A0: Not available, file cannot be scored    Reject Codes corresponding to Model Number 01203   - A1: File Under Review   - B0: Insufficient Information to Score   - F1: No Qualifying Accounts Present   - L0: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable    Reject Codes corresponding to Model Number 01204   - A1: File Under Review   - B0: Insufficient Information to Score   - F1: No Qualifying Accounts Present   - L0: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable  Reject Codes corresponding to Model Number 02912   - A1: File Under Review   - B0: Insufficient Information to Score   - F1: No Qualifying Accounts Present   - L0: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable  Reject Codes corresponding to Model Number 02903   - A1: File Under Review   - B0: Insufficient Information to Score   - F1: No Qualifying Accounts Present   - L0: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable  Reject Codes corresponding to Model Number 02904   - A1: File Under Review   - B0: Insufficient Information to Score   - F1: No Qualifying Accounts Present   - L0: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable  Reject Codes corresponding to Model Number 02470   - B0: No trade or inquiry reported within 24 months   - B1: Subject deceased   - X7: File cannot be scored  Reject Codes corresponding to Model Number 02557   - B0: No trade or inquiry reported within 24 months   - B1: Subject deceased   - X7: File cannot be scored  Reject Codes corresponding to Model Number 02458   - B0: No trade or inquiry reported within 24 months   - B1: Subject deceased   - X7: File cannot be scored  Reject Codes corresponding to Model Number 02479   - B0: No trade or inquiry reported within the last 24 months   - B1: Subject Deceased   - D0: Bankruptcy on file   - X7: File cannot be scored  Reject Codes corresponding to Model Number 02978   - L0: Deceased   - F1: Lack of Trades   - B0: Lack of Activity   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available  Reject Codes corresponding to Model Number 02991   - L0: Deceased   - F1: Lack of Trades   - B0: Lack of Activity   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available  Reject Codes corresponding to Model Number 05008   - L0: Deceased   - F1: Lack of Trades   - B0: Lack of Activity   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available  Reject Codes corresponding to Model Number 05028   - L0: Deceased   - F1: Lack of Trades   - B0: Lack of Activity   - X7: Model Delivery is Temporarily Unavailable   - A1: Model Delivery is Not Available  Reject Codes corresponding to Model Number 05143   - 000L0: Deceased   - 000F1: Lack of Trades   - 000B0: Lack of Activity   - 000X7: Model Delivery is Temporarily Unavailable   - 000A1: Model Delivery is Not Available  Reject Codes corresponding to Model Number 05151   - 000L0: Deceased   - 000F1: Lack of Trades   - 000B0: Lack of Activity   - 000X7: Model Delivery is Temporarily Unavailable   - 000A1: Model Delivery is Not Available  Reject Codes corresponding to Model Number 02770   - B0: Insufficient Information to Score   - L0: Subject Deceased   - X7: Model Delivery is Temporarily Unavailable   - A1: File Under Review  Reject Codes corresponding to Model Number 02778   - B1: Subject deceased   - F1: No trades on file   - F2: No trades on file with date open older than 5 months   - F3: No trades on files with date reported in last 6 months   - F4: No trades on file with a valid current status and without data suppression or disputed info   - X5: Invalid source data input (request missing a 1, 2, 3, 4 or 5 for the score desired)  Reject Codes corresponding to Model Number 02779   - B1: Subject deceased   - F1: No trades on file   - F2: No trades on file with date open older than 5 months   - F3: No trades on files with date reported in last 6 months   - F4: No trades on file with a valid current status and without data suppression or disputed info   - X5: Invalid source data input (request missing a 1, 2, 3, 4 or 5 for the score desired)  Reject Codes corresponding to Model Number 01958   - B0: No Trade/Inq     - B1: Deceased  Reject Codes corresponding to Model Number 01918   - B0: No Trade/Inq     - L0: Deceased  Reject Codes corresponding to Model Number 05236   - 01: DECEASED ON CREDIT, NCTUE AND LEXISNEXIS   - 02: DECEASED ON CREDIT AND NCTUE   - 03: DECEASED ON CREDIT AND LEXISNEXIS   - 04: DECEASED ON NCTUE AND LEXISNEXIS   - 05: DECEASED ON CREDIT   - 06: DECEASED ON NCTUE   - 07: DECEASED ON LEXISNEXIS   - 08: FILE IN REVIEW-CREDIT,FRAUD-NCTUE,IDENTITY THEFT -LEXISNEXIS   - 09: FILE IN REVIEW-CREDIT,FRAUD-NCTUE   - 10: FILE IN REVIEW-CREDIT,IDENTITY THEFT -LEXISNEXIS   - 11: FRAUD-NCTUE,IDENTITY THEFT -LEXISNEXIS   - 12: FILE IN REVIEW-CREDIT   - 13: FRAUD-NCTUE   - 14: IDENTITY THEFT -LEXISNEXIS   - 15: NO HIT-CREDIT,NO HIT-NCTUE,NO HIT-LEXISNEXIS   - 16: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,NO HIT-LEXISNEXIS   - 17: NO HIT-CREDIT,INQUIRY ONLY-NCTUE,NO HIT-LEXISNEXIS   - 18: INADEQUATE INFO-CREDIT,INQUIRY ONLY-NCTUE,NO HIT-LEXISNEXIS   - 19: NO HIT-CREDIT,BANKRUPTCY-NCTUE,NO HIT-LEXISNEXIS   - 20: INADEQUATE INFO-CREDIT,BANKRUPTCY-NCTUE,NO HIT-LEXISNEXIS   - 21: NO HIT-CREDIT,NO HIT-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 22: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 23: NO HIT-CREDIT,INQ ONLY-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 24: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 25: NO HIT-CREDIT,BKP-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 26: INADEQUATE INFO-CREDIT,BKP-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 27: NO HIT-CREDIT,NO HIT-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 28: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 29: NO HIT-CREDIT,INQ ONLY-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 30: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 31: NO HIT-CREDIT,BKP-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 32: INADEQUATE INFO-CREDIT,BKP-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 33: NO HIT-CREDIT,NO HIT-NCTUE,SECURITY ALERT-LEXISNEXIS   - 34: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,SECURITY ALERT-LEXISNEXIS   - 35: NO HIT-CREDIT,INQ ONLY-NCTUE,SECURITY ALERT-LEXISNEXIS   - 36: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,SECURITY ALERT-LEXISNEXIS   - 37: NO HIT-CREDIT,BKP-NCTUE,SECURITY ALERT-LEXISNEXIS   - 38: INADEQUATE INFO-CREDIT,BKP-NCTUE,SECURITY ALERT-LEXISNEXIS   - 39: NO HIT-CREDIT,NO HIT-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 40: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 41: NO HIT-CREDIT,INQ ONLY-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 42: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 43: NO HIT-CREDIT,BKP-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 44: INADEQUATE INFO-CREDIT,BKP-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 45: NO HIT-CREDIT,NO HIT-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 46: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 47: NO HIT-CREDIT,INQ ONLY-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 48: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 49: NO HIT-CREDIT,BKP-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 50: INADEQUATE INFO-CREDIT,BKP-NCTUE,INADEQUATE INFO-LEXISNEXIS   - A1: **NOT AVAILABLE, FILE UNDER REVIEW   - B0: INSUFFICIENT INFORMATION TO SCORE   - C1: MODEL DELIVERY IS NOT AVAILABLE: NO QUALIFYING ACCOUNTS PRESENT. NO HIT   - C2: MODEL DELIVERY UNAVAILABLE: FILE CONDITION NOT MET   - C3: ADDRESS FORMATTED INCORRECTLY FOR ALTERNATE DATA SOURCE   - C4: NAME FORMATTED INCORRECTLY FOR ALTERNATE DATA SOURCE   - C5: BUSINESS NAME INVALID   - C6: XML FORMAT ERROR BETWEEN INTERNAL DATABASES    - C7: INVALID ALTERNATE DATA SOURCE MBR NBR ON DATABASE SERVER   - C8: ALTERNATE DATA SOURCE MBR NBR NOT AUTHORIZED ON DATABASE   - C9: INVALID SECURITY CODE FOR ALTERNATE DATA SRCE ON DATABASE   - CC: NOT AUTHORIZED TO RECEIVE INSIGHT SCORES   - CD: INVALID PRODUCT CONFIGURATION FOR INSIGHT SCORES   - CE: ALTERNATE DATA SOURCE ERROR - MAX OF 4 ADDRESSES ALLOWED   - CF: INVALID ONLINE MATCH CONFIGURATION FOR INSIGHT SCORE   - CG: ALTERNATE DATA SRC ERROR - NO CONSUMER SRCH FIELDS PROVIDED   - CH: MISSING REQUIRED FIELDS FOR INTERNAL DATABASE SEARCH   - CJ: INTERNAL DATABASE ERROR - PLEASE TRY LATER OR CONTACT EFX   - CK: INTERNAL MDB LAYOUT ERROR   - CL: RETRY TRANSACTION TRANSIENT ERROR   - CQ: INTERNAL PROCESSING ERROR PLEASE TRY LATER OR CONTACT EFX   - CS: MODEL SERVER ERROR PLEASE TRY AGAIN LATER OR CONTACT EFX   - CT: INTERNAL CUSTOMER ID ERROR   - CX: HTTP ERROR RETURNED TO OMS FROM NC+/CONNEXUS   - CZ: RETRY TRANSACTION - IF ERROR CONTINUES, CONTACT EQUIFAX   - L0: MODEL DELIVERY IS NOT AVAILABLE: SUBJECT DECEASED   - N1: INQUIRY ONLY FILE   - R0: MODEL DELIVERY IS NOT AVAILABLE: INSUFFICIENT INFORMATION TO SCORE   - X7: MODEL DELIVERY IS TEMPORARILY UNAVAILABLE  Reject Codes corresponding to Model Number 05168   - B: RISKWISE AUTHORIZATION REQUIRED - CONTACT YOUR SALES REP   - R: DATA SOURCE CURRENTLY UNAVAILABLE   - S: DATA SOURCE CURRENTLY UNAVAILABLE   - T: REQUESTED PRODUCT UNAVAILABLE, CONTACT SALES REP   - U: UNABLE TO ACCESS DATA SOURCE   - V: UNABLE TO ACCESS DATA SOURCE   - W: DATA SOURCE IS TEMPORARILY OUT OF SERVICE   - X: DATA SOURCE IS TEMPORARILY OUT OF SERVICE   - Y: REQUIRED DATA NOT PRESENT   - Z: REQUIRED DATA NOT PRESENT 04  Reject Codes corresponding to Model Number 05271   - A1: MODEL DELIVERY NOT AVAILABLE: FILE UNDER REVIEW   - C1: MODEL DELIVERY NOT AVAILABLE: NO QUALIFYING ACCOUNTS PRESENT. NO HIT   - L0: MODEL DELIVERY NOT AVAILABLE: SUBJECT DECEASED   - R0: MODEL DELIVERY NOT AVAILABLE: INSUFFICIENT INFORMATION TO SCORE  Reject Codes corresponding to Model Number 05274   - 01: DECEASED ON CREDIT, NCTUE AND LEXISNEXIS   - 02: DECEASED ON CREDIT AND NCTUE   - 03: DECEASED ON CREDIT AND LEXISNEXIS   - 04: DECEASED ON NCTUE AND LEXISNEXIS   - 05: DECEASED ON CREDIT   - 06: DECEASED ON NCTUE   - 07: DECEASED ON LEXISNEXIS   - 08: FILE IN REVIEW-CREDIT,FRAUD-NCTUE,IDENTITY THEFT -LEXISNEXIS   - 09: FILE IN REVIEW-CREDIT,FRAUD-NCTUE   - 10: FILE IN REVIEW-CREDIT,IDENTITY THEFT -LEXISNEXIS   - 11: FRAUD-NCTUE,IDENTITY THEFT -LEXISNEXIS   - 12: FILE IN REVIEW-CREDIT   - 13: FRAUD-NCTUE   - 14: IDENTITY THEFT -LEXISNEXIS   - 15: NO HIT-CREDIT,NO HIT-NCTUE,NO HIT-LEXISNEXIS   - 16: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,NO HIT-LEXISNEXIS   - 17: NO HIT-CREDIT,INQUIRY ONLY-NCTUE,NO HIT-LEXISNEXIS   - 18: INADEQUATE INFO-CREDIT,INQUIRY ONLY-NCTUE,NO HIT-LEXISNEXIS   - 19: NO HIT-CREDIT,BANKRUPTCY-NCTUE,NO HIT-LEXISNEXIS   - 20: INADEQUATE INFO-CREDIT,BANKRUPTCY-NCTUE,NO HIT-LEXISNEXIS   - 21: NO HIT-CREDIT,NO HIT-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 22: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 23: NO HIT-CREDIT,INQ ONLY-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 24: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 25: NO HIT-CREDIT,BKP-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 26: INADEQUATE INFO-CREDIT,BKP-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 27: NO HIT-CREDIT,NO HIT-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 28: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 29: NO HIT-CREDIT,INQ ONLY-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 30: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 31: NO HIT-CREDIT,BKP-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 32: INADEQUATE INFO-CREDIT,BKP-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 33: NO HIT-CREDIT,NO HIT-NCTUE,SECURITY ALERT-LEXISNEXIS   - 34: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,SECURITY ALERT-LEXISNEXIS   - 35: NO HIT-CREDIT,INQ ONLY-NCTUE,SECURITY ALERT-LEXISNEXIS   - 36: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,SECURITY ALERT-LEXISNEXIS   - 37: NO HIT-CREDIT,BKP-NCTUE,SECURITY ALERT-LEXISNEXIS   - 38: INADEQUATE INFO-CREDIT,BKP-NCTUE,SECURITY ALERT-LEXISNEXIS   - 39: NO HIT-CREDIT,NO HIT-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 40: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 41: NO HIT-CREDIT,INQ ONLY-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 42: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 43: NO HIT-CREDIT,BKP-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 44: INADEQUATE INFO-CREDIT,BKP-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 45: NO HIT-CREDIT,NO HIT-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 46: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 47: NO HIT-CREDIT,INQ ONLY-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 48: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 49: NO HIT-CREDIT,BKP-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 50: INADEQUATE INFO-CREDIT,BKP-NCTUE,INADEQUATE INFO-LEXISNEXIS   - A1: **NOT AVAILABLE, FILE UNDER REVIEW   - C1: MODEL DELIVERY IS NOT AVAILABLE: NO QUALIFYING ACCOUNTS PRESENT. NO HIT   - C2: MODEL DELIVERY UNAVAILABLE, FILE CONDITION NOT MET   - C3: ADDRESS FORMATTED INCORRECTLY FOR ALTERNATE DATA SOURCE   - C4: NAME FORMATTED INCORRECTLY FOR ALTERNATE DATA SOURCE   - C5: BUSINESS NAME INVALID   - C6: XML FORMAT ERROR BETWEEN INTERNAL DATABASES    - C7: INVALID ALTERNATE DATA SOURCE MBR NBR ON DATABASE SERVER   - C8: ALTERNATE DATA SOURCE MBR NBR NOT AUTHORIZED ON DATABASE   - C9: INVALID SECURITY CODE FOR ALTERNATE DATA SRCE ON DATABASE   - CC: NOT AUTHORIZED TO RECEIVE INSIGHT SCORES   - CD: INVALID PRODUCT CONFIGURATION FOR INSIGHT SCORES   - CE: ALTERNATE DATA SOURCE ERROR - MAX OF 4 ADDRESSES ALLOWED   - CF: INVALID ONLINE MATCH CONFIGURATION FOR INSIGHT SCORE   - CG: ALTERNATE DATA SRC ERROR - NO CONSUMER SRCH FIELDS PROVIDED   - CH: MISSING REQUIRED FIELDS FOR INTERNAL DATABASE SEARCH   - CJ: INTERNAL DATABASE ERROR - PLEASE TRY LATER OR CONTACT EFX   - CK: INTERNAL MDB LAYOUT ERROR   - CL: RETRY TRANSACTION TRANSIENT ERROR   - CQ: INTERNAL PROCESSING ERROR PLEASE TRY LATER OR CONTACT EFX   - CS: MODEL SERVER ERROR PLEASE TRY AGAIN LATER OR CONTACT EFX   - CT: INTERNAL CUSTOMER ID ERROR   - CX: HTTP ERROR RETURNED TO OMS FROM NC+/CONNEXUS   - CZ: RETRY TRANSACTION - IF ERROR CONTINUES, CONTACT EQUIFAX   - L0: MODEL DELIVERY IS NOT AVAILABLE: SUBJECT DECEASED   - R0: MODEL DELIVERY IS NOT AVAILABLE: INSUFFICIENT INFORMATION TO SCORE  Reject Codes corresponding to Model Number 05285   - A1: **NOT AVAILABLE, FILE UNDER REVIEW   - B0: INSUFFICIENT INFORMATION TO SCORE   - C1: MODEL DELIVERY IS NOT AVAILABLE: NO QUALIFYING ACCOUNTS PRESENT. NO HIT   - L0: MODEL DELIVERY IS NOT AVAILABLE: SUBJECT DECEASED   - N1: INQUIRY ONLY FILE   - R0: MODEL DELIVERY IS NOT AVAILABLE: INSUFFICIENT INFORMATION TO SCORE   - X7: MODEL DELIVERY IS TEMPORARILY UNAVAILABLE  Reject Codes corresponding to Model Number 05264   - 01: DECEASED ON CREDIT, NCTUE AND LEXISNEXIS   - 02: DECEASED ON CREDIT AND NCTUE   - 03: DECEASED ON CREDIT AND LEXISNEXIS   - 04: DECEASED ON NCTUE AND LEXISNEXIS   - 05: DECEASED ON CREDIT   - 06: DECEASED ON NCTUE   - 07: DECEASED ON LEXISNEXIS   - 08: FILE IN REVIEW-CREDIT,FRAUD-NCTUE,IDENTITY THEFT-LEXISNEXIS   - 09: FILE IN REVIEW-CREDIT,FRAUD-NCTUE   - 10: FILE IN REVIEW-CREDIT,IDENTITY THEFT -LEXISNEXIS   - 11: FRAUD-NCTUE,IDENTITY THEFT -LEXISNEXIS   - 12: FILE IN REVIEW-CREDIT   - 13: FRAUD-NCTUE   - 14: IDENTITY THEFT -LEXISNEXIS   - 15: NO HIT-CREDIT,NO HIT-NCTUE,NO HIT-LEXISNEXIS   - 16: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,NO HIT-LEXISNEXIS   - 17: NO HIT-CREDIT,INQUIRY ONLY-NCTUE,NO HIT-LEXISNEXIS   - 18: INADEQUATE INFO-CREDIT,INQUIRY ONLY-NCTUE,NO HIT-LEXISNEXIS   - 19: NO HIT-CREDIT,BANKRUPTCY-NCTUE,NO HIT-LEXISNEXIS   - 20: INADEQUATE INFO-CREDIT,BANKRUPTCY-NCTUE,NO HIT-LEXISNEXIS   - 21: NO HIT-CREDIT,NO HIT-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 22: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 23: NO HIT-CREDIT,INQ ONLY-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 24: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 25: NO HIT-CREDIT,BKP-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 26: INADEQUATE INFO-CREDIT,BKP-NCTUE,FAIL CA VERIFY-LEXISNEXIS   - 27: NO HIT-CREDIT,NO HIT-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 28: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 29: NO HIT-CREDIT,INQ ONLY-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 30: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 31: NO HIT-CREDIT,BKP-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 32: INADEQUATE INFO-CREDIT,BKP-NCTUE,SECURITY FREEZE-LEXISNEXIS   - 33: NO HIT-CREDIT,NO HIT-NCTUE,SECURITY ALERT-LEXISNEXIS   - 34: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,SECURITY ALERT-LEXISNEXIS   - 35: NO HIT-CREDIT,INQ ONLY-NCTUE,SECURITY ALERT-LEXISNEXIS   - 36: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,SECURITY ALERT-LEXISNEXIS   - 37: NO HIT-CREDIT,BKP-NCTUE,SECURITY ALERT-LEXISNEXIS   - 38: INADEQUATE INFO-CREDIT,BKP-NCTUE,SECURITY ALERT-LEXISNEXIS   - 39: NO HIT-CREDIT,NO HIT-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 40: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 41: NO HIT-CREDIT,INQ ONLY-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 42: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 43: NO HIT-CREDIT,BKP-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 44: INADEQUATE INFO-CREDIT,BKP-NCTUE,DISPUTE ON FILE-LEXISNEXIS   - 45: NO HIT-CREDIT,NO HIT-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 46: INADEQUATE INFO-CREDIT,NO HIT-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 47: NO HIT-CREDIT,INQ ONLY-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 48: INADEQUATE INFO-CREDIT,INQ ONLY-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 49: NO HIT-CREDIT,BKP-NCTUE,INADEQUATE INFO-LEXISNEXIS   - 50: INADEQUATE INFO-CREDIT,BKP-NCTUE,INADEQUATE INFO-LEXISNEXIS   - A1: **NOT AVAILABLE, FILE UNDER REVIEW   - C1: NOT AVAILABLE: NO QUALIFYING ACCOUNTS PRESENT. NO HIT   - C6: XML FORMAT ERROR BETWEEN INTERNAL DATABASES   - C7: INVALID ALTERNATE DATA SOURCE MBR NBR ON DATABASE SERVER   - C8: ALTERNATE DATA SOURCE MBR NBR NOT AUTHORIZED ON DATABASE   - C9: INVALID SECURITY CODE FOR ALTERNATE DATA SRCE ON DATABASE   - CC: NOT AUTHORIZED TO RECEIVE INSIGHT SCORES   - CD: INVALID PRODUCT CONFIGURATION FOR INSIGHT SCORES   - CE: ALTERNATE DATA SOURCE ERROR - MAX OF 4 ADDRESSES ALLOWED   - CF: INVALID ONLINE MATCH CONFIGURATION FOR INSIGHT SCORE   - CG: ALTERNATE DATA SRC ERROR-NO CONSUMER SRCH FIELDS PROVIDED   - CH: MISSING REQUIRED FIELDS FOR INTERNAL DATABASE SEARCH   - CJ: INTERNAL DATABASE ERROR - PLEASE TRY LATER OR CONTACT EFX   - CK: INTERNAL MDS LAYOUT ERROR   - CL: RETRY TRANSACTION TRANSIENT ERROR   - CQ: INTERNAL PROCESSING ERROR PLEASE TRY LATER OR CONTACT EFX   - CS: MODEL SERVER ERROR PLEASE TRY AGAIN LATER OR CONTACT EFX   - CX: HTTP ERROR RETURNED TO OMS FROM NC+/CONNEXUS   - CZ: RETRY TRANSACTION . IF ERROR CONTINUES, CONTACT EQUIFAX   - L0: SUBJECT DECEASED INDICATED   - N1: INQUIRY ONLY FILE   - R0: MODEL DELIVERY IS NOT AVAILABLE: INSUFFICIENT INFORMATION TO SCORE   - X1: MODEL DELIVERY IS TEMPORARILY UNAVAILABLE: PROGRAM NOT DEFINED OR IN THE SYSTEM   - X3: MODEL DELIVERY IS TEMPORARILY UNAVAILABLE: TOO MANY INQUIRIES ON FILE   - X5: MODEL DELIVERY IS TEMPORARILY UNAVAILABLE: MODEL NEEDS INPUT FIELDS AND NONE WERE PROVIDED   - X7: MODEL DELIVERY IS TEMPORARILY UNAVAILABLE: FILE CANNOT BE SCORED  Reject Codes corresponding to Model Number 05184   - C1: MODEL DELIVERY UNAVAILABLE, SCORE RANGE NOT MET   - C2: MODEL DELIVERY UNAVAILABLE, FILE CONDITION NOT MET   - C3: ADDRESS FORMATTED INCORRECTLY FOR ALTERNATE DATA SOURCE   - C4: NAME FORMATTED INCORRECTLY FOR ALTERNATE DATA SOURCE   - C5: BUSINESS NAME INVALID   - C6: XML FORMAT ERROR BETWEEN INTERNAL DATABASES   - C7: INVALID ALTERNATE DATA SOURCE MBR NBR ON DATABASE SERVER   - C8: ALTERNATE DATA SOURCE MBR NBR NOT AUTHORIZED ON DATABASE   - C9: INVALID SECURITY CODE FOR ALTERNATE DATA SRCE ON DATABASE   - CC: NOT AUTHORIZED TO RECEIVE INSIGHT SCORES   - CD: INVALID PRODUCT CONFIGURATION FOR INSIGHT SCORES   - CE: ALTERNATE DATA SOURCE ERROR - MAX OF 4 ADDRESSES ALLOWED   - CF: INVALID ONLINE MATCH CONFIGURATION FOR INSIGHT SCORE   - CG: ALTERNATE DATA SRC ERROR-NO CONSUMER SRCH FIELDS PROVIDED   - CH: MISSING REQUIRED FIELDS FOR INTERNAL DATABASE SEARCH   - CJ: INTERNAL DATABASE ERROR - PLEASE TRY LATER OR CONTACT EFX   - CK: INTERNAL MDB LAYOUT ERROR   - CL: RETRY TRANSACTION TRANSIENT ERROR   - CQ: INTERNAL PROCESSING ERROR PLEASE TRY LATER OR CONTACT EFX   - CS: MODEL SERVER ERROR PLEASE TRY AGAIN LATER OR CONTACT EFX   - CT: INTERNAL CUSTOMER ID ERROR   - CZ: RETRY TRANSACTION - IF ERROR CONTINUES, CONTACT EQUIFAX    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportRejects
instance A.FromJSON ConsumerCreditReportRejects where
  parseJSON = A.withObject "ConsumerCreditReportRejects" $ \o ->
    ConsumerCreditReportRejects
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportRejects
instance A.ToJSON ConsumerCreditReportRejects where
  toJSON ConsumerCreditReportRejects {..} =
   _omitNulls
      [ "code" .= consumerCreditReportRejectsCode
      , "description" .= consumerCreditReportRejectsDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportRejects' (by applying it's required fields, if any)
mkConsumerCreditReportRejects
  :: ConsumerCreditReportRejects
mkConsumerCreditReportRejects =
  ConsumerCreditReportRejects
  { consumerCreditReportRejectsCode = Nothing
  , consumerCreditReportRejectsDescription = Nothing
  }

-- ** ConsumerCreditReportReturnCode1
-- | ConsumerCreditReportReturnCode1
-- Return code 1
data ConsumerCreditReportReturnCode1 = ConsumerCreditReportReturnCode1
  { consumerCreditReportReturnCode1Code :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportReturnCode1Description :: !(Maybe Text) -- ^ "description" - Description for the given code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportReturnCode1
instance A.FromJSON ConsumerCreditReportReturnCode1 where
  parseJSON = A.withObject "ConsumerCreditReportReturnCode1" $ \o ->
    ConsumerCreditReportReturnCode1
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportReturnCode1
instance A.ToJSON ConsumerCreditReportReturnCode1 where
  toJSON ConsumerCreditReportReturnCode1 {..} =
   _omitNulls
      [ "code" .= consumerCreditReportReturnCode1Code
      , "description" .= consumerCreditReportReturnCode1Description
      ]


-- | Construct a value of type 'ConsumerCreditReportReturnCode1' (by applying it's required fields, if any)
mkConsumerCreditReportReturnCode1
  :: ConsumerCreditReportReturnCode1
mkConsumerCreditReportReturnCode1 =
  ConsumerCreditReportReturnCode1
  { consumerCreditReportReturnCode1Code = Nothing
  , consumerCreditReportReturnCode1Description = Nothing
  }

-- ** ConsumerCreditReportReturnCode2
-- | ConsumerCreditReportReturnCode2
-- Return code 2
data ConsumerCreditReportReturnCode2 = ConsumerCreditReportReturnCode2
  { consumerCreditReportReturnCode2Code :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportReturnCode2Description :: !(Maybe Text) -- ^ "description" - Description for the given code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportReturnCode2
instance A.FromJSON ConsumerCreditReportReturnCode2 where
  parseJSON = A.withObject "ConsumerCreditReportReturnCode2" $ \o ->
    ConsumerCreditReportReturnCode2
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportReturnCode2
instance A.ToJSON ConsumerCreditReportReturnCode2 where
  toJSON ConsumerCreditReportReturnCode2 {..} =
   _omitNulls
      [ "code" .= consumerCreditReportReturnCode2Code
      , "description" .= consumerCreditReportReturnCode2Description
      ]


-- | Construct a value of type 'ConsumerCreditReportReturnCode2' (by applying it's required fields, if any)
mkConsumerCreditReportReturnCode2
  :: ConsumerCreditReportReturnCode2
mkConsumerCreditReportReturnCode2 =
  ConsumerCreditReportReturnCode2
  { consumerCreditReportReturnCode2Code = Nothing
  , consumerCreditReportReturnCode2Description = Nothing
  }

-- ** ConsumerCreditReportReturnCode3
-- | ConsumerCreditReportReturnCode3
-- Return code 3
data ConsumerCreditReportReturnCode3 = ConsumerCreditReportReturnCode3
  { consumerCreditReportReturnCode3Code :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportReturnCode3Description :: !(Maybe Text) -- ^ "description" - Description for the given code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportReturnCode3
instance A.FromJSON ConsumerCreditReportReturnCode3 where
  parseJSON = A.withObject "ConsumerCreditReportReturnCode3" $ \o ->
    ConsumerCreditReportReturnCode3
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportReturnCode3
instance A.ToJSON ConsumerCreditReportReturnCode3 where
  toJSON ConsumerCreditReportReturnCode3 {..} =
   _omitNulls
      [ "code" .= consumerCreditReportReturnCode3Code
      , "description" .= consumerCreditReportReturnCode3Description
      ]


-- | Construct a value of type 'ConsumerCreditReportReturnCode3' (by applying it's required fields, if any)
mkConsumerCreditReportReturnCode3
  :: ConsumerCreditReportReturnCode3
mkConsumerCreditReportReturnCode3 =
  ConsumerCreditReportReturnCode3
  { consumerCreditReportReturnCode3Code = Nothing
  , consumerCreditReportReturnCode3Description = Nothing
  }

-- ** ConsumerCreditReportReturnCode4
-- | ConsumerCreditReportReturnCode4
-- Return code 4
data ConsumerCreditReportReturnCode4 = ConsumerCreditReportReturnCode4
  { consumerCreditReportReturnCode4Code :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportReturnCode4Description :: !(Maybe Text) -- ^ "description" - Description for the given code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportReturnCode4
instance A.FromJSON ConsumerCreditReportReturnCode4 where
  parseJSON = A.withObject "ConsumerCreditReportReturnCode4" $ \o ->
    ConsumerCreditReportReturnCode4
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportReturnCode4
instance A.ToJSON ConsumerCreditReportReturnCode4 where
  toJSON ConsumerCreditReportReturnCode4 {..} =
   _omitNulls
      [ "code" .= consumerCreditReportReturnCode4Code
      , "description" .= consumerCreditReportReturnCode4Description
      ]


-- | Construct a value of type 'ConsumerCreditReportReturnCode4' (by applying it's required fields, if any)
mkConsumerCreditReportReturnCode4
  :: ConsumerCreditReportReturnCode4
mkConsumerCreditReportReturnCode4 =
  ConsumerCreditReportReturnCode4
  { consumerCreditReportReturnCode4Code = Nothing
  , consumerCreditReportReturnCode4Description = Nothing
  }

-- ** ConsumerCreditReportRiskBasedPricingOrModel
-- | ConsumerCreditReportRiskBasedPricingOrModel
data ConsumerCreditReportRiskBasedPricingOrModel = ConsumerCreditReportRiskBasedPricingOrModel
  { consumerCreditReportRiskBasedPricingOrModelPercentage :: !(Maybe Text) -- ^ "percentage" - Percentage of the U.S. population that the Consumers Score for this model scores
  , consumerCreditReportRiskBasedPricingOrModelLowRange :: !(Maybe Text) -- ^ "lowRange" - Dodd Frank Wall Street Lowest Score available on the model requested
  , consumerCreditReportRiskBasedPricingOrModelHighRange :: !(Maybe Text) -- ^ "highRange" - Dodd Frank Wall Street Highest Score available on the model requested
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportRiskBasedPricingOrModel
instance A.FromJSON ConsumerCreditReportRiskBasedPricingOrModel where
  parseJSON = A.withObject "ConsumerCreditReportRiskBasedPricingOrModel" $ \o ->
    ConsumerCreditReportRiskBasedPricingOrModel
      <$> (o .:? "percentage")
      <*> (o .:? "lowRange")
      <*> (o .:? "highRange")

-- | ToJSON ConsumerCreditReportRiskBasedPricingOrModel
instance A.ToJSON ConsumerCreditReportRiskBasedPricingOrModel where
  toJSON ConsumerCreditReportRiskBasedPricingOrModel {..} =
   _omitNulls
      [ "percentage" .= consumerCreditReportRiskBasedPricingOrModelPercentage
      , "lowRange" .= consumerCreditReportRiskBasedPricingOrModelLowRange
      , "highRange" .= consumerCreditReportRiskBasedPricingOrModelHighRange
      ]


-- | Construct a value of type 'ConsumerCreditReportRiskBasedPricingOrModel' (by applying it's required fields, if any)
mkConsumerCreditReportRiskBasedPricingOrModel
  :: ConsumerCreditReportRiskBasedPricingOrModel
mkConsumerCreditReportRiskBasedPricingOrModel =
  ConsumerCreditReportRiskBasedPricingOrModel
  { consumerCreditReportRiskBasedPricingOrModelPercentage = Nothing
  , consumerCreditReportRiskBasedPricingOrModelLowRange = Nothing
  , consumerCreditReportRiskBasedPricingOrModelHighRange = Nothing
  }

-- ** ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
-- | ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
data ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode = ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
  { consumerCreditReportScoreNumberOrMarketMaxIndustryCodeCode :: !(Maybe Text) -- ^ "code"
  , consumerCreditReportScoreNumberOrMarketMaxIndustryCodeDescription :: !(Maybe Text) -- ^ "description" - Either the number of model segments being returned or MarketMax 4.0 industry Code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
instance A.FromJSON ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode where
  parseJSON = A.withObject "ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode" $ \o ->
    ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
instance A.ToJSON ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode where
  toJSON ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportScoreNumberOrMarketMaxIndustryCodeCode
      , "description" .= consumerCreditReportScoreNumberOrMarketMaxIndustryCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode' (by applying it's required fields, if any)
mkConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
  :: ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
mkConsumerCreditReportScoreNumberOrMarketMaxIndustryCode =
  ConsumerCreditReportScoreNumberOrMarketMaxIndustryCode
  { consumerCreditReportScoreNumberOrMarketMaxIndustryCodeCode = Nothing
  , consumerCreditReportScoreNumberOrMarketMaxIndustryCodeDescription = Nothing
  }

-- ** ConsumerCreditReportSubjectName
-- | ConsumerCreditReportSubjectName
-- Subject's full name
data ConsumerCreditReportSubjectName = ConsumerCreditReportSubjectName
  { consumerCreditReportSubjectNameFirstName :: !(Maybe Text) -- ^ "firstName" - Subject&#39;s first name
  , consumerCreditReportSubjectNameLastName :: !(Maybe Text) -- ^ "lastName" - Subject&#39;s last name
  , consumerCreditReportSubjectNameMiddleName :: !(Maybe Text) -- ^ "middleName" - Subject&#39;s middle name
  , consumerCreditReportSubjectNameSuffix :: !(Maybe Text) -- ^ "suffix" - Subject&#39;s suffix name
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportSubjectName
instance A.FromJSON ConsumerCreditReportSubjectName where
  parseJSON = A.withObject "ConsumerCreditReportSubjectName" $ \o ->
    ConsumerCreditReportSubjectName
      <$> (o .:? "firstName")
      <*> (o .:? "lastName")
      <*> (o .:? "middleName")
      <*> (o .:? "suffix")

-- | ToJSON ConsumerCreditReportSubjectName
instance A.ToJSON ConsumerCreditReportSubjectName where
  toJSON ConsumerCreditReportSubjectName {..} =
   _omitNulls
      [ "firstName" .= consumerCreditReportSubjectNameFirstName
      , "lastName" .= consumerCreditReportSubjectNameLastName
      , "middleName" .= consumerCreditReportSubjectNameMiddleName
      , "suffix" .= consumerCreditReportSubjectNameSuffix
      ]


-- | Construct a value of type 'ConsumerCreditReportSubjectName' (by applying it's required fields, if any)
mkConsumerCreditReportSubjectName
  :: ConsumerCreditReportSubjectName
mkConsumerCreditReportSubjectName =
  ConsumerCreditReportSubjectName
  { consumerCreditReportSubjectNameFirstName = Nothing
  , consumerCreditReportSubjectNameLastName = Nothing
  , consumerCreditReportSubjectNameMiddleName = Nothing
  , consumerCreditReportSubjectNameSuffix = Nothing
  }

-- ** ConsumerCreditReportTelephoneNumberType
-- | ConsumerCreditReportTelephoneNumberType
-- Types of telephone numbers
data ConsumerCreditReportTelephoneNumberType = ConsumerCreditReportTelephoneNumberType
  { consumerCreditReportTelephoneNumberTypeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportTelephoneNumberTypeDescription :: !(Maybe Text) -- ^ "description" -  - C: Cellular - D: Daytime - E: Evening - P: Pager 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportTelephoneNumberType
instance A.FromJSON ConsumerCreditReportTelephoneNumberType where
  parseJSON = A.withObject "ConsumerCreditReportTelephoneNumberType" $ \o ->
    ConsumerCreditReportTelephoneNumberType
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportTelephoneNumberType
instance A.ToJSON ConsumerCreditReportTelephoneNumberType where
  toJSON ConsumerCreditReportTelephoneNumberType {..} =
   _omitNulls
      [ "code" .= consumerCreditReportTelephoneNumberTypeCode
      , "description" .= consumerCreditReportTelephoneNumberTypeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportTelephoneNumberType' (by applying it's required fields, if any)
mkConsumerCreditReportTelephoneNumberType
  :: ConsumerCreditReportTelephoneNumberType
mkConsumerCreditReportTelephoneNumberType =
  ConsumerCreditReportTelephoneNumberType
  { consumerCreditReportTelephoneNumberTypeCode = Nothing
  , consumerCreditReportTelephoneNumberTypeDescription = Nothing
  }

-- ** ConsumerCreditReportTelephoneNumbers
-- | ConsumerCreditReportTelephoneNumbers
-- Contact's telephone information
data ConsumerCreditReportTelephoneNumbers = ConsumerCreditReportTelephoneNumbers
  { consumerCreditReportTelephoneNumbersTelephoneNumberType :: !(Maybe ConsumerCreditReportTelephoneNumberType) -- ^ "telephoneNumberType"
  , consumerCreditReportTelephoneNumbersCountryCode :: !(Maybe Text) -- ^ "countryCode" - the telephone&#39;s country code
  , consumerCreditReportTelephoneNumbersTelephoneNumber :: !(Maybe Text) -- ^ "telephoneNumber" - Telephone number including a valid area code
  , consumerCreditReportTelephoneNumbersExtension :: !(Maybe Text) -- ^ "extension" - Telephone extension if it&#39;s present
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportTelephoneNumbers
instance A.FromJSON ConsumerCreditReportTelephoneNumbers where
  parseJSON = A.withObject "ConsumerCreditReportTelephoneNumbers" $ \o ->
    ConsumerCreditReportTelephoneNumbers
      <$> (o .:? "telephoneNumberType")
      <*> (o .:? "countryCode")
      <*> (o .:? "telephoneNumber")
      <*> (o .:? "extension")

-- | ToJSON ConsumerCreditReportTelephoneNumbers
instance A.ToJSON ConsumerCreditReportTelephoneNumbers where
  toJSON ConsumerCreditReportTelephoneNumbers {..} =
   _omitNulls
      [ "telephoneNumberType" .= consumerCreditReportTelephoneNumbersTelephoneNumberType
      , "countryCode" .= consumerCreditReportTelephoneNumbersCountryCode
      , "telephoneNumber" .= consumerCreditReportTelephoneNumbersTelephoneNumber
      , "extension" .= consumerCreditReportTelephoneNumbersExtension
      ]


-- | Construct a value of type 'ConsumerCreditReportTelephoneNumbers' (by applying it's required fields, if any)
mkConsumerCreditReportTelephoneNumbers
  :: ConsumerCreditReportTelephoneNumbers
mkConsumerCreditReportTelephoneNumbers =
  ConsumerCreditReportTelephoneNumbers
  { consumerCreditReportTelephoneNumbersTelephoneNumberType = Nothing
  , consumerCreditReportTelephoneNumbersCountryCode = Nothing
  , consumerCreditReportTelephoneNumbersTelephoneNumber = Nothing
  , consumerCreditReportTelephoneNumbersExtension = Nothing
  }

-- ** ConsumerCreditReportTypeCode
-- | ConsumerCreditReportTypeCode
-- The type of identification
data ConsumerCreditReportTypeCode = ConsumerCreditReportTypeCode
  { consumerCreditReportTypeCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportTypeCodeDescription :: !(Maybe Text) -- ^ "description" -  - C: S.I.N. - S:  SSN - T: TAX ID 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportTypeCode
instance A.FromJSON ConsumerCreditReportTypeCode where
  parseJSON = A.withObject "ConsumerCreditReportTypeCode" $ \o ->
    ConsumerCreditReportTypeCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportTypeCode
instance A.ToJSON ConsumerCreditReportTypeCode where
  toJSON ConsumerCreditReportTypeCode {..} =
   _omitNulls
      [ "code" .= consumerCreditReportTypeCodeCode
      , "description" .= consumerCreditReportTypeCodeDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportTypeCode' (by applying it's required fields, if any)
mkConsumerCreditReportTypeCode
  :: ConsumerCreditReportTypeCode
mkConsumerCreditReportTypeCode =
  ConsumerCreditReportTypeCode
  { consumerCreditReportTypeCodeCode = Nothing
  , consumerCreditReportTypeCodeDescription = Nothing
  }

-- ** ConsumerCreditReportTypeOfAddress
-- | ConsumerCreditReportTypeOfAddress
-- Type of address
data ConsumerCreditReportTypeOfAddress = ConsumerCreditReportTypeOfAddress
  { consumerCreditReportTypeOfAddressCode :: !(Maybe Text) -- ^ "code" - Code value
  , consumerCreditReportTypeOfAddressDescription :: !(Maybe Text) -- ^ "description" - Description for the given code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConsumerCreditReportTypeOfAddress
instance A.FromJSON ConsumerCreditReportTypeOfAddress where
  parseJSON = A.withObject "ConsumerCreditReportTypeOfAddress" $ \o ->
    ConsumerCreditReportTypeOfAddress
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ConsumerCreditReportTypeOfAddress
instance A.ToJSON ConsumerCreditReportTypeOfAddress where
  toJSON ConsumerCreditReportTypeOfAddress {..} =
   _omitNulls
      [ "code" .= consumerCreditReportTypeOfAddressCode
      , "description" .= consumerCreditReportTypeOfAddressDescription
      ]


-- | Construct a value of type 'ConsumerCreditReportTypeOfAddress' (by applying it's required fields, if any)
mkConsumerCreditReportTypeOfAddress
  :: ConsumerCreditReportTypeOfAddress
mkConsumerCreditReportTypeOfAddress =
  ConsumerCreditReportTypeOfAddress
  { consumerCreditReportTypeOfAddressCode = Nothing
  , consumerCreditReportTypeOfAddressDescription = Nothing
  }

-- ** CreditReportRequest
-- | CreditReportRequest
data CreditReportRequest = CreditReportRequest
  { creditReportRequestConsumers :: !(CreditReportRequestConsumers) -- ^ /Required/ "consumers"
  , creditReportRequestExternalDataSources :: !(Maybe CreditReportRequestExternalDataSources) -- ^ "externalDataSources"
  , creditReportRequestCustomerReferenceIdentifier :: !(Maybe Text) -- ^ "customerReferenceIdentifier" - Unique identifier provided by customer
  , creditReportRequestCustomerConfiguration :: !(CreditReportRequestCustomerConfiguration) -- ^ /Required/ "customerConfiguration"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequest
instance A.FromJSON CreditReportRequest where
  parseJSON = A.withObject "CreditReportRequest" $ \o ->
    CreditReportRequest
      <$> (o .:  "consumers")
      <*> (o .:? "externalDataSources")
      <*> (o .:? "customerReferenceIdentifier")
      <*> (o .:  "customerConfiguration")

-- | ToJSON CreditReportRequest
instance A.ToJSON CreditReportRequest where
  toJSON CreditReportRequest {..} =
   _omitNulls
      [ "consumers" .= creditReportRequestConsumers
      , "externalDataSources" .= creditReportRequestExternalDataSources
      , "customerReferenceIdentifier" .= creditReportRequestCustomerReferenceIdentifier
      , "customerConfiguration" .= creditReportRequestCustomerConfiguration
      ]


-- | Construct a value of type 'CreditReportRequest' (by applying it's required fields, if any)
mkCreditReportRequest
  :: CreditReportRequestConsumers -- ^ 'creditReportRequestConsumers' 
  -> CreditReportRequestCustomerConfiguration -- ^ 'creditReportRequestCustomerConfiguration' 
  -> CreditReportRequest
mkCreditReportRequest creditReportRequestConsumers creditReportRequestCustomerConfiguration =
  CreditReportRequest
  { creditReportRequestConsumers
  , creditReportRequestExternalDataSources = Nothing
  , creditReportRequestCustomerReferenceIdentifier = Nothing
  , creditReportRequestCustomerConfiguration
  }

-- ** CreditReportRequestConsumers
-- | CreditReportRequestConsumers
data CreditReportRequestConsumers = CreditReportRequestConsumers
  { creditReportRequestConsumersName :: !([CreditReportRequestConsumersName]) -- ^ /Required/ "name" - Consumer name
  , creditReportRequestConsumersSocialNum :: !(Maybe [CreditReportRequestConsumersSocialNum]) -- ^ "socialNum" - Social Security Number
  , creditReportRequestConsumersDateOfBirth :: !(Maybe Date) -- ^ "dateOfBirth" - Date of Birth
  , creditReportRequestConsumersAge :: !(Maybe Text) -- ^ "age" - Age
  , creditReportRequestConsumersAddresses :: !(Maybe [AddressRequest]) -- ^ "addresses" - Address information. A maximum of 2 addresses can be sent per inquiry. If socialNum is not provided, the houseNumber, streetName, city and state are required
  , creditReportRequestConsumersPhoneNumbers :: !(Maybe [CreditReportRequestConsumersPhoneNumbers]) -- ^ "phoneNumbers"
  , creditReportRequestConsumersEmployments :: !(Maybe CreditReportRequestConsumersEmployments) -- ^ "employments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumers
instance A.FromJSON CreditReportRequestConsumers where
  parseJSON = A.withObject "CreditReportRequestConsumers" $ \o ->
    CreditReportRequestConsumers
      <$> (o .:  "name")
      <*> (o .:? "socialNum")
      <*> (o .:? "dateOfBirth")
      <*> (o .:? "age")
      <*> (o .:? "addresses")
      <*> (o .:? "phoneNumbers")
      <*> (o .:? "employments")

-- | ToJSON CreditReportRequestConsumers
instance A.ToJSON CreditReportRequestConsumers where
  toJSON CreditReportRequestConsumers {..} =
   _omitNulls
      [ "name" .= creditReportRequestConsumersName
      , "socialNum" .= creditReportRequestConsumersSocialNum
      , "dateOfBirth" .= creditReportRequestConsumersDateOfBirth
      , "age" .= creditReportRequestConsumersAge
      , "addresses" .= creditReportRequestConsumersAddresses
      , "phoneNumbers" .= creditReportRequestConsumersPhoneNumbers
      , "employments" .= creditReportRequestConsumersEmployments
      ]


-- | Construct a value of type 'CreditReportRequestConsumers' (by applying it's required fields, if any)
mkCreditReportRequestConsumers
  :: [CreditReportRequestConsumersName] -- ^ 'creditReportRequestConsumersName': Consumer name
  -> CreditReportRequestConsumers
mkCreditReportRequestConsumers creditReportRequestConsumersName =
  CreditReportRequestConsumers
  { creditReportRequestConsumersName
  , creditReportRequestConsumersSocialNum = Nothing
  , creditReportRequestConsumersDateOfBirth = Nothing
  , creditReportRequestConsumersAge = Nothing
  , creditReportRequestConsumersAddresses = Nothing
  , creditReportRequestConsumersPhoneNumbers = Nothing
  , creditReportRequestConsumersEmployments = Nothing
  }

-- ** CreditReportRequestConsumersEmployments
-- | CreditReportRequestConsumersEmployments
data CreditReportRequestConsumersEmployments = CreditReportRequestConsumersEmployments
  { creditReportRequestConsumersEmploymentsOccupation :: !(Maybe Text) -- ^ "occupation" - Occupation
  , creditReportRequestConsumersEmploymentsEmployerName :: !(Maybe Text) -- ^ "employerName" - Employer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersEmployments
instance A.FromJSON CreditReportRequestConsumersEmployments where
  parseJSON = A.withObject "CreditReportRequestConsumersEmployments" $ \o ->
    CreditReportRequestConsumersEmployments
      <$> (o .:? "occupation")
      <*> (o .:? "employerName")

-- | ToJSON CreditReportRequestConsumersEmployments
instance A.ToJSON CreditReportRequestConsumersEmployments where
  toJSON CreditReportRequestConsumersEmployments {..} =
   _omitNulls
      [ "occupation" .= creditReportRequestConsumersEmploymentsOccupation
      , "employerName" .= creditReportRequestConsumersEmploymentsEmployerName
      ]


-- | Construct a value of type 'CreditReportRequestConsumersEmployments' (by applying it's required fields, if any)
mkCreditReportRequestConsumersEmployments
  :: CreditReportRequestConsumersEmployments
mkCreditReportRequestConsumersEmployments =
  CreditReportRequestConsumersEmployments
  { creditReportRequestConsumersEmploymentsOccupation = Nothing
  , creditReportRequestConsumersEmploymentsEmployerName = Nothing
  }

-- ** CreditReportRequestConsumersName
-- | CreditReportRequestConsumersName
data CreditReportRequestConsumersName = CreditReportRequestConsumersName
  { creditReportRequestConsumersNameIdentifier :: !(Text) -- ^ /Required/ "identifier" - Record identifier
  , creditReportRequestConsumersNameFirstName :: !(Text) -- ^ /Required/ "firstName" - First name
  , creditReportRequestConsumersNameLastName :: !(Text) -- ^ /Required/ "lastName" - Last name
  , creditReportRequestConsumersNameMiddleName :: !(Maybe Text) -- ^ "middleName" - Middle name or initial
  , creditReportRequestConsumersNameSuffix :: !(Maybe Text) -- ^ "suffix" - Suffix
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersName
instance A.FromJSON CreditReportRequestConsumersName where
  parseJSON = A.withObject "CreditReportRequestConsumersName" $ \o ->
    CreditReportRequestConsumersName
      <$> (o .:  "identifier")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:? "middleName")
      <*> (o .:? "suffix")

-- | ToJSON CreditReportRequestConsumersName
instance A.ToJSON CreditReportRequestConsumersName where
  toJSON CreditReportRequestConsumersName {..} =
   _omitNulls
      [ "identifier" .= creditReportRequestConsumersNameIdentifier
      , "firstName" .= creditReportRequestConsumersNameFirstName
      , "lastName" .= creditReportRequestConsumersNameLastName
      , "middleName" .= creditReportRequestConsumersNameMiddleName
      , "suffix" .= creditReportRequestConsumersNameSuffix
      ]


-- | Construct a value of type 'CreditReportRequestConsumersName' (by applying it's required fields, if any)
mkCreditReportRequestConsumersName
  :: Text -- ^ 'creditReportRequestConsumersNameIdentifier': Record identifier
  -> Text -- ^ 'creditReportRequestConsumersNameFirstName': First name
  -> Text -- ^ 'creditReportRequestConsumersNameLastName': Last name
  -> CreditReportRequestConsumersName
mkCreditReportRequestConsumersName creditReportRequestConsumersNameIdentifier creditReportRequestConsumersNameFirstName creditReportRequestConsumersNameLastName =
  CreditReportRequestConsumersName
  { creditReportRequestConsumersNameIdentifier
  , creditReportRequestConsumersNameFirstName
  , creditReportRequestConsumersNameLastName
  , creditReportRequestConsumersNameMiddleName = Nothing
  , creditReportRequestConsumersNameSuffix = Nothing
  }

-- ** CreditReportRequestConsumersPhoneNumbers
-- | CreditReportRequestConsumersPhoneNumbers
data CreditReportRequestConsumersPhoneNumbers = CreditReportRequestConsumersPhoneNumbers
  { creditReportRequestConsumersPhoneNumbersIdentifier :: !(Text) -- ^ /Required/ "identifier"
  , creditReportRequestConsumersPhoneNumbersNumber :: !(Text) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersPhoneNumbers
instance A.FromJSON CreditReportRequestConsumersPhoneNumbers where
  parseJSON = A.withObject "CreditReportRequestConsumersPhoneNumbers" $ \o ->
    CreditReportRequestConsumersPhoneNumbers
      <$> (o .:  "identifier")
      <*> (o .:  "number")

-- | ToJSON CreditReportRequestConsumersPhoneNumbers
instance A.ToJSON CreditReportRequestConsumersPhoneNumbers where
  toJSON CreditReportRequestConsumersPhoneNumbers {..} =
   _omitNulls
      [ "identifier" .= creditReportRequestConsumersPhoneNumbersIdentifier
      , "number" .= creditReportRequestConsumersPhoneNumbersNumber
      ]


-- | Construct a value of type 'CreditReportRequestConsumersPhoneNumbers' (by applying it's required fields, if any)
mkCreditReportRequestConsumersPhoneNumbers
  :: Text -- ^ 'creditReportRequestConsumersPhoneNumbersIdentifier' 
  -> Text -- ^ 'creditReportRequestConsumersPhoneNumbersNumber' 
  -> CreditReportRequestConsumersPhoneNumbers
mkCreditReportRequestConsumersPhoneNumbers creditReportRequestConsumersPhoneNumbersIdentifier creditReportRequestConsumersPhoneNumbersNumber =
  CreditReportRequestConsumersPhoneNumbers
  { creditReportRequestConsumersPhoneNumbersIdentifier
  , creditReportRequestConsumersPhoneNumbersNumber
  }

-- ** CreditReportRequestConsumersSocialNum
-- | CreditReportRequestConsumersSocialNum
data CreditReportRequestConsumersSocialNum = CreditReportRequestConsumersSocialNum
  { creditReportRequestConsumersSocialNumIdentifier :: !(Text) -- ^ /Required/ "identifier" - Record identifier
  , creditReportRequestConsumersSocialNumNumber :: !(Text) -- ^ /Required/ "number" - Social Security Number (SSN)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersSocialNum
instance A.FromJSON CreditReportRequestConsumersSocialNum where
  parseJSON = A.withObject "CreditReportRequestConsumersSocialNum" $ \o ->
    CreditReportRequestConsumersSocialNum
      <$> (o .:  "identifier")
      <*> (o .:  "number")

-- | ToJSON CreditReportRequestConsumersSocialNum
instance A.ToJSON CreditReportRequestConsumersSocialNum where
  toJSON CreditReportRequestConsumersSocialNum {..} =
   _omitNulls
      [ "identifier" .= creditReportRequestConsumersSocialNumIdentifier
      , "number" .= creditReportRequestConsumersSocialNumNumber
      ]


-- | Construct a value of type 'CreditReportRequestConsumersSocialNum' (by applying it's required fields, if any)
mkCreditReportRequestConsumersSocialNum
  :: Text -- ^ 'creditReportRequestConsumersSocialNumIdentifier': Record identifier
  -> Text -- ^ 'creditReportRequestConsumersSocialNumNumber': Social Security Number (SSN)
  -> CreditReportRequestConsumersSocialNum
mkCreditReportRequestConsumersSocialNum creditReportRequestConsumersSocialNumIdentifier creditReportRequestConsumersSocialNumNumber =
  CreditReportRequestConsumersSocialNum
  { creditReportRequestConsumersSocialNumIdentifier
  , creditReportRequestConsumersSocialNumNumber
  }

-- ** CreditReportRequestCustomerConfiguration
-- | CreditReportRequestCustomerConfiguration
-- Configurations related to the credit report being requested
data CreditReportRequestCustomerConfiguration = CreditReportRequestCustomerConfiguration
  { creditReportRequestCustomerConfigurationEquifaxUsConsumerCreditReport :: !(Maybe EquifaxUSConsumerCreditRequest) -- ^ "equifaxUSConsumerCreditReport"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestCustomerConfiguration
instance A.FromJSON CreditReportRequestCustomerConfiguration where
  parseJSON = A.withObject "CreditReportRequestCustomerConfiguration" $ \o ->
    CreditReportRequestCustomerConfiguration
      <$> (o .:? "equifaxUSConsumerCreditReport")

-- | ToJSON CreditReportRequestCustomerConfiguration
instance A.ToJSON CreditReportRequestCustomerConfiguration where
  toJSON CreditReportRequestCustomerConfiguration {..} =
   _omitNulls
      [ "equifaxUSConsumerCreditReport" .= creditReportRequestCustomerConfigurationEquifaxUsConsumerCreditReport
      ]


-- | Construct a value of type 'CreditReportRequestCustomerConfiguration' (by applying it's required fields, if any)
mkCreditReportRequestCustomerConfiguration
  :: CreditReportRequestCustomerConfiguration
mkCreditReportRequestCustomerConfiguration =
  CreditReportRequestCustomerConfiguration
  { creditReportRequestCustomerConfigurationEquifaxUsConsumerCreditReport = Nothing
  }

-- ** CreditReportRequestExternalDataSources
-- | CreditReportRequestExternalDataSources
data CreditReportRequestExternalDataSources = CreditReportRequestExternalDataSources
  { creditReportRequestExternalDataSourcesAlternateDataSources :: !(Maybe CreditReportRequestExternalDataSourcesAlternateDataSources) -- ^ "alternateDataSources"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestExternalDataSources
instance A.FromJSON CreditReportRequestExternalDataSources where
  parseJSON = A.withObject "CreditReportRequestExternalDataSources" $ \o ->
    CreditReportRequestExternalDataSources
      <$> (o .:? "alternateDataSources")

-- | ToJSON CreditReportRequestExternalDataSources
instance A.ToJSON CreditReportRequestExternalDataSources where
  toJSON CreditReportRequestExternalDataSources {..} =
   _omitNulls
      [ "alternateDataSources" .= creditReportRequestExternalDataSourcesAlternateDataSources
      ]


-- | Construct a value of type 'CreditReportRequestExternalDataSources' (by applying it's required fields, if any)
mkCreditReportRequestExternalDataSources
  :: CreditReportRequestExternalDataSources
mkCreditReportRequestExternalDataSources =
  CreditReportRequestExternalDataSources
  { creditReportRequestExternalDataSourcesAlternateDataSources = Nothing
  }

-- ** CreditReportRequestExternalDataSourcesAlternateDataSources
-- | CreditReportRequestExternalDataSourcesAlternateDataSources
data CreditReportRequestExternalDataSourcesAlternateDataSources = CreditReportRequestExternalDataSourcesAlternateDataSources
  { creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator :: !(Bool) -- ^ /Required/ "consumerReportIndicator"
  , creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrchestrationCode :: !(Maybe Text) -- ^ "customerOrchestrationCode"
  , creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrganizationCode :: !(Maybe Text) -- ^ "customerOrganizationCode"
  , creditReportRequestExternalDataSourcesAlternateDataSourcesDataProviderTag :: !(Maybe Text) -- ^ "dataProviderTag"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestExternalDataSourcesAlternateDataSources
instance A.FromJSON CreditReportRequestExternalDataSourcesAlternateDataSources where
  parseJSON = A.withObject "CreditReportRequestExternalDataSourcesAlternateDataSources" $ \o ->
    CreditReportRequestExternalDataSourcesAlternateDataSources
      <$> (o .:  "consumerReportIndicator")
      <*> (o .:? "customerOrchestrationCode")
      <*> (o .:? "customerOrganizationCode")
      <*> (o .:? "dataProviderTag")

-- | ToJSON CreditReportRequestExternalDataSourcesAlternateDataSources
instance A.ToJSON CreditReportRequestExternalDataSourcesAlternateDataSources where
  toJSON CreditReportRequestExternalDataSourcesAlternateDataSources {..} =
   _omitNulls
      [ "consumerReportIndicator" .= creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator
      , "customerOrchestrationCode" .= creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrchestrationCode
      , "customerOrganizationCode" .= creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrganizationCode
      , "dataProviderTag" .= creditReportRequestExternalDataSourcesAlternateDataSourcesDataProviderTag
      ]


-- | Construct a value of type 'CreditReportRequestExternalDataSourcesAlternateDataSources' (by applying it's required fields, if any)
mkCreditReportRequestExternalDataSourcesAlternateDataSources
  :: Bool -- ^ 'creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator' 
  -> CreditReportRequestExternalDataSourcesAlternateDataSources
mkCreditReportRequestExternalDataSourcesAlternateDataSources creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator =
  CreditReportRequestExternalDataSourcesAlternateDataSources
  { creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator
  , creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrchestrationCode = Nothing
  , creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrganizationCode = Nothing
  , creditReportRequestExternalDataSourcesAlternateDataSourcesDataProviderTag = Nothing
  }

-- ** CreditReportResponse
-- | CreditReportResponse
data CreditReportResponse = CreditReportResponse
  { creditReportResponseStatus :: !(Maybe Text) -- ^ "status" - Transaction status. It could include some comments related to the transaction
  , creditReportResponseConsumers :: !(Maybe ConsumerCreditReport) -- ^ "consumers"
  , creditReportResponseLinks :: !(Maybe [CreditReportResponseLinks]) -- ^ "links" - Returned when pdfCombo Indicator is set to &#39;Y&#39; or &#39;S&#39;. A separate link is returned for each credit report generated for the requested applicant(s). When multiple reports option is set to &#39;F&#39;, a maximum of 4 reports may be returned for each applicant.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportResponse
instance A.FromJSON CreditReportResponse where
  parseJSON = A.withObject "CreditReportResponse" $ \o ->
    CreditReportResponse
      <$> (o .:? "status")
      <*> (o .:? "consumers")
      <*> (o .:? "links")

-- | ToJSON CreditReportResponse
instance A.ToJSON CreditReportResponse where
  toJSON CreditReportResponse {..} =
   _omitNulls
      [ "status" .= creditReportResponseStatus
      , "consumers" .= creditReportResponseConsumers
      , "links" .= creditReportResponseLinks
      ]


-- | Construct a value of type 'CreditReportResponse' (by applying it's required fields, if any)
mkCreditReportResponse
  :: CreditReportResponse
mkCreditReportResponse =
  CreditReportResponse
  { creditReportResponseStatus = Nothing
  , creditReportResponseConsumers = Nothing
  , creditReportResponseLinks = Nothing
  }

-- ** CreditReportResponseLinks
-- | CreditReportResponseLinks
data CreditReportResponseLinks = CreditReportResponseLinks
  { creditReportResponseLinksIdentifier :: !(Maybe Text) -- ^ "identifier" - identifies the credit report contained in the PDF. Corresponds to the JSON response equifaxUSConsumerCreditReport.identifier.
  , creditReportResponseLinksType :: !(Maybe Text) -- ^ "type" - REST method to retrieve PDF
  , creditReportResponseLinksHref :: !(Maybe Text) -- ^ "href" - Link to retrieve PDF for report named in identifier
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportResponseLinks
instance A.FromJSON CreditReportResponseLinks where
  parseJSON = A.withObject "CreditReportResponseLinks" $ \o ->
    CreditReportResponseLinks
      <$> (o .:? "identifier")
      <*> (o .:? "type")
      <*> (o .:? "href")

-- | ToJSON CreditReportResponseLinks
instance A.ToJSON CreditReportResponseLinks where
  toJSON CreditReportResponseLinks {..} =
   _omitNulls
      [ "identifier" .= creditReportResponseLinksIdentifier
      , "type" .= creditReportResponseLinksType
      , "href" .= creditReportResponseLinksHref
      ]


-- | Construct a value of type 'CreditReportResponseLinks' (by applying it's required fields, if any)
mkCreditReportResponseLinks
  :: CreditReportResponseLinks
mkCreditReportResponseLinks =
  CreditReportResponseLinks
  { creditReportResponseLinksIdentifier = Nothing
  , creditReportResponseLinksType = Nothing
  , creditReportResponseLinksHref = Nothing
  }

-- ** CreditorClassificationCode
-- | CreditorClassificationCode
-- A general type of business for the original creditor and is only applicable for trades reported by Debt Buyers 
data CreditorClassificationCode = CreditorClassificationCode
  { creditorClassificationCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , creditorClassificationCodeDescription :: !(Maybe Text) -- ^ "description" - Business type of original creditor   - 01: RETAIL   - 02: MEDICAL/HEALTH CARE   - 03: OIL COMPANY   - 04: GOVERNMENT   - 05: PERSONAL SERVICES   - 06: INSURANCE   - 07: EDUCATIONAL   - 08: BANKING   - 09: RENTAL/LEASING   - 10: UTILITIES   - 11: CABLE/CELLULAR   - 12: FINANCIAL   - 13: CREDIT UNION   - 14: AUTOMOTIVE   - 15: CHECK GUARANTEE    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditorClassificationCode
instance A.FromJSON CreditorClassificationCode where
  parseJSON = A.withObject "CreditorClassificationCode" $ \o ->
    CreditorClassificationCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON CreditorClassificationCode
instance A.ToJSON CreditorClassificationCode where
  toJSON CreditorClassificationCode {..} =
   _omitNulls
      [ "code" .= creditorClassificationCodeCode
      , "description" .= creditorClassificationCodeDescription
      ]


-- | Construct a value of type 'CreditorClassificationCode' (by applying it's required fields, if any)
mkCreditorClassificationCode
  :: CreditorClassificationCode
mkCreditorClassificationCode =
  CreditorClassificationCode
  { creditorClassificationCodeCode = Nothing
  , creditorClassificationCodeDescription = Nothing
  }

-- ** EquifaxUSConsumerCreditRequest
-- | EquifaxUSConsumerCreditRequest
-- Configuration related to the customer request
data EquifaxUSConsumerCreditRequest = EquifaxUSConsumerCreditRequest
  { equifaxUSConsumerCreditRequestMemberNumber :: !(Text) -- ^ /Required/ "memberNumber" - This is your Equifax Customer Number. This number is used to both access and invoice for Equifax data, products and services. Please contact your Equifax Sales Associate for additional information and activation. 
  , equifaxUSConsumerCreditRequestSecurityCode :: !(Text) -- ^ /Required/ "securityCode" - Security code
  , equifaxUSConsumerCreditRequestCodeDescriptionRequired :: !(Maybe Bool) -- ^ "codeDescriptionRequired" - Request code descriptions
  , equifaxUSConsumerCreditRequestEndUserInformation :: !(Maybe EquifaxUSConsumerCreditRequestEndUserInformation) -- ^ "endUserInformation"
  , equifaxUSConsumerCreditRequestProductCodes :: !(Maybe [Text]) -- ^ "productCodes" - Codes related to the optional Equifax products \\: Please contact your Equifax Sales Associate for additional information and activation of the desired optional services. Product code values include:   - 01: Equifax Fraud Advisor 2.0 and up to 4 warning codes with Consumer report   - N1: Equifax Fraud Advisor 2.0 and up to 4 warning codes without Consumer report   - 03: Equifax ID Advisor Plus Raw Data returned with Consumer report   - N3: Equifax ID Advisor Plus Raw Data returned without Consumer report   - 08: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on high \\# risk group only (scores of 1-5) with Consumer report   - N8: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on high \\# risk group only (1-5) without Consumer report   - 10: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on all \\# risk groups (scores of 1-9) with Consumer report   - NA: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on all \\# risk groups (scores of 1-9) without Consumer report   - MM: MarketMax with a Consumer Report   - NZ: MarketMax without a Consumer Report   - 31: ID Score® - Risk with Consumer report   - 32: ID Score® - Risk without Consumer report 
  , equifaxUSConsumerCreditRequestProductInformation :: !(Maybe EquifaxUSConsumerCreditRequestProductInformation) -- ^ "productInformation"
  , equifaxUSConsumerCreditRequestModels :: !(Maybe [EquifaxUSConsumerCreditRequestModels]) -- ^ "models" - Model Score
  , equifaxUSConsumerCreditRequestCustomerCode :: !(Maybe Text) -- ^ "customerCode" - Assigned customer code
  , equifaxUSConsumerCreditRequestMultipleReportIndicator :: !(Maybe Text) -- ^ "multipleReportIndicator" - Indicates if the report allows more than 1 credit report   - 1: one report   - F: multiple reports (Puerto Rico only) 
  , equifaxUSConsumerCreditRequestEcoaInquiryType :: !(Maybe Text) -- ^ "ECOAInquiryType" - Type of inquiry
  , equifaxUSConsumerCreditRequestOptionalFeatureCode :: !(Maybe [Text]) -- ^ "optionalFeatureCode" - The optional features requested in the credit report. Please contact your Equifax Sales Associate for additional information and activation Optional feature code:   - B: Military Lending Act with Credit Data   - D: ON-LINE DIRECTORY or ON-LINE DIRECTORY w/Address   - G: Dimensions Data   - M: Return Risk-Based Pricing score information in the FICO and Model Segments   - Q: Return Risk-Based Pricing score information in the FICO segment only   - O: Equifax Model(s) that are set up as Default or Multiple returned   - V: Enhanced Delinquency Alert System (EDAS) &amp; FICO Score based on Equifax Data   - X: FICO Score based on Equifax Data   - Z: Enhanced Delinquency Alert System (EDAS)   - &amp;: FraudIQ Synthetic ID Alerts 
  , equifaxUSConsumerCreditRequestPdfComboIndicator :: !(Maybe Text) -- ^ "pdfComboIndicator" - Optional indicator to request a PDF version of the report. PDF may be retrieved using the resulting links for up to 2 hours after the initial request is made. If ECOAInquiryType is &#39;Co-applicant&#39;, a separate link is returned for each applicant.     - N: No PDF link is returned in the response (default behavior when indicator not present)     - Y: PDF Link(s) are included with the JSON credit report response.      - S: Standalone PDF, only the PDF links are returned in the JSON response.  
  , equifaxUSConsumerCreditRequestVendorIdentificationCode :: !(Maybe Text) -- ^ "vendorIdentificationCode" - Required for all third-party channel partners and vendors who support end-customer access to Equifax products and services
  , equifaxUSConsumerCreditRequestRiskModelCodeOnly :: !(Maybe Text) -- ^ "riskModelCodeOnly" - It can be one of the following indicators:     Pre-screen of One model request  - ^: For a single prescreen model          - %: For multiple prescreen models  In-Person rules require that 3 or more items in the request match to a consumer&#39;s file to be considered a hit/match.  - P: In Person rules apply based on the state code in the request          - Q: In Person rules apply based on the state code in the Current Address on the file  Mortgage Reissue   - M: if Mortgage Reissue is requested this indicator is required. Used by the mortgage industry when a consumer’s credit report is reissued to another company for additional services.  
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequest
instance A.FromJSON EquifaxUSConsumerCreditRequest where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequest" $ \o ->
    EquifaxUSConsumerCreditRequest
      <$> (o .:  "memberNumber")
      <*> (o .:  "securityCode")
      <*> (o .:? "codeDescriptionRequired")
      <*> (o .:? "endUserInformation")
      <*> (o .:? "productCodes")
      <*> (o .:? "productInformation")
      <*> (o .:? "models")
      <*> (o .:? "customerCode")
      <*> (o .:? "multipleReportIndicator")
      <*> (o .:? "ECOAInquiryType")
      <*> (o .:? "optionalFeatureCode")
      <*> (o .:? "pdfComboIndicator")
      <*> (o .:? "vendorIdentificationCode")
      <*> (o .:? "riskModelCodeOnly")

-- | ToJSON EquifaxUSConsumerCreditRequest
instance A.ToJSON EquifaxUSConsumerCreditRequest where
  toJSON EquifaxUSConsumerCreditRequest {..} =
   _omitNulls
      [ "memberNumber" .= equifaxUSConsumerCreditRequestMemberNumber
      , "securityCode" .= equifaxUSConsumerCreditRequestSecurityCode
      , "codeDescriptionRequired" .= equifaxUSConsumerCreditRequestCodeDescriptionRequired
      , "endUserInformation" .= equifaxUSConsumerCreditRequestEndUserInformation
      , "productCodes" .= equifaxUSConsumerCreditRequestProductCodes
      , "productInformation" .= equifaxUSConsumerCreditRequestProductInformation
      , "models" .= equifaxUSConsumerCreditRequestModels
      , "customerCode" .= equifaxUSConsumerCreditRequestCustomerCode
      , "multipleReportIndicator" .= equifaxUSConsumerCreditRequestMultipleReportIndicator
      , "ECOAInquiryType" .= equifaxUSConsumerCreditRequestEcoaInquiryType
      , "optionalFeatureCode" .= equifaxUSConsumerCreditRequestOptionalFeatureCode
      , "pdfComboIndicator" .= equifaxUSConsumerCreditRequestPdfComboIndicator
      , "vendorIdentificationCode" .= equifaxUSConsumerCreditRequestVendorIdentificationCode
      , "riskModelCodeOnly" .= equifaxUSConsumerCreditRequestRiskModelCodeOnly
      ]


-- | Construct a value of type 'EquifaxUSConsumerCreditRequest' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequest
  :: Text -- ^ 'equifaxUSConsumerCreditRequestMemberNumber': This is your Equifax Customer Number. This number is used to both access and invoice for Equifax data, products and services. Please contact your Equifax Sales Associate for additional information and activation. 
  -> Text -- ^ 'equifaxUSConsumerCreditRequestSecurityCode': Security code
  -> EquifaxUSConsumerCreditRequest
mkEquifaxUSConsumerCreditRequest equifaxUSConsumerCreditRequestMemberNumber equifaxUSConsumerCreditRequestSecurityCode =
  EquifaxUSConsumerCreditRequest
  { equifaxUSConsumerCreditRequestMemberNumber
  , equifaxUSConsumerCreditRequestSecurityCode
  , equifaxUSConsumerCreditRequestCodeDescriptionRequired = Nothing
  , equifaxUSConsumerCreditRequestEndUserInformation = Nothing
  , equifaxUSConsumerCreditRequestProductCodes = Nothing
  , equifaxUSConsumerCreditRequestProductInformation = Nothing
  , equifaxUSConsumerCreditRequestModels = Nothing
  , equifaxUSConsumerCreditRequestCustomerCode = Nothing
  , equifaxUSConsumerCreditRequestMultipleReportIndicator = Nothing
  , equifaxUSConsumerCreditRequestEcoaInquiryType = Nothing
  , equifaxUSConsumerCreditRequestOptionalFeatureCode = Nothing
  , equifaxUSConsumerCreditRequestPdfComboIndicator = Nothing
  , equifaxUSConsumerCreditRequestVendorIdentificationCode = Nothing
  , equifaxUSConsumerCreditRequestRiskModelCodeOnly = Nothing
  }

-- ** EquifaxUSConsumerCreditRequestEndUserInformation
-- | EquifaxUSConsumerCreditRequestEndUserInformation
-- Customers using an \"IG\", \"IL\", \"IZ\" or \"RT\" Industry Code are only required to send the appropriate Permissible Purpose Code. Customers using a \"ZB\" or \"ZT\" Industry Code must include both the \"End Users Name\" and the applicable Permissible Purpose code. 
data EquifaxUSConsumerCreditRequestEndUserInformation = EquifaxUSConsumerCreditRequestEndUserInformation
  { equifaxUSConsumerCreditRequestEndUserInformationEndUsersName :: !(Text) -- ^ /Required/ "endUsersName" - Company name of the final recipient of the consumer report making the request
  , equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode :: !(Text) -- ^ /Required/ "permissiblePurposeCode" - Code to audit the purposes for which Equifax consumer information is furnished thus providing continued compliance with the FCRA   - 01: Intends to use the information as a potential investor servicer or current insurer in connection with a valuation of or assessment of the credit or prepayment risks.   - 03: In accordance with written instructions of the consumer to whom it relates.   - 04: In connection with a collection transaction involving a credit account of the consumer.   - 05: In response to an agency administering a state plan under Section 454 of the Social Security Act (42 U.S.C. 654) for use to set an initial or modified child support award.   - 06: In accordance with written instructions of the consumer through a reseller.   - 07: In response to a request by the head of a state or local child support enforcement agency (or a state or local government official authorized by the head of such an agency) that has met all requirements of Section 604(a)(4)(ABCD).   - 08: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer. For use only when the transaction cannot be described with a more specific code.   - 09: For employment purposes (Only PERSONA is available with this code)   - 10: In connection with a determination of eligibility for a license or other benefit granted by a governmental instrument required by law to consider financial responsibility or status.   - 11: In connection with the underwriting of insurance.   - 12: In connection with the review of existing policy holders for insurance underwriting purposes.   - 13: A legitimate business need to review an account to determine whether the consumer continues to meet the terms of the account.   - 14: In response to the order of a court having jurisdiction or a subpoena issued by a federal grand jury.   - 15: In connection with a tenant screen application involving the consumer.   - 16: For use by a governmental agency pursuant to FCRA Section 608.   - 17: To protect against or prevent actual or potential fraud unauthorized transactions claims or other liability.   - 18: For required institutional risk control or for resolving consumer disputes or inquiries.   - 19: Due to holding a legal or beneficial interest relating to the consumer.   - 20: To law enforcement agencies or for an investigation on a matter related to public safety.   - 21: As necessary to effect administer or enforce a transaction; to underwrite insurance at the consumer’s request for reinsurance purposes or for the following purposes related to the consumer’s insurance;  account administration reporting investigating fraud prevention premium payment processing claim processing benefit administration or research projects.   - 22: To persons acting in a fiduciary or representative capacity on behalf of and with the consent of the consumer.   - 23: As necessary to effect administer or enforce a transaction requested or authorized by the consumer including location for collection of a delinquent account.   - 24: In conjunction with access to a commercial file on a sole proprietorship.   - 25: In conjunction with access to a commercial file on a corporation where specific consumer consent is given.   - 26: In connection with a credit transaction involving the extension of credit to or review or collection of an account of the consumer where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use of which the medical information will be furnished.   - 27: For employment purposes where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use for which the medical information will be furnished.    - 28: In connection with the underwriting of insurance. Specific consumer consent was given for the release of medical information contained within the consumer report.   - 29: In connection with a transaction where the credit file including any medical information in it is only to be provided directly to the individual consumer to whom the information relates and specific consumer consent was received for the receipt and furnishing of the consumer report including medical information to the consumer.   - 51: In accordance with written instructions of the consumer providing consent for use related to bankruptcy filing purposes.   - 52: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to an automobile or truck.   - 53: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive repair.   - 54: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive parts tires etc.   - 55: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a boat or recreational vehicle.   - 56: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to farm equipment.   - 57: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan origination.   - 58: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan refinancing.   - 59: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a home equity loan line of credit.   - 60: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a personal loan.   - 61: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a credit card.   - 62: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home furnishings.   - 63: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to general contracting / home improvement.   - 64: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to air conditioning / heating / plumbing or electrical.   - 65: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to lumber / building materials / hardware.   - 66: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to hospitalization / medical care / dental care.   - 67: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to personal services.   - 68: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home heating oil / fuel.   - 69: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to telephone / electrical / gas / water utilities or household garbage removal.   - 70: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to wholesale goods.   - 71: For the purpose of providing a consumer with a copy of his/her consumer report or credit score upon the consumer’s request.   - 72: For the purpose of administering a credit file or credit score monitoring service to which the consumer has subscribed.   - 73: For use by a housing counseling agency where the consumer has provided his / her specific consent.    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestEndUserInformation
instance A.FromJSON EquifaxUSConsumerCreditRequestEndUserInformation where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestEndUserInformation" $ \o ->
    EquifaxUSConsumerCreditRequestEndUserInformation
      <$> (o .:  "endUsersName")
      <*> (o .:  "permissiblePurposeCode")

-- | ToJSON EquifaxUSConsumerCreditRequestEndUserInformation
instance A.ToJSON EquifaxUSConsumerCreditRequestEndUserInformation where
  toJSON EquifaxUSConsumerCreditRequestEndUserInformation {..} =
   _omitNulls
      [ "endUsersName" .= equifaxUSConsumerCreditRequestEndUserInformationEndUsersName
      , "permissiblePurposeCode" .= equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode
      ]


-- | Construct a value of type 'EquifaxUSConsumerCreditRequestEndUserInformation' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestEndUserInformation
  :: Text -- ^ 'equifaxUSConsumerCreditRequestEndUserInformationEndUsersName': Company name of the final recipient of the consumer report making the request
  -> Text -- ^ 'equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode': Code to audit the purposes for which Equifax consumer information is furnished thus providing continued compliance with the FCRA   - 01: Intends to use the information as a potential investor servicer or current insurer in connection with a valuation of or assessment of the credit or prepayment risks.   - 03: In accordance with written instructions of the consumer to whom it relates.   - 04: In connection with a collection transaction involving a credit account of the consumer.   - 05: In response to an agency administering a state plan under Section 454 of the Social Security Act (42 U.S.C. 654) for use to set an initial or modified child support award.   - 06: In accordance with written instructions of the consumer through a reseller.   - 07: In response to a request by the head of a state or local child support enforcement agency (or a state or local government official authorized by the head of such an agency) that has met all requirements of Section 604(a)(4)(ABCD).   - 08: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer. For use only when the transaction cannot be described with a more specific code.   - 09: For employment purposes (Only PERSONA is available with this code)   - 10: In connection with a determination of eligibility for a license or other benefit granted by a governmental instrument required by law to consider financial responsibility or status.   - 11: In connection with the underwriting of insurance.   - 12: In connection with the review of existing policy holders for insurance underwriting purposes.   - 13: A legitimate business need to review an account to determine whether the consumer continues to meet the terms of the account.   - 14: In response to the order of a court having jurisdiction or a subpoena issued by a federal grand jury.   - 15: In connection with a tenant screen application involving the consumer.   - 16: For use by a governmental agency pursuant to FCRA Section 608.   - 17: To protect against or prevent actual or potential fraud unauthorized transactions claims or other liability.   - 18: For required institutional risk control or for resolving consumer disputes or inquiries.   - 19: Due to holding a legal or beneficial interest relating to the consumer.   - 20: To law enforcement agencies or for an investigation on a matter related to public safety.   - 21: As necessary to effect administer or enforce a transaction; to underwrite insurance at the consumer’s request for reinsurance purposes or for the following purposes related to the consumer’s insurance;  account administration reporting investigating fraud prevention premium payment processing claim processing benefit administration or research projects.   - 22: To persons acting in a fiduciary or representative capacity on behalf of and with the consent of the consumer.   - 23: As necessary to effect administer or enforce a transaction requested or authorized by the consumer including location for collection of a delinquent account.   - 24: In conjunction with access to a commercial file on a sole proprietorship.   - 25: In conjunction with access to a commercial file on a corporation where specific consumer consent is given.   - 26: In connection with a credit transaction involving the extension of credit to or review or collection of an account of the consumer where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use of which the medical information will be furnished.   - 27: For employment purposes where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use for which the medical information will be furnished.    - 28: In connection with the underwriting of insurance. Specific consumer consent was given for the release of medical information contained within the consumer report.   - 29: In connection with a transaction where the credit file including any medical information in it is only to be provided directly to the individual consumer to whom the information relates and specific consumer consent was received for the receipt and furnishing of the consumer report including medical information to the consumer.   - 51: In accordance with written instructions of the consumer providing consent for use related to bankruptcy filing purposes.   - 52: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to an automobile or truck.   - 53: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive repair.   - 54: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive parts tires etc.   - 55: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a boat or recreational vehicle.   - 56: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to farm equipment.   - 57: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan origination.   - 58: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan refinancing.   - 59: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a home equity loan line of credit.   - 60: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a personal loan.   - 61: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a credit card.   - 62: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home furnishings.   - 63: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to general contracting / home improvement.   - 64: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to air conditioning / heating / plumbing or electrical.   - 65: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to lumber / building materials / hardware.   - 66: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to hospitalization / medical care / dental care.   - 67: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to personal services.   - 68: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home heating oil / fuel.   - 69: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to telephone / electrical / gas / water utilities or household garbage removal.   - 70: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to wholesale goods.   - 71: For the purpose of providing a consumer with a copy of his/her consumer report or credit score upon the consumer’s request.   - 72: For the purpose of administering a credit file or credit score monitoring service to which the consumer has subscribed.   - 73: For use by a housing counseling agency where the consumer has provided his / her specific consent.    
  -> EquifaxUSConsumerCreditRequestEndUserInformation
mkEquifaxUSConsumerCreditRequestEndUserInformation equifaxUSConsumerCreditRequestEndUserInformationEndUsersName equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode =
  EquifaxUSConsumerCreditRequestEndUserInformation
  { equifaxUSConsumerCreditRequestEndUserInformationEndUsersName
  , equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode
  }

-- ** EquifaxUSConsumerCreditRequestModels
-- | EquifaxUSConsumerCreditRequestModels
data EquifaxUSConsumerCreditRequestModels = EquifaxUSConsumerCreditRequestModels
  { equifaxUSConsumerCreditRequestModelsIdentifier :: !(Maybe Text) -- ^ "identifier" - Model number
  , equifaxUSConsumerCreditRequestModelsModelField :: !(Maybe [Text]) -- ^ "modelField"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestModels
instance A.FromJSON EquifaxUSConsumerCreditRequestModels where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestModels" $ \o ->
    EquifaxUSConsumerCreditRequestModels
      <$> (o .:? "identifier")
      <*> (o .:? "modelField")

-- | ToJSON EquifaxUSConsumerCreditRequestModels
instance A.ToJSON EquifaxUSConsumerCreditRequestModels where
  toJSON EquifaxUSConsumerCreditRequestModels {..} =
   _omitNulls
      [ "identifier" .= equifaxUSConsumerCreditRequestModelsIdentifier
      , "modelField" .= equifaxUSConsumerCreditRequestModelsModelField
      ]


-- | Construct a value of type 'EquifaxUSConsumerCreditRequestModels' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestModels
  :: EquifaxUSConsumerCreditRequestModels
mkEquifaxUSConsumerCreditRequestModels =
  EquifaxUSConsumerCreditRequestModels
  { equifaxUSConsumerCreditRequestModelsIdentifier = Nothing
  , equifaxUSConsumerCreditRequestModelsModelField = Nothing
  }

-- ** EquifaxUSConsumerCreditRequestProductInformation
-- | EquifaxUSConsumerCreditRequestProductInformation
data EquifaxUSConsumerCreditRequestProductInformation = EquifaxUSConsumerCreditRequestProductInformation
  { equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber :: !(Maybe [EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber]) -- ^ "driverLicenseNumber"
  , equifaxUSConsumerCreditRequestProductInformationCoApplicantDateOfBirth :: !(Maybe Date) -- ^ "coApplicantDateOfBirth" - Co-applicant&#39;s birth date
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestProductInformation
instance A.FromJSON EquifaxUSConsumerCreditRequestProductInformation where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestProductInformation" $ \o ->
    EquifaxUSConsumerCreditRequestProductInformation
      <$> (o .:? "driverLicenseNumber")
      <*> (o .:? "coApplicantDateOfBirth")

-- | ToJSON EquifaxUSConsumerCreditRequestProductInformation
instance A.ToJSON EquifaxUSConsumerCreditRequestProductInformation where
  toJSON EquifaxUSConsumerCreditRequestProductInformation {..} =
   _omitNulls
      [ "driverLicenseNumber" .= equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
      , "coApplicantDateOfBirth" .= equifaxUSConsumerCreditRequestProductInformationCoApplicantDateOfBirth
      ]


-- | Construct a value of type 'EquifaxUSConsumerCreditRequestProductInformation' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestProductInformation
  :: EquifaxUSConsumerCreditRequestProductInformation
mkEquifaxUSConsumerCreditRequestProductInformation =
  EquifaxUSConsumerCreditRequestProductInformation
  { equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber = Nothing
  , equifaxUSConsumerCreditRequestProductInformationCoApplicantDateOfBirth = Nothing
  }

-- ** EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
-- | EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
data EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber = EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
  { equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberIdentifier :: !(Maybe Text) -- ^ "identifier" - Owner of the drivers license
  , equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberDriverLicenseNumber :: !(Maybe Text) -- ^ "driverLicenseNumber" - Subject&#39;s drivers license number
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
instance A.FromJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber" $ \o ->
    EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
      <$> (o .:? "identifier")
      <*> (o .:? "driverLicenseNumber")

-- | ToJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
instance A.ToJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber where
  toJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber {..} =
   _omitNulls
      [ "identifier" .= equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberIdentifier
      , "driverLicenseNumber" .= equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberDriverLicenseNumber
      ]


-- | Construct a value of type 'EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
  :: EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
mkEquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber =
  EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
  { equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberIdentifier = Nothing
  , equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberDriverLicenseNumber = Nothing
  }

-- ** Trade
-- | Trade
data Trade = Trade
  { tradeAutomatedUpdateIndicator :: !(Maybe Text) -- ^ "automatedUpdateIndicator" - Automated Update Indicator
  , tradeMonthsReviewed :: !(Maybe Text) -- ^ "monthsReviewed" - How many months the trade was reviewed
  , tradeAccountDesignator :: !(Maybe AccountDesignatorCode) -- ^ "accountDesignator"
  , tradeAccountNumber :: !(Maybe Text) -- ^ "accountNumber" - Account number
  , tradeThirtyDayCounter :: !(Maybe Int) -- ^ "thirtyDayCounter" - Number of times the consumer has been 30 days delinquent in payment
  , tradeSixtyDayCounter :: !(Maybe Int) -- ^ "sixtyDayCounter" - Number of times the consumer has been 60 days delinquent in payment
  , tradeNinetyDayCounter :: !(Maybe Int) -- ^ "ninetyDayCounter" - Number of times the consumer has been 90+ days delinquent in payment
  , tradePreviousHighRate1 :: !(Maybe Int) -- ^ "previousHighRate1" - First highest rate that occurred outside of the timeframe of the payment history that has beed requested (Valid Rates\\: 2-5, 8 and 9) 
  , tradePreviousHighDate1 :: !(Maybe Text) -- ^ "previousHighDate1" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , tradePreviousHighRate2 :: !(Maybe Int) -- ^ "previousHighRate2" - Second highest rate that occurred outside of the timeframe of the payment history that has beed requested (Valid Rates\\: 2-5, 8 and 9) 
  , tradePreviousHighDate2 :: !(Maybe Text) -- ^ "previousHighDate2" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , tradePreviousHighRate3 :: !(Maybe Int) -- ^ "previousHighRate3" - Third highest rate that occurred outside of the timeframe of the payment history that has beed requested (Valid Rates\\: 2-5, 8 and 9) 
  , tradePreviousHighDate3 :: !(Maybe Text) -- ^ "previousHighDate3" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , trade24monthPaymentHistory :: !(Maybe [Trade24MonthPaymentHistory]) -- ^ "24MonthPaymentHistory"
  , tradeCustomerName :: !(Maybe Text) -- ^ "customerName" - Customer name
  , tradeCustomerNumber :: !(Maybe Text) -- ^ "customerNumber" - Customer number
  , tradeDateReported :: !(Maybe Date) -- ^ "dateReported" - Represents the \&quot;as of\&quot; date of the most recent update received from the data furnisher. Accounts may continue to be updated by the data furnisher even after they are closed, paid out or become severely delinquent (charge off, repossession, etc.). 
  , tradeDateOpened :: !(Maybe Date) -- ^ "dateOpened" - Date account originally opened
  , tradeHighCredit :: !(Maybe Int) -- ^ "highCredit" - Highest outstanding balance or original amount
  , tradeCreditLimit :: !(Maybe Int) -- ^ "creditLimit" - Highest available credit limit
  , tradeBalance :: !(Maybe Int) -- ^ "balance" - Account balance
  , tradePastDueAmount :: !(Maybe Int) -- ^ "pastDueAmount" - Amount past due on an account (late)
  , tradePortfolioTypeCode :: !(Maybe TradePortfolioTypeCode) -- ^ "portfolioTypeCode"
  , tradeRateStatusCode :: !(Maybe TradeRateStatusCode) -- ^ "rateStatusCode"
  , tradeRate :: !(Maybe TradeRate) -- ^ "rate"
  , tradeLastActivityDate :: !(Maybe Text) -- ^ "lastActivityDate" - Contains the date of last activity
  , tradeNarrativeCodes :: !(Maybe [A.Value]) -- ^ "narrativeCodes"
  , tradeRawNarrativeCodes :: !(Maybe [Text]) -- ^ "rawNarrativeCodes" - Raw codes for the narratives
  , tradeAccountTypeCode :: !(Maybe AccountTypeCode) -- ^ "accountTypeCode"
  , tradeLastPaymentDate :: !(Maybe Date) -- ^ "lastPaymentDate" - Date of the most recent payment.
  , tradeClosedDate :: !(Maybe Date) -- ^ "closedDate" - Contains the date the account was closed
  , tradeDateMajorDelinquencyFirstReported :: !(Maybe Date) -- ^ "dateMajorDelinquencyFirstReported" - If current Rate/Status code is 6, 7, 8, 9, M, Z or if trade contains narrative code 081 (foreclosure), this date will reflect the first time that Rate/Status or narrative code was reported. 
  , tradeActualPaymentAmount :: !(Maybe Int) -- ^ "actualPaymentAmount" - Payment actually received for a reporting period
  , tradeScheduledPaymentAmount :: !(Maybe Int) -- ^ "scheduledPaymentAmount" - Contractual amount due for a payment period. (The figure in this field should be the monthly amount due regardless of the actual payment frequency.)  
  , tradeTermsFrequencyCode :: !(Maybe TradeTermsFrequencyCode) -- ^ "termsFrequencyCode"
  , tradeTermsDurationCode :: !(Maybe TradeTermsDurationCode) -- ^ "termsDurationCode"
  , tradePurchasedFromOrSoldCreditorIndicator :: !(Maybe TradePurchasedFromOrSoldCreditorIndicator) -- ^ "purchasedFromOrSoldCreditorIndicator"
  , tradePurchasedFromOrSoldCreditorName :: !(Maybe Text) -- ^ "purchasedFromOrSoldCreditorName" - Denotes who the account was either purchased from or sold to or the Original Creditor’s name
  , tradeCreditorClassificationCode :: !(Maybe CreditorClassificationCode) -- ^ "creditorClassificationCode"
  , tradeActivityDesignatorCode :: !(Maybe TradeActivityDesignatorCode) -- ^ "activityDesignatorCode"
  , tradeOriginalChargeOffAmount :: !(Maybe Int) -- ^ "originalChargeOffAmount" - Amount originally charged to loss by the creditor
  , tradeDeferredPaymentStartDate :: !(Maybe Date) -- ^ "deferredPaymentStartDate" - Contains the date the first payment is due for deferred loans
  , tradeBallonPaymentAmount :: !(Maybe Int) -- ^ "ballonPaymentAmount" - Amount of the balloon payment
  , tradeBallonPaymentDueDate :: !(Maybe Date) -- ^ "ballonPaymentDueDate" - Contains the date the balloon payment is due
  , tradeMortgageIdNumber :: !(Maybe Text) -- ^ "mortgageIDNumber" - Number assigned to a mortgage loan that remains constant throughout the life of the loan. The MIN indicates that the loan is registered with the Mortgage Electronic Registration Systems, Inc., the electronic registry for tracking the ownership of mortgage rights. 
  , tradePaymentHistory1to24 :: !(Maybe [TradePaymentHistory1to24]) -- ^ "paymentHistory1to24"
  , tradePaymentHistory25to36 :: !(Maybe [TradePaymentHistory25to36]) -- ^ "paymentHistory25to36"
  , tradePaymentHistory37to48 :: !(Maybe [TradePaymentHistory37to48]) -- ^ "paymentHistory37to48"
  , tradePreviousHighRatePaymentHistory :: !(Maybe Text) -- ^ "previousHighRatePaymentHistory"
  , tradePreviousHighDatePaymentHistory :: !(Maybe Text) -- ^ "previousHighDatePaymentHistory" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , tradeDimensionsDataStartDate :: !(Maybe Text) -- ^ "dimensionsDataStartDate" - Date in format MMYYYY where MM is the Month and YYYY is the year
  , tradeDimensionsNumberOfMonths :: !(Maybe Text) -- ^ "dimensionsNumberOfMonths" - Number of months of Dimensions data requested
  , tradeDimension :: !(Maybe [TradeDimension]) -- ^ "dimension" - Information over the most recent 24 months of historical data. There may be gaps of historical Dimensions data if that month (or field) is not available Dimensions Data is an optional feature offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Trade
instance A.FromJSON Trade where
  parseJSON = A.withObject "Trade" $ \o ->
    Trade
      <$> (o .:? "automatedUpdateIndicator")
      <*> (o .:? "monthsReviewed")
      <*> (o .:? "accountDesignator")
      <*> (o .:? "accountNumber")
      <*> (o .:? "thirtyDayCounter")
      <*> (o .:? "sixtyDayCounter")
      <*> (o .:? "ninetyDayCounter")
      <*> (o .:? "previousHighRate1")
      <*> (o .:? "previousHighDate1")
      <*> (o .:? "previousHighRate2")
      <*> (o .:? "previousHighDate2")
      <*> (o .:? "previousHighRate3")
      <*> (o .:? "previousHighDate3")
      <*> (o .:? "24MonthPaymentHistory")
      <*> (o .:? "customerName")
      <*> (o .:? "customerNumber")
      <*> (o .:? "dateReported")
      <*> (o .:? "dateOpened")
      <*> (o .:? "highCredit")
      <*> (o .:? "creditLimit")
      <*> (o .:? "balance")
      <*> (o .:? "pastDueAmount")
      <*> (o .:? "portfolioTypeCode")
      <*> (o .:? "rateStatusCode")
      <*> (o .:? "rate")
      <*> (o .:? "lastActivityDate")
      <*> (o .:? "narrativeCodes")
      <*> (o .:? "rawNarrativeCodes")
      <*> (o .:? "accountTypeCode")
      <*> (o .:? "lastPaymentDate")
      <*> (o .:? "closedDate")
      <*> (o .:? "dateMajorDelinquencyFirstReported")
      <*> (o .:? "actualPaymentAmount")
      <*> (o .:? "scheduledPaymentAmount")
      <*> (o .:? "termsFrequencyCode")
      <*> (o .:? "termsDurationCode")
      <*> (o .:? "purchasedFromOrSoldCreditorIndicator")
      <*> (o .:? "purchasedFromOrSoldCreditorName")
      <*> (o .:? "creditorClassificationCode")
      <*> (o .:? "activityDesignatorCode")
      <*> (o .:? "originalChargeOffAmount")
      <*> (o .:? "deferredPaymentStartDate")
      <*> (o .:? "ballonPaymentAmount")
      <*> (o .:? "ballonPaymentDueDate")
      <*> (o .:? "mortgageIDNumber")
      <*> (o .:? "paymentHistory1to24")
      <*> (o .:? "paymentHistory25to36")
      <*> (o .:? "paymentHistory37to48")
      <*> (o .:? "previousHighRatePaymentHistory")
      <*> (o .:? "previousHighDatePaymentHistory")
      <*> (o .:? "dimensionsDataStartDate")
      <*> (o .:? "dimensionsNumberOfMonths")
      <*> (o .:? "dimension")

-- | ToJSON Trade
instance A.ToJSON Trade where
  toJSON Trade {..} =
   _omitNulls
      [ "automatedUpdateIndicator" .= tradeAutomatedUpdateIndicator
      , "monthsReviewed" .= tradeMonthsReviewed
      , "accountDesignator" .= tradeAccountDesignator
      , "accountNumber" .= tradeAccountNumber
      , "thirtyDayCounter" .= tradeThirtyDayCounter
      , "sixtyDayCounter" .= tradeSixtyDayCounter
      , "ninetyDayCounter" .= tradeNinetyDayCounter
      , "previousHighRate1" .= tradePreviousHighRate1
      , "previousHighDate1" .= tradePreviousHighDate1
      , "previousHighRate2" .= tradePreviousHighRate2
      , "previousHighDate2" .= tradePreviousHighDate2
      , "previousHighRate3" .= tradePreviousHighRate3
      , "previousHighDate3" .= tradePreviousHighDate3
      , "24MonthPaymentHistory" .= trade24monthPaymentHistory
      , "customerName" .= tradeCustomerName
      , "customerNumber" .= tradeCustomerNumber
      , "dateReported" .= tradeDateReported
      , "dateOpened" .= tradeDateOpened
      , "highCredit" .= tradeHighCredit
      , "creditLimit" .= tradeCreditLimit
      , "balance" .= tradeBalance
      , "pastDueAmount" .= tradePastDueAmount
      , "portfolioTypeCode" .= tradePortfolioTypeCode
      , "rateStatusCode" .= tradeRateStatusCode
      , "rate" .= tradeRate
      , "lastActivityDate" .= tradeLastActivityDate
      , "narrativeCodes" .= tradeNarrativeCodes
      , "rawNarrativeCodes" .= tradeRawNarrativeCodes
      , "accountTypeCode" .= tradeAccountTypeCode
      , "lastPaymentDate" .= tradeLastPaymentDate
      , "closedDate" .= tradeClosedDate
      , "dateMajorDelinquencyFirstReported" .= tradeDateMajorDelinquencyFirstReported
      , "actualPaymentAmount" .= tradeActualPaymentAmount
      , "scheduledPaymentAmount" .= tradeScheduledPaymentAmount
      , "termsFrequencyCode" .= tradeTermsFrequencyCode
      , "termsDurationCode" .= tradeTermsDurationCode
      , "purchasedFromOrSoldCreditorIndicator" .= tradePurchasedFromOrSoldCreditorIndicator
      , "purchasedFromOrSoldCreditorName" .= tradePurchasedFromOrSoldCreditorName
      , "creditorClassificationCode" .= tradeCreditorClassificationCode
      , "activityDesignatorCode" .= tradeActivityDesignatorCode
      , "originalChargeOffAmount" .= tradeOriginalChargeOffAmount
      , "deferredPaymentStartDate" .= tradeDeferredPaymentStartDate
      , "ballonPaymentAmount" .= tradeBallonPaymentAmount
      , "ballonPaymentDueDate" .= tradeBallonPaymentDueDate
      , "mortgageIDNumber" .= tradeMortgageIdNumber
      , "paymentHistory1to24" .= tradePaymentHistory1to24
      , "paymentHistory25to36" .= tradePaymentHistory25to36
      , "paymentHistory37to48" .= tradePaymentHistory37to48
      , "previousHighRatePaymentHistory" .= tradePreviousHighRatePaymentHistory
      , "previousHighDatePaymentHistory" .= tradePreviousHighDatePaymentHistory
      , "dimensionsDataStartDate" .= tradeDimensionsDataStartDate
      , "dimensionsNumberOfMonths" .= tradeDimensionsNumberOfMonths
      , "dimension" .= tradeDimension
      ]


-- | Construct a value of type 'Trade' (by applying it's required fields, if any)
mkTrade
  :: Trade
mkTrade =
  Trade
  { tradeAutomatedUpdateIndicator = Nothing
  , tradeMonthsReviewed = Nothing
  , tradeAccountDesignator = Nothing
  , tradeAccountNumber = Nothing
  , tradeThirtyDayCounter = Nothing
  , tradeSixtyDayCounter = Nothing
  , tradeNinetyDayCounter = Nothing
  , tradePreviousHighRate1 = Nothing
  , tradePreviousHighDate1 = Nothing
  , tradePreviousHighRate2 = Nothing
  , tradePreviousHighDate2 = Nothing
  , tradePreviousHighRate3 = Nothing
  , tradePreviousHighDate3 = Nothing
  , trade24monthPaymentHistory = Nothing
  , tradeCustomerName = Nothing
  , tradeCustomerNumber = Nothing
  , tradeDateReported = Nothing
  , tradeDateOpened = Nothing
  , tradeHighCredit = Nothing
  , tradeCreditLimit = Nothing
  , tradeBalance = Nothing
  , tradePastDueAmount = Nothing
  , tradePortfolioTypeCode = Nothing
  , tradeRateStatusCode = Nothing
  , tradeRate = Nothing
  , tradeLastActivityDate = Nothing
  , tradeNarrativeCodes = Nothing
  , tradeRawNarrativeCodes = Nothing
  , tradeAccountTypeCode = Nothing
  , tradeLastPaymentDate = Nothing
  , tradeClosedDate = Nothing
  , tradeDateMajorDelinquencyFirstReported = Nothing
  , tradeActualPaymentAmount = Nothing
  , tradeScheduledPaymentAmount = Nothing
  , tradeTermsFrequencyCode = Nothing
  , tradeTermsDurationCode = Nothing
  , tradePurchasedFromOrSoldCreditorIndicator = Nothing
  , tradePurchasedFromOrSoldCreditorName = Nothing
  , tradeCreditorClassificationCode = Nothing
  , tradeActivityDesignatorCode = Nothing
  , tradeOriginalChargeOffAmount = Nothing
  , tradeDeferredPaymentStartDate = Nothing
  , tradeBallonPaymentAmount = Nothing
  , tradeBallonPaymentDueDate = Nothing
  , tradeMortgageIdNumber = Nothing
  , tradePaymentHistory1to24 = Nothing
  , tradePaymentHistory25to36 = Nothing
  , tradePaymentHistory37to48 = Nothing
  , tradePreviousHighRatePaymentHistory = Nothing
  , tradePreviousHighDatePaymentHistory = Nothing
  , tradeDimensionsDataStartDate = Nothing
  , tradeDimensionsNumberOfMonths = Nothing
  , tradeDimension = Nothing
  }

-- ** Trade24MonthPaymentHistory
-- | Trade24MonthPaymentHistory
data Trade24MonthPaymentHistory = Trade24MonthPaymentHistory
  { trade24MonthPaymentHistoryCode :: !(Maybe Text) -- ^ "code"
  , trade24MonthPaymentHistoryDescription :: !(Maybe Text) -- ^ "description" - The most recent payment history on the trade for the last 24 months It&#39;s an optional feature offered by Equifax. Please contact your Equifax Sales Associate for additional information and activation. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Trade24MonthPaymentHistory
instance A.FromJSON Trade24MonthPaymentHistory where
  parseJSON = A.withObject "Trade24MonthPaymentHistory" $ \o ->
    Trade24MonthPaymentHistory
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON Trade24MonthPaymentHistory
instance A.ToJSON Trade24MonthPaymentHistory where
  toJSON Trade24MonthPaymentHistory {..} =
   _omitNulls
      [ "code" .= trade24MonthPaymentHistoryCode
      , "description" .= trade24MonthPaymentHistoryDescription
      ]


-- | Construct a value of type 'Trade24MonthPaymentHistory' (by applying it's required fields, if any)
mkTrade24MonthPaymentHistory
  :: Trade24MonthPaymentHistory
mkTrade24MonthPaymentHistory =
  Trade24MonthPaymentHistory
  { trade24MonthPaymentHistoryCode = Nothing
  , trade24MonthPaymentHistoryDescription = Nothing
  }

-- ** TradeActivityDesignatorCode
-- | TradeActivityDesignatorCode
-- Describes the final state of the account.
data TradeActivityDesignatorCode = TradeActivityDesignatorCode
  { tradeActivityDesignatorCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , tradeActivityDesignatorCodeDescription :: !(Maybe Text) -- ^ "description" - - B: Paid and Closed - C: Closed - D: Transfer/Sold/Paid - L: Lost/Stolen - P: Paid - R: Refinanced - T: Transfer/Sold 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradeActivityDesignatorCode
instance A.FromJSON TradeActivityDesignatorCode where
  parseJSON = A.withObject "TradeActivityDesignatorCode" $ \o ->
    TradeActivityDesignatorCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradeActivityDesignatorCode
instance A.ToJSON TradeActivityDesignatorCode where
  toJSON TradeActivityDesignatorCode {..} =
   _omitNulls
      [ "code" .= tradeActivityDesignatorCodeCode
      , "description" .= tradeActivityDesignatorCodeDescription
      ]


-- | Construct a value of type 'TradeActivityDesignatorCode' (by applying it's required fields, if any)
mkTradeActivityDesignatorCode
  :: TradeActivityDesignatorCode
mkTradeActivityDesignatorCode =
  TradeActivityDesignatorCode
  { tradeActivityDesignatorCodeCode = Nothing
  , tradeActivityDesignatorCodeDescription = Nothing
  }

-- ** TradeDimension
-- | TradeDimension
data TradeDimension = TradeDimension
  { tradeDimensionDimensionsBalance :: !(Maybe Int) -- ^ "dimensionsBalance" - Balance during the month being reported
  , tradeDimensionDimensionsActualPaymentAmount :: !(Maybe Int) -- ^ "dimensionsActualPaymentAmount" - Payment actually received for a reporting period
  , tradeDimensionDimensionsScheduledPaymentAmount :: !(Maybe Int) -- ^ "dimensionsScheduledPaymentAmount" - Contractual amount due for a payment period. (The figure in this field should be the monthly amount due regardless of the actual payment frequency.)
  , tradeDimensionDimensionsLastPaymentDate :: !(Maybe Date) -- ^ "dimensionsLastPaymentDate" - Date of the most recent payment
  , tradeDimensionDimensionsHighCredit :: !(Maybe Int) -- ^ "dimensionsHighCredit" - Highest outstanding balance or original amount
  , tradeDimensionDimensionsCreditLimit :: !(Maybe Int) -- ^ "dimensionsCreditLimit" - Highest available credit amount
  , tradeDimensionDimensionsPastDueAmount :: !(Maybe Int) -- ^ "dimensionsPastDueAmount" - Current amount overdue on a trade
  , tradeDimensionDimensionsNarrativeCodes :: !(Maybe [A.Value]) -- ^ "dimensionsNarrativeCodes"
  , tradeDimensionDimensionsRawNarrativeCodes :: !(Maybe [Text]) -- ^ "dimensionsRawNarrativeCodes" - Raw Dimensions Data naratives. It contains up to 4 narratives
  , tradeDimensionDimensionsAccountDesignatorCode :: !(Maybe AccountDesignatorCode) -- ^ "dimensionsAccountDesignatorCode"
  , tradeDimensionDimensionsAccountTypeCode :: !(Maybe AccountTypeCode) -- ^ "dimensionsAccountTypeCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradeDimension
instance A.FromJSON TradeDimension where
  parseJSON = A.withObject "TradeDimension" $ \o ->
    TradeDimension
      <$> (o .:? "dimensionsBalance")
      <*> (o .:? "dimensionsActualPaymentAmount")
      <*> (o .:? "dimensionsScheduledPaymentAmount")
      <*> (o .:? "dimensionsLastPaymentDate")
      <*> (o .:? "dimensionsHighCredit")
      <*> (o .:? "dimensionsCreditLimit")
      <*> (o .:? "dimensionsPastDueAmount")
      <*> (o .:? "dimensionsNarrativeCodes")
      <*> (o .:? "dimensionsRawNarrativeCodes")
      <*> (o .:? "dimensionsAccountDesignatorCode")
      <*> (o .:? "dimensionsAccountTypeCode")

-- | ToJSON TradeDimension
instance A.ToJSON TradeDimension where
  toJSON TradeDimension {..} =
   _omitNulls
      [ "dimensionsBalance" .= tradeDimensionDimensionsBalance
      , "dimensionsActualPaymentAmount" .= tradeDimensionDimensionsActualPaymentAmount
      , "dimensionsScheduledPaymentAmount" .= tradeDimensionDimensionsScheduledPaymentAmount
      , "dimensionsLastPaymentDate" .= tradeDimensionDimensionsLastPaymentDate
      , "dimensionsHighCredit" .= tradeDimensionDimensionsHighCredit
      , "dimensionsCreditLimit" .= tradeDimensionDimensionsCreditLimit
      , "dimensionsPastDueAmount" .= tradeDimensionDimensionsPastDueAmount
      , "dimensionsNarrativeCodes" .= tradeDimensionDimensionsNarrativeCodes
      , "dimensionsRawNarrativeCodes" .= tradeDimensionDimensionsRawNarrativeCodes
      , "dimensionsAccountDesignatorCode" .= tradeDimensionDimensionsAccountDesignatorCode
      , "dimensionsAccountTypeCode" .= tradeDimensionDimensionsAccountTypeCode
      ]


-- | Construct a value of type 'TradeDimension' (by applying it's required fields, if any)
mkTradeDimension
  :: TradeDimension
mkTradeDimension =
  TradeDimension
  { tradeDimensionDimensionsBalance = Nothing
  , tradeDimensionDimensionsActualPaymentAmount = Nothing
  , tradeDimensionDimensionsScheduledPaymentAmount = Nothing
  , tradeDimensionDimensionsLastPaymentDate = Nothing
  , tradeDimensionDimensionsHighCredit = Nothing
  , tradeDimensionDimensionsCreditLimit = Nothing
  , tradeDimensionDimensionsPastDueAmount = Nothing
  , tradeDimensionDimensionsNarrativeCodes = Nothing
  , tradeDimensionDimensionsRawNarrativeCodes = Nothing
  , tradeDimensionDimensionsAccountDesignatorCode = Nothing
  , tradeDimensionDimensionsAccountTypeCode = Nothing
  }

-- ** TradePaymentHistory1to24
-- | TradePaymentHistory1to24
data TradePaymentHistory1to24 = TradePaymentHistory1to24
  { tradePaymentHistory1to24Code :: !(Maybe Text) -- ^ "code"
  , tradePaymentHistory1to24Description :: !(Maybe Text) -- ^ "description" - The valid values for the standard 24, 36 and 48 Month Payment History are:    - Blank: not populated based on the Date Open (payment history will only be populated for each of the months that the account has been open)   - E: Zero balance and current account    - \\*: Rate/Status was not available for that month  - 2 – 6, 8 and 9 (See Rate/Status Codes for values)  - 6: Valid value for Payment History 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradePaymentHistory1to24
instance A.FromJSON TradePaymentHistory1to24 where
  parseJSON = A.withObject "TradePaymentHistory1to24" $ \o ->
    TradePaymentHistory1to24
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradePaymentHistory1to24
instance A.ToJSON TradePaymentHistory1to24 where
  toJSON TradePaymentHistory1to24 {..} =
   _omitNulls
      [ "code" .= tradePaymentHistory1to24Code
      , "description" .= tradePaymentHistory1to24Description
      ]


-- | Construct a value of type 'TradePaymentHistory1to24' (by applying it's required fields, if any)
mkTradePaymentHistory1to24
  :: TradePaymentHistory1to24
mkTradePaymentHistory1to24 =
  TradePaymentHistory1to24
  { tradePaymentHistory1to24Code = Nothing
  , tradePaymentHistory1to24Description = Nothing
  }

-- ** TradePaymentHistory25to36
-- | TradePaymentHistory25to36
data TradePaymentHistory25to36 = TradePaymentHistory25to36
  { tradePaymentHistory25to36Code :: !(Maybe Text) -- ^ "code"
  , tradePaymentHistory25to36Description :: !(Maybe Text) -- ^ "description" - The valid values for the standard 24, 36 and 48 Month Payment History are:  - Blank: not populated based on the Date Open (payment history will only be populated for each of the months that the account has been open)  - E: Zero balance and current account  - \\*: Rate/Status was not available for that month  - 2 - 6, 8 and 9 (See Rate/Status Codes for values)  - 6: Valid value for Payment History 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradePaymentHistory25to36
instance A.FromJSON TradePaymentHistory25to36 where
  parseJSON = A.withObject "TradePaymentHistory25to36" $ \o ->
    TradePaymentHistory25to36
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradePaymentHistory25to36
instance A.ToJSON TradePaymentHistory25to36 where
  toJSON TradePaymentHistory25to36 {..} =
   _omitNulls
      [ "code" .= tradePaymentHistory25to36Code
      , "description" .= tradePaymentHistory25to36Description
      ]


-- | Construct a value of type 'TradePaymentHistory25to36' (by applying it's required fields, if any)
mkTradePaymentHistory25to36
  :: TradePaymentHistory25to36
mkTradePaymentHistory25to36 =
  TradePaymentHistory25to36
  { tradePaymentHistory25to36Code = Nothing
  , tradePaymentHistory25to36Description = Nothing
  }

-- ** TradePaymentHistory37to48
-- | TradePaymentHistory37to48
data TradePaymentHistory37to48 = TradePaymentHistory37to48
  { tradePaymentHistory37to48Code :: !(Maybe Text) -- ^ "code"
  , tradePaymentHistory37to48Description :: !(Maybe Text) -- ^ "description" - The valid values for the standard 24, 36 and 48 Month Payment History are:  - Blank: not populated based on the Date Open (payment history will only be populated for each of the months that the account has been open)  - E: Zero balance and current account  - \\*: Rate/Status was not available for that month  - 2 – 6, 8 and 9 (See Rate/Status Codes for values)  - 6: Valid value for Payment History 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradePaymentHistory37to48
instance A.FromJSON TradePaymentHistory37to48 where
  parseJSON = A.withObject "TradePaymentHistory37to48" $ \o ->
    TradePaymentHistory37to48
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradePaymentHistory37to48
instance A.ToJSON TradePaymentHistory37to48 where
  toJSON TradePaymentHistory37to48 {..} =
   _omitNulls
      [ "code" .= tradePaymentHistory37to48Code
      , "description" .= tradePaymentHistory37to48Description
      ]


-- | Construct a value of type 'TradePaymentHistory37to48' (by applying it's required fields, if any)
mkTradePaymentHistory37to48
  :: TradePaymentHistory37to48
mkTradePaymentHistory37to48 =
  TradePaymentHistory37to48
  { tradePaymentHistory37to48Code = Nothing
  , tradePaymentHistory37to48Description = Nothing
  }

-- ** TradePortfolioTypeCode
-- | TradePortfolioTypeCode
-- Describes the payment arrangement of the account (revolving, open, installment, line of credit or mortgage)
data TradePortfolioTypeCode = TradePortfolioTypeCode
  { tradePortfolioTypeCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , tradePortfolioTypeCodeDescription :: !(Maybe Text) -- ^ "description" - Portfolio Type Codes:   - C: Line of Credit (payment amounts based on the outstanding balance)   - I: Installment (fixed number of payments)   - M: Mortgage (fixed number of payments – usually for real estate)   - O: Open Account (entire balance is due upon demand)   - R: Revolving (payment amounts based on the outstanding balance)   - Blank: No Portfolio Type available    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradePortfolioTypeCode
instance A.FromJSON TradePortfolioTypeCode where
  parseJSON = A.withObject "TradePortfolioTypeCode" $ \o ->
    TradePortfolioTypeCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradePortfolioTypeCode
instance A.ToJSON TradePortfolioTypeCode where
  toJSON TradePortfolioTypeCode {..} =
   _omitNulls
      [ "code" .= tradePortfolioTypeCodeCode
      , "description" .= tradePortfolioTypeCodeDescription
      ]


-- | Construct a value of type 'TradePortfolioTypeCode' (by applying it's required fields, if any)
mkTradePortfolioTypeCode
  :: TradePortfolioTypeCode
mkTradePortfolioTypeCode =
  TradePortfolioTypeCode
  { tradePortfolioTypeCodeCode = Nothing
  , tradePortfolioTypeCodeDescription = Nothing
  }

-- ** TradePurchasedFromOrSoldCreditorIndicator
-- | TradePurchasedFromOrSoldCreditorIndicator
-- Purchased From/Sold To/Original Creditor Name is the purchaser, seller or original creditor
data TradePurchasedFromOrSoldCreditorIndicator = TradePurchasedFromOrSoldCreditorIndicator
  { tradePurchasedFromOrSoldCreditorIndicatorCode :: !(Maybe Text) -- ^ "code" - Code value
  , tradePurchasedFromOrSoldCreditorIndicatorDescription :: !(Maybe Text) -- ^ "description" - Purchased From/Sold To/Original Creditor Values   - O: Original Creditor   - P: Purchased From   - S: Sold To 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradePurchasedFromOrSoldCreditorIndicator
instance A.FromJSON TradePurchasedFromOrSoldCreditorIndicator where
  parseJSON = A.withObject "TradePurchasedFromOrSoldCreditorIndicator" $ \o ->
    TradePurchasedFromOrSoldCreditorIndicator
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradePurchasedFromOrSoldCreditorIndicator
instance A.ToJSON TradePurchasedFromOrSoldCreditorIndicator where
  toJSON TradePurchasedFromOrSoldCreditorIndicator {..} =
   _omitNulls
      [ "code" .= tradePurchasedFromOrSoldCreditorIndicatorCode
      , "description" .= tradePurchasedFromOrSoldCreditorIndicatorDescription
      ]


-- | Construct a value of type 'TradePurchasedFromOrSoldCreditorIndicator' (by applying it's required fields, if any)
mkTradePurchasedFromOrSoldCreditorIndicator
  :: TradePurchasedFromOrSoldCreditorIndicator
mkTradePurchasedFromOrSoldCreditorIndicator =
  TradePurchasedFromOrSoldCreditorIndicator
  { tradePurchasedFromOrSoldCreditorIndicatorCode = Nothing
  , tradePurchasedFromOrSoldCreditorIndicatorDescription = Nothing
  }

-- ** TradeRate
-- | TradeRate
data TradeRate = TradeRate
  { tradeRateCode :: !(Maybe Int) -- ^ "code"
  , tradeRateDescription :: !(Maybe Text) -- ^ "description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradeRate
instance A.FromJSON TradeRate where
  parseJSON = A.withObject "TradeRate" $ \o ->
    TradeRate
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradeRate
instance A.ToJSON TradeRate where
  toJSON TradeRate {..} =
   _omitNulls
      [ "code" .= tradeRateCode
      , "description" .= tradeRateDescription
      ]


-- | Construct a value of type 'TradeRate' (by applying it's required fields, if any)
mkTradeRate
  :: TradeRate
mkTradeRate =
  TradeRate
  { tradeRateCode = Nothing
  , tradeRateDescription = Nothing
  }

-- ** TradeRateStatusCode
-- | TradeRateStatusCode
-- Current status or rating of the account
data TradeRateStatusCode = TradeRateStatusCode
  { tradeRateStatusCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , tradeRateStatusCodeDescription :: !(Maybe Text) -- ^ "description" -  - 0: Too new to rate; Approved but not used    : - 1: Pays account as agreed    : - 2: Not more than two payments past due    : - 3: Not more than three payments past due    : - 4: Not more than four payments past due    : - 5: At least 120 days or more than four payments past due    : - 6: Collection account (Enhanced Trade Only)    : - 7: Included in Chapter 13    : - 8: Repossession    : - 9: Charge-off - Blank: No rate reported 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradeRateStatusCode
instance A.FromJSON TradeRateStatusCode where
  parseJSON = A.withObject "TradeRateStatusCode" $ \o ->
    TradeRateStatusCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradeRateStatusCode
instance A.ToJSON TradeRateStatusCode where
  toJSON TradeRateStatusCode {..} =
   _omitNulls
      [ "code" .= tradeRateStatusCodeCode
      , "description" .= tradeRateStatusCodeDescription
      ]


-- | Construct a value of type 'TradeRateStatusCode' (by applying it's required fields, if any)
mkTradeRateStatusCode
  :: TradeRateStatusCode
mkTradeRateStatusCode =
  TradeRateStatusCode
  { tradeRateStatusCodeCode = Nothing
  , tradeRateStatusCodeDescription = Nothing
  }

-- ** TradeTermsDurationCode
-- | TradeTermsDurationCode
-- Amount of time to repay the loan
data TradeTermsDurationCode = TradeTermsDurationCode
  { tradeTermsDurationCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , tradeTermsDurationCodeDescription :: !(Maybe Text) -- ^ "description" - Terms duration codes    - D: Days   - M: Months   - Y: Years 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradeTermsDurationCode
instance A.FromJSON TradeTermsDurationCode where
  parseJSON = A.withObject "TradeTermsDurationCode" $ \o ->
    TradeTermsDurationCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradeTermsDurationCode
instance A.ToJSON TradeTermsDurationCode where
  toJSON TradeTermsDurationCode {..} =
   _omitNulls
      [ "code" .= tradeTermsDurationCodeCode
      , "description" .= tradeTermsDurationCodeDescription
      ]


-- | Construct a value of type 'TradeTermsDurationCode' (by applying it's required fields, if any)
mkTradeTermsDurationCode
  :: TradeTermsDurationCode
mkTradeTermsDurationCode =
  TradeTermsDurationCode
  { tradeTermsDurationCodeCode = Nothing
  , tradeTermsDurationCodeDescription = Nothing
  }

-- ** TradeTermsFrequencyCode
-- | TradeTermsFrequencyCode
-- Reflects how often payments are due
data TradeTermsFrequencyCode = TradeTermsFrequencyCode
  { tradeTermsFrequencyCodeCode :: !(Maybe Text) -- ^ "code" - Code value
  , tradeTermsFrequencyCodeDescription :: !(Maybe Text) -- ^ "description" - - B: Biweekly (due every 2 weeks) - D: Deferred - E: Semi-monthly (due twice a month) - L: Bi-monthly (due every 2 months) - M: Monthly (due every month) - P: Single Payment Loan - Q: Quarterly (due every 3 months) - S: Semi-annually (due twice a year) - T: Tri-annually (due every 4 months) - W: Weekly (due every week) - Y: Annually (due every year) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TradeTermsFrequencyCode
instance A.FromJSON TradeTermsFrequencyCode where
  parseJSON = A.withObject "TradeTermsFrequencyCode" $ \o ->
    TradeTermsFrequencyCode
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON TradeTermsFrequencyCode
instance A.ToJSON TradeTermsFrequencyCode where
  toJSON TradeTermsFrequencyCode {..} =
   _omitNulls
      [ "code" .= tradeTermsFrequencyCodeCode
      , "description" .= tradeTermsFrequencyCodeDescription
      ]


-- | Construct a value of type 'TradeTermsFrequencyCode' (by applying it's required fields, if any)
mkTradeTermsFrequencyCode
  :: TradeTermsFrequencyCode
mkTradeTermsFrequencyCode =
  TradeTermsFrequencyCode
  { tradeTermsFrequencyCodeCode = Nothing
  , tradeTermsFrequencyCodeDescription = Nothing
  }


-- * Enums


-- ** E'AddressType

-- | Enum of 'Text' .
-- The address type:   - current: Current Address. A maximum of 1 current Address can be returned per report   - former: Former Address. A maximum of 1 former Address can be returned per report   - additional: Additional Address. A maximum of 8 additional Addresses can be returned per report 
data E'AddressType
  = E'AddressType'Current -- ^ @"current"@
  | E'AddressType'Former -- ^ @"former"@
  | E'AddressType'Additional -- ^ @"additional"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AddressType where toJSON = A.toJSON . fromE'AddressType
instance A.FromJSON E'AddressType where parseJSON o = P.either P.fail (pure . P.id) . toE'AddressType =<< A.parseJSON o
instance WH.ToHttpApiData E'AddressType where toQueryParam = WH.toQueryParam . fromE'AddressType
instance WH.FromHttpApiData E'AddressType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AddressType
instance MimeRender MimeMultipartFormData E'AddressType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AddressType' enum
fromE'AddressType :: E'AddressType -> Text
fromE'AddressType = \case
  E'AddressType'Current -> "current"
  E'AddressType'Former -> "former"
  E'AddressType'Additional -> "additional"

-- | parse 'E'AddressType' enum
toE'AddressType :: Text -> P.Either String E'AddressType
toE'AddressType = \case
  "current" -> P.Right E'AddressType'Current
  "former" -> P.Right E'AddressType'Former
  "additional" -> P.Right E'AddressType'Additional
  s -> P.Left $ "toE'AddressType: enum parse failure: " P.++ P.show s


-- ** E'ErrorType

-- | Enum of 'Text' .
-- Error type
data E'ErrorType
  = E'ErrorType'CERR -- ^ @"CERR"@
  | E'ErrorType'MERR -- ^ @"MERR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ErrorType where toJSON = A.toJSON . fromE'ErrorType
instance A.FromJSON E'ErrorType where parseJSON o = P.either P.fail (pure . P.id) . toE'ErrorType =<< A.parseJSON o
instance WH.ToHttpApiData E'ErrorType where toQueryParam = WH.toQueryParam . fromE'ErrorType
instance WH.FromHttpApiData E'ErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ErrorType
instance MimeRender MimeMultipartFormData E'ErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ErrorType' enum
fromE'ErrorType :: E'ErrorType -> Text
fromE'ErrorType = \case
  E'ErrorType'CERR -> "CERR"
  E'ErrorType'MERR -> "MERR"

-- | parse 'E'ErrorType' enum
toE'ErrorType :: Text -> P.Either String E'ErrorType
toE'ErrorType = \case
  "CERR" -> P.Right E'ErrorType'CERR
  "MERR" -> P.Right E'ErrorType'MERR
  s -> P.Left $ "toE'ErrorType: enum parse failure: " P.++ P.show s


-- ** E'FirstNameMatchFlag

-- | Enum of 'Text' .
-- Flag indicates if the subject's first name matches
data E'FirstNameMatchFlag
  = E'FirstNameMatchFlag'Y -- ^ @"Y"@
  | E'FirstNameMatchFlag'N -- ^ @"N"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FirstNameMatchFlag where toJSON = A.toJSON . fromE'FirstNameMatchFlag
instance A.FromJSON E'FirstNameMatchFlag where parseJSON o = P.either P.fail (pure . P.id) . toE'FirstNameMatchFlag =<< A.parseJSON o
instance WH.ToHttpApiData E'FirstNameMatchFlag where toQueryParam = WH.toQueryParam . fromE'FirstNameMatchFlag
instance WH.FromHttpApiData E'FirstNameMatchFlag where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FirstNameMatchFlag
instance MimeRender MimeMultipartFormData E'FirstNameMatchFlag where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FirstNameMatchFlag' enum
fromE'FirstNameMatchFlag :: E'FirstNameMatchFlag -> Text
fromE'FirstNameMatchFlag = \case
  E'FirstNameMatchFlag'Y -> "Y"
  E'FirstNameMatchFlag'N -> "N"

-- | parse 'E'FirstNameMatchFlag' enum
toE'FirstNameMatchFlag :: Text -> P.Either String E'FirstNameMatchFlag
toE'FirstNameMatchFlag = \case
  "Y" -> P.Right E'FirstNameMatchFlag'Y
  "N" -> P.Right E'FirstNameMatchFlag'N
  s -> P.Left $ "toE'FirstNameMatchFlag: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- Determine what type of model is
data E'Type
  = E'Type'EDAS -- ^ @"EDAS"@
  | E'Type'FICO -- ^ @"FICO"@
  | E'Type'MARKETMAX -- ^ @"MARKETMAX"@
  | E'Type'IDSCORE -- ^ @"IDSCORE"@
  | E'Type'MODEL -- ^ @"MODEL"@
  | E'Type'RBP -- ^ @"RBP"@
  | E'Type'DODDFRANK -- ^ @"DODDFRANK"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'EDAS -> "EDAS"
  E'Type'FICO -> "FICO"
  E'Type'MARKETMAX -> "MARKETMAX"
  E'Type'IDSCORE -> "IDSCORE"
  E'Type'MODEL -> "MODEL"
  E'Type'RBP -> "RBP"
  E'Type'DODDFRANK -> "DODDFRANK"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "EDAS" -> P.Right E'Type'EDAS
  "FICO" -> P.Right E'Type'FICO
  "MARKETMAX" -> P.Right E'Type'MARKETMAX
  "IDSCORE" -> P.Right E'Type'IDSCORE
  "MODEL" -> P.Right E'Type'MODEL
  "RBP" -> P.Right E'Type'RBP
  "DODDFRANK" -> P.Right E'Type'DODDFRANK
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicOAuth20
data AuthBasicOAuth20 =
  AuthBasicOAuth20 B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicOAuth20 where
  applyAuthMethod _ a@(AuthBasicOAuth20 user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


