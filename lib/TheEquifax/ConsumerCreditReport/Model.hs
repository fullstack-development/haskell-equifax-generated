{-
   Consumer Credit Report

   # Introduction       Equifax’s Consumer Credit Report is the leading consumer credit resource enabling lenders to make faster, more informed credit-granting decisions, better manage their risk and maximize growth opportunities. The Consumer Credit Report unites the power of superior consumer dfata with best-in-class search and match logic capabilities to deliver higher match rates on more inquiries.    # Getting Started  1. **<a href=\"/user/applications\" target=\"_blank\">Create</a>** an application  2. **<a href=\"/user/applications\" target=\"_blank\">Subscribe</a>** to Consumer Credit Report API  3. **<a href=\"/products/consumer-credit-report\" target=\"_blank\">Explore</a>** the Sandbox environment mode # Promoting to UAT  To successfully submit test transactions through your application in the UAT environment, a test member number is required.  You may use your existing Equifax test member number(s).  Please contact your Equifax Account Representative if a new test member number is needed. The steps below can be used to test in the UAT environment.  Transactions generated using a test member number do not return identical results as a sandbox transaction.  A sandbox transaction will reflect everything that is exposed in the API whereas a test member number is configured to align with the specifications of your contract. Please contact us to ensure your test member number is configured to your expectations.      1. **<a href=\"/user/applications\" target=\"_blank\">Promote</a>** application to test  2. **<a href=\"/documentation\" target=\"_blank\">Update</a>** requests details for UAT  3. **<a href=\"/documentation\" target=\"_blank\">Test</a>** scenarios in UAT environment   # For More Details    * **<a href=\"/contact\" target=\"_blank\">Contact Us</a>** - Equifax Developer Center Support Website   * **ACRO Migration Support**       * phone: 1-888-407-0359; Option 2 followed by Option 5         * email:  BT.Acro.tech@equifax.com

   OpenAPI Version: 3.0.0
   Consumer Credit Report API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

-- |
-- Module : ConsumerCreditReport.Model
module TheEquifax.ConsumerCreditReport.Model where

import TheEquifax.Core 
import TheEquifax.Core.MimeTypes
import Control.Applicative (Alternative, (<|>))
import qualified Control.Arrow as P (left)
import Data.Aeson ((.:), (.:!), (.:?), (.=))
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (TypeRep, Typeable, typeOf, typeRep)
import qualified Data.Foldable as P
import Data.Function ((&))
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import Data.Monoid ((<>))
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH
import Prelude (Applicative, Bool (..), Char, Double, FilePath, Float, Functor, Int, Integer, Maybe (..), Monad, String, fmap, maybe, mempty, pure, undefined, ($), (.), (/=), (<$>), (<*>), (=<<), (>>=))
import qualified Prelude as P

-- * Parameter newtypes

-- ** PdfRequestId

newtype PdfRequestId = PdfRequestId {unPdfRequestId :: Text} deriving (P.Eq, P.Show)

-- * Models

-- ** APIErrorResponse

-- | APIErrorResponse
data APIErrorResponse = APIErrorResponse
  { -- | /Required/ "efxErrorCode" - Error code
    aPIErrorResponseEfxErrorCode :: !(Double),
    -- | /Required/ "description"
    aPIErrorResponseDescription :: !(Text),
    -- | "additionalErrorDetails"
    aPIErrorResponseAdditionalErrorDetails :: !(Maybe AdditionalErrorDetails)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON APIErrorResponse
instance A.FromJSON APIErrorResponse where
  parseJSON = A.withObject "APIErrorResponse" $ \o ->
    APIErrorResponse
      <$> (o .: "efxErrorCode")
      <*> (o .: "description")
      <*> (o .:? "additionalErrorDetails")

-- | ToJSON APIErrorResponse
instance A.ToJSON APIErrorResponse where
  toJSON APIErrorResponse {..} =
    _omitNulls
      [ "efxErrorCode" .= aPIErrorResponseEfxErrorCode,
        "description" .= aPIErrorResponseDescription,
        "additionalErrorDetails" .= aPIErrorResponseAdditionalErrorDetails
      ]

-- | Construct a value of type 'APIErrorResponse' (by applying it's required fields, if any)
mkAPIErrorResponse ::
  -- | 'aPIErrorResponseEfxErrorCode': Error code
  Double ->
  -- | 'aPIErrorResponseDescription'
  Text ->
  APIErrorResponse
mkAPIErrorResponse aPIErrorResponseEfxErrorCode aPIErrorResponseDescription =
  APIErrorResponse
    { aPIErrorResponseEfxErrorCode,
      aPIErrorResponseDescription,
      aPIErrorResponseAdditionalErrorDetails = Nothing
    }

-- **

-- ** AdditionalErrorDetails

-- | AdditionalErrorDetails
-- Additional error details
data AdditionalErrorDetails = AdditionalErrorDetails
  { -- | /Required/ "status" - HTTP status code
    additionalErrorDetailsStatus :: !(Double),
    -- | "errors"
    additionalErrorDetailsErrors :: !(Maybe [A.Value]),
    -- | "code" - Internal code to identify the error
    additionalErrorDetailsCode :: !(Maybe Double),
    -- | "message" - Short error message
    additionalErrorDetailsMessage :: !(Maybe Text),
    -- | "timeStamp" - Date and time when the error occurred
    additionalErrorDetailsTimeStamp :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdditionalErrorDetails
instance A.FromJSON AdditionalErrorDetails where
  parseJSON = A.withObject "AdditionalErrorDetails" $ \o ->
    AdditionalErrorDetails
      <$> (o .: "status")
      <*> (o .:? "errors")
      <*> (o .:? "code")
      <*> (o .:? "message")
      <*> (o .:? "timeStamp")

-- | ToJSON AdditionalErrorDetails
instance A.ToJSON AdditionalErrorDetails where
  toJSON AdditionalErrorDetails {..} =
    _omitNulls
      [ "status" .= additionalErrorDetailsStatus,
        "errors" .= additionalErrorDetailsErrors,
        "code" .= additionalErrorDetailsCode,
        "message" .= additionalErrorDetailsMessage,
        "timeStamp" .= additionalErrorDetailsTimeStamp
      ]

-- | Construct a value of type 'AdditionalErrorDetails' (by applying it's required fields, if any)
mkAdditionalErrorDetails ::
  -- | 'additionalErrorDetailsStatus': HTTP status code
  Double ->
  AdditionalErrorDetails
mkAdditionalErrorDetails additionalErrorDetailsStatus =
  AdditionalErrorDetails
    { additionalErrorDetailsStatus,
      additionalErrorDetailsErrors = Nothing,
      additionalErrorDetailsCode = Nothing,
      additionalErrorDetailsMessage = Nothing,
      additionalErrorDetailsTimeStamp = Nothing
    }

-- ** AddressRequest

-- | AddressRequest
data AddressRequest = AddressRequest
  { -- | /Required/ "identifier" - Address type of the report subject
    addressRequestIdentifier :: !(Text),
    -- | "houseNumber" - House number
    addressRequestHouseNumber :: !(Maybe Text),
    -- | "quadrant" - Quadrant
    addressRequestQuadrant :: !(Maybe Text),
    -- | "streetName" - Street name
    addressRequestStreetName :: !(Maybe Text),
    -- | "streetType" - Street type
    addressRequestStreetType :: !(Maybe Text),
    -- | "apartmentNumber" - Apartment/Condo/Unit number
    addressRequestApartmentNumber :: !(Maybe Text),
    -- | /Required/ "city" - City name
    addressRequestCity :: !(Text),
    -- | /Required/ "state" - State abbreviation
    addressRequestState :: !(Text),
    -- | "zip" - Zip code
    addressRequestZip :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressRequest
instance A.FromJSON AddressRequest where
  parseJSON = A.withObject "AddressRequest" $ \o ->
    AddressRequest
      <$> (o .: "identifier")
      <*> (o .:? "houseNumber")
      <*> (o .:? "quadrant")
      <*> (o .:? "streetName")
      <*> (o .:? "streetType")
      <*> (o .:? "apartmentNumber")
      <*> (o .: "city")
      <*> (o .: "state")
      <*> (o .:? "zip")

-- | ToJSON AddressRequest
instance A.ToJSON AddressRequest where
  toJSON AddressRequest {..} =
    _omitNulls
      [ "identifier" .= addressRequestIdentifier,
        "houseNumber" .= addressRequestHouseNumber,
        "quadrant" .= addressRequestQuadrant,
        "streetName" .= addressRequestStreetName,
        "streetType" .= addressRequestStreetType,
        "apartmentNumber" .= addressRequestApartmentNumber,
        "city" .= addressRequestCity,
        "state" .= addressRequestState,
        "zip" .= addressRequestZip
      ]

-- | Construct a value of type 'AddressRequest' (by applying it's required fields, if any)
mkAddressRequest ::
  -- | 'addressRequestIdentifier': Address type of the report subject
  Text ->
  -- | 'addressRequestCity': City name
  Text ->
  -- | 'addressRequestState': State abbreviation
  Text ->
  AddressRequest
mkAddressRequest addressRequestIdentifier addressRequestCity addressRequestState =
  AddressRequest
    { addressRequestIdentifier,
      addressRequestHouseNumber = Nothing,
      addressRequestQuadrant = Nothing,
      addressRequestStreetName = Nothing,
      addressRequestStreetType = Nothing,
      addressRequestApartmentNumber = Nothing,
      addressRequestCity,
      addressRequestState,
      addressRequestZip = Nothing
    }

-- ** CreditReportRequest

-- | CreditReportRequest
data CreditReportRequest = CreditReportRequest
  { -- | /Required/ "consumers"
    creditReportRequestConsumers :: !(CreditReportRequestConsumers),
    -- | "externalDataSources"
    creditReportRequestExternalDataSources :: !(Maybe CreditReportRequestExternalDataSources),
    -- | "customerReferenceIdentifier" - Unique identifier provided by customer
    creditReportRequestCustomerReferenceIdentifier :: !(Maybe Text),
    -- | /Required/ "customerConfiguration"
    creditReportRequestCustomerConfiguration :: !(CreditReportRequestCustomerConfiguration)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequest
instance A.FromJSON CreditReportRequest where
  parseJSON = A.withObject "CreditReportRequest" $ \o ->
    CreditReportRequest
      <$> (o .: "consumers")
      <*> (o .:? "externalDataSources")
      <*> (o .:? "customerReferenceIdentifier")
      <*> (o .: "customerConfiguration")

-- | ToJSON CreditReportRequest
instance A.ToJSON CreditReportRequest where
  toJSON CreditReportRequest {..} =
    _omitNulls
      [ "consumers" .= creditReportRequestConsumers,
        "externalDataSources" .= creditReportRequestExternalDataSources,
        "customerReferenceIdentifier" .= creditReportRequestCustomerReferenceIdentifier,
        "customerConfiguration" .= creditReportRequestCustomerConfiguration
      ]

-- | Construct a value of type 'CreditReportRequest' (by applying it's required fields, if any)
mkCreditReportRequest ::
  -- | 'creditReportRequestConsumers'
  CreditReportRequestConsumers ->
  -- | 'creditReportRequestCustomerConfiguration'
  CreditReportRequestCustomerConfiguration ->
  CreditReportRequest
mkCreditReportRequest creditReportRequestConsumers creditReportRequestCustomerConfiguration =
  CreditReportRequest
    { creditReportRequestConsumers,
      creditReportRequestExternalDataSources = Nothing,
      creditReportRequestCustomerReferenceIdentifier = Nothing,
      creditReportRequestCustomerConfiguration
    }

-- ** CreditReportRequestConsumers

-- | CreditReportRequestConsumers
data CreditReportRequestConsumers = CreditReportRequestConsumers
  { -- | /Required/ "name" - Consumer name
    creditReportRequestConsumersName :: !([CreditReportRequestConsumersName]),
    -- | "socialNum" - Social Security Number
    creditReportRequestConsumersSocialNum :: !(Maybe [CreditReportRequestConsumersSocialNum]),
    -- | "dateOfBirth" - Date of Birth
    creditReportRequestConsumersDateOfBirth :: !(Maybe Date),
    -- | "age" - Age
    creditReportRequestConsumersAge :: !(Maybe Text),
    -- | "addresses" - Address information. A maximum of 2 addresses can be sent per inquiry. If socialNum is not provided, the houseNumber, streetName, city and state are required
    creditReportRequestConsumersAddresses :: !(Maybe [AddressRequest]),
    -- | "phoneNumbers"
    creditReportRequestConsumersPhoneNumbers :: !(Maybe [CreditReportRequestConsumersPhoneNumbers]),
    -- | "employments"
    creditReportRequestConsumersEmployments :: !(Maybe CreditReportRequestConsumersEmployments)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumers
instance A.FromJSON CreditReportRequestConsumers where
  parseJSON = A.withObject "CreditReportRequestConsumers" $ \o ->
    CreditReportRequestConsumers
      <$> (o .: "name")
      <*> (o .:? "socialNum")
      <*> (o .:? "dateOfBirth")
      <*> (o .:? "age")
      <*> (o .:? "addresses")
      <*> (o .:? "phoneNumbers")
      <*> (o .:? "employments")

-- | ToJSON CreditReportRequestConsumers
instance A.ToJSON CreditReportRequestConsumers where
  toJSON CreditReportRequestConsumers {..} =
    _omitNulls
      [ "name" .= creditReportRequestConsumersName,
        "socialNum" .= creditReportRequestConsumersSocialNum,
        "dateOfBirth" .= creditReportRequestConsumersDateOfBirth,
        "age" .= creditReportRequestConsumersAge,
        "addresses" .= creditReportRequestConsumersAddresses,
        "phoneNumbers" .= creditReportRequestConsumersPhoneNumbers,
        "employments" .= creditReportRequestConsumersEmployments
      ]

-- | Construct a value of type 'CreditReportRequestConsumers' (by applying it's required fields, if any)
mkCreditReportRequestConsumers ::
  -- | 'creditReportRequestConsumersName': Consumer name
  [CreditReportRequestConsumersName] ->
  CreditReportRequestConsumers
mkCreditReportRequestConsumers creditReportRequestConsumersName =
  CreditReportRequestConsumers
    { creditReportRequestConsumersName,
      creditReportRequestConsumersSocialNum = Nothing,
      creditReportRequestConsumersDateOfBirth = Nothing,
      creditReportRequestConsumersAge = Nothing,
      creditReportRequestConsumersAddresses = Nothing,
      creditReportRequestConsumersPhoneNumbers = Nothing,
      creditReportRequestConsumersEmployments = Nothing
    }

-- ** CreditReportRequestConsumersEmployments

-- | CreditReportRequestConsumersEmployments
data CreditReportRequestConsumersEmployments = CreditReportRequestConsumersEmployments
  { -- | "occupation" - Occupation
    creditReportRequestConsumersEmploymentsOccupation :: !(Maybe Text),
    -- | "employerName" - Employer
    creditReportRequestConsumersEmploymentsEmployerName :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersEmployments
instance A.FromJSON CreditReportRequestConsumersEmployments where
  parseJSON = A.withObject "CreditReportRequestConsumersEmployments" $ \o ->
    CreditReportRequestConsumersEmployments
      <$> (o .:? "occupation")
      <*> (o .:? "employerName")

-- | ToJSON CreditReportRequestConsumersEmployments
instance A.ToJSON CreditReportRequestConsumersEmployments where
  toJSON CreditReportRequestConsumersEmployments {..} =
    _omitNulls
      [ "occupation" .= creditReportRequestConsumersEmploymentsOccupation,
        "employerName" .= creditReportRequestConsumersEmploymentsEmployerName
      ]

-- | Construct a value of type 'CreditReportRequestConsumersEmployments' (by applying it's required fields, if any)
mkCreditReportRequestConsumersEmployments ::
  CreditReportRequestConsumersEmployments
mkCreditReportRequestConsumersEmployments =
  CreditReportRequestConsumersEmployments
    { creditReportRequestConsumersEmploymentsOccupation = Nothing,
      creditReportRequestConsumersEmploymentsEmployerName = Nothing
    }

-- ** CreditReportRequestConsumersName

-- | CreditReportRequestConsumersName
data CreditReportRequestConsumersName = CreditReportRequestConsumersName
  { -- | /Required/ "identifier" - Record identifier
    creditReportRequestConsumersNameIdentifier :: !(Text),
    -- | /Required/ "firstName" - First name
    creditReportRequestConsumersNameFirstName :: !(Text),
    -- | /Required/ "lastName" - Last name
    creditReportRequestConsumersNameLastName :: !(Text),
    -- | "middleName" - Middle name or initial
    creditReportRequestConsumersNameMiddleName :: !(Maybe Text),
    -- | "suffix" - Suffix
    creditReportRequestConsumersNameSuffix :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersName
instance A.FromJSON CreditReportRequestConsumersName where
  parseJSON = A.withObject "CreditReportRequestConsumersName" $ \o ->
    CreditReportRequestConsumersName
      <$> (o .: "identifier")
      <*> (o .: "firstName")
      <*> (o .: "lastName")
      <*> (o .:? "middleName")
      <*> (o .:? "suffix")

-- | ToJSON CreditReportRequestConsumersName
instance A.ToJSON CreditReportRequestConsumersName where
  toJSON CreditReportRequestConsumersName {..} =
    _omitNulls
      [ "identifier" .= creditReportRequestConsumersNameIdentifier,
        "firstName" .= creditReportRequestConsumersNameFirstName,
        "lastName" .= creditReportRequestConsumersNameLastName,
        "middleName" .= creditReportRequestConsumersNameMiddleName,
        "suffix" .= creditReportRequestConsumersNameSuffix
      ]

-- | Construct a value of type 'CreditReportRequestConsumersName' (by applying it's required fields, if any)
mkCreditReportRequestConsumersName ::
  -- | 'creditReportRequestConsumersNameIdentifier': Record identifier
  Text ->
  -- | 'creditReportRequestConsumersNameFirstName': First name
  Text ->
  -- | 'creditReportRequestConsumersNameLastName': Last name
  Text ->
  CreditReportRequestConsumersName
mkCreditReportRequestConsumersName creditReportRequestConsumersNameIdentifier creditReportRequestConsumersNameFirstName creditReportRequestConsumersNameLastName =
  CreditReportRequestConsumersName
    { creditReportRequestConsumersNameIdentifier,
      creditReportRequestConsumersNameFirstName,
      creditReportRequestConsumersNameLastName,
      creditReportRequestConsumersNameMiddleName = Nothing,
      creditReportRequestConsumersNameSuffix = Nothing
    }

-- ** CreditReportRequestConsumersPhoneNumbers

-- | CreditReportRequestConsumersPhoneNumbers
data CreditReportRequestConsumersPhoneNumbers = CreditReportRequestConsumersPhoneNumbers
  { -- | /Required/ "identifier"
    creditReportRequestConsumersPhoneNumbersIdentifier :: !(Text),
    -- | /Required/ "number"
    creditReportRequestConsumersPhoneNumbersNumber :: !(Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersPhoneNumbers
instance A.FromJSON CreditReportRequestConsumersPhoneNumbers where
  parseJSON = A.withObject "CreditReportRequestConsumersPhoneNumbers" $ \o ->
    CreditReportRequestConsumersPhoneNumbers
      <$> (o .: "identifier")
      <*> (o .: "number")

-- | ToJSON CreditReportRequestConsumersPhoneNumbers
instance A.ToJSON CreditReportRequestConsumersPhoneNumbers where
  toJSON CreditReportRequestConsumersPhoneNumbers {..} =
    _omitNulls
      [ "identifier" .= creditReportRequestConsumersPhoneNumbersIdentifier,
        "number" .= creditReportRequestConsumersPhoneNumbersNumber
      ]

-- | Construct a value of type 'CreditReportRequestConsumersPhoneNumbers' (by applying it's required fields, if any)
mkCreditReportRequestConsumersPhoneNumbers ::
  -- | 'creditReportRequestConsumersPhoneNumbersIdentifier'
  Text ->
  -- | 'creditReportRequestConsumersPhoneNumbersNumber'
  Text ->
  CreditReportRequestConsumersPhoneNumbers
mkCreditReportRequestConsumersPhoneNumbers creditReportRequestConsumersPhoneNumbersIdentifier creditReportRequestConsumersPhoneNumbersNumber =
  CreditReportRequestConsumersPhoneNumbers
    { creditReportRequestConsumersPhoneNumbersIdentifier,
      creditReportRequestConsumersPhoneNumbersNumber
    }

-- ** CreditReportRequestConsumersSocialNum

-- | CreditReportRequestConsumersSocialNum
data CreditReportRequestConsumersSocialNum = CreditReportRequestConsumersSocialNum
  { -- | /Required/ "identifier" - Record identifier
    creditReportRequestConsumersSocialNumIdentifier :: !(Text),
    -- | /Required/ "number" - Social Security Number (SSN)
    creditReportRequestConsumersSocialNumNumber :: !(Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestConsumersSocialNum
instance A.FromJSON CreditReportRequestConsumersSocialNum where
  parseJSON = A.withObject "CreditReportRequestConsumersSocialNum" $ \o ->
    CreditReportRequestConsumersSocialNum
      <$> (o .: "identifier")
      <*> (o .: "number")

-- | ToJSON CreditReportRequestConsumersSocialNum
instance A.ToJSON CreditReportRequestConsumersSocialNum where
  toJSON CreditReportRequestConsumersSocialNum {..} =
    _omitNulls
      [ "identifier" .= creditReportRequestConsumersSocialNumIdentifier,
        "number" .= creditReportRequestConsumersSocialNumNumber
      ]

-- | Construct a value of type 'CreditReportRequestConsumersSocialNum' (by applying it's required fields, if any)
mkCreditReportRequestConsumersSocialNum ::
  -- | 'creditReportRequestConsumersSocialNumIdentifier': Record identifier
  Text ->
  -- | 'creditReportRequestConsumersSocialNumNumber': Social Security Number (SSN)
  Text ->
  CreditReportRequestConsumersSocialNum
mkCreditReportRequestConsumersSocialNum creditReportRequestConsumersSocialNumIdentifier creditReportRequestConsumersSocialNumNumber =
  CreditReportRequestConsumersSocialNum
    { creditReportRequestConsumersSocialNumIdentifier,
      creditReportRequestConsumersSocialNumNumber
    }

-- ** CreditReportRequestCustomerConfiguration

-- | CreditReportRequestCustomerConfiguration
-- Configurations related to the credit report being requested
data CreditReportRequestCustomerConfiguration = CreditReportRequestCustomerConfiguration
  { -- | "equifaxUSConsumerCreditReport"
    creditReportRequestCustomerConfigurationEquifaxUsConsumerCreditReport :: !(Maybe EquifaxUSConsumerCreditRequest)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestCustomerConfiguration
instance A.FromJSON CreditReportRequestCustomerConfiguration where
  parseJSON = A.withObject "CreditReportRequestCustomerConfiguration" $ \o ->
    CreditReportRequestCustomerConfiguration
      <$> (o .:? "equifaxUSConsumerCreditReport")

-- | ToJSON CreditReportRequestCustomerConfiguration
instance A.ToJSON CreditReportRequestCustomerConfiguration where
  toJSON CreditReportRequestCustomerConfiguration {..} =
    _omitNulls
      [ "equifaxUSConsumerCreditReport" .= creditReportRequestCustomerConfigurationEquifaxUsConsumerCreditReport
      ]

-- | Construct a value of type 'CreditReportRequestCustomerConfiguration' (by applying it's required fields, if any)
mkCreditReportRequestCustomerConfiguration ::
  CreditReportRequestCustomerConfiguration
mkCreditReportRequestCustomerConfiguration =
  CreditReportRequestCustomerConfiguration
    { creditReportRequestCustomerConfigurationEquifaxUsConsumerCreditReport = Nothing
    }

-- ** CreditReportRequestExternalDataSources

-- | CreditReportRequestExternalDataSources
data CreditReportRequestExternalDataSources = CreditReportRequestExternalDataSources
  { -- | "alternateDataSources"
    creditReportRequestExternalDataSourcesAlternateDataSources :: !(Maybe CreditReportRequestExternalDataSourcesAlternateDataSources)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestExternalDataSources
instance A.FromJSON CreditReportRequestExternalDataSources where
  parseJSON = A.withObject "CreditReportRequestExternalDataSources" $ \o ->
    CreditReportRequestExternalDataSources
      <$> (o .:? "alternateDataSources")

-- | ToJSON CreditReportRequestExternalDataSources
instance A.ToJSON CreditReportRequestExternalDataSources where
  toJSON CreditReportRequestExternalDataSources {..} =
    _omitNulls
      [ "alternateDataSources" .= creditReportRequestExternalDataSourcesAlternateDataSources
      ]

-- | Construct a value of type 'CreditReportRequestExternalDataSources' (by applying it's required fields, if any)
mkCreditReportRequestExternalDataSources ::
  CreditReportRequestExternalDataSources
mkCreditReportRequestExternalDataSources =
  CreditReportRequestExternalDataSources
    { creditReportRequestExternalDataSourcesAlternateDataSources = Nothing
    }

-- ** CreditReportRequestExternalDataSourcesAlternateDataSources

-- | CreditReportRequestExternalDataSourcesAlternateDataSources
data CreditReportRequestExternalDataSourcesAlternateDataSources = CreditReportRequestExternalDataSourcesAlternateDataSources
  { -- | /Required/ "consumerReportIndicator"
    creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator :: !(Bool),
    -- | "customerOrchestrationCode"
    creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrchestrationCode :: !(Maybe Text),
    -- | "customerOrganizationCode"
    creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrganizationCode :: !(Maybe Text),
    -- | "dataProviderTag"
    creditReportRequestExternalDataSourcesAlternateDataSourcesDataProviderTag :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditReportRequestExternalDataSourcesAlternateDataSources
instance A.FromJSON CreditReportRequestExternalDataSourcesAlternateDataSources where
  parseJSON = A.withObject "CreditReportRequestExternalDataSourcesAlternateDataSources" $ \o ->
    CreditReportRequestExternalDataSourcesAlternateDataSources
      <$> (o .: "consumerReportIndicator")
      <*> (o .:? "customerOrchestrationCode")
      <*> (o .:? "customerOrganizationCode")
      <*> (o .:? "dataProviderTag")

-- | ToJSON CreditReportRequestExternalDataSourcesAlternateDataSources
instance A.ToJSON CreditReportRequestExternalDataSourcesAlternateDataSources where
  toJSON CreditReportRequestExternalDataSourcesAlternateDataSources {..} =
    _omitNulls
      [ "consumerReportIndicator" .= creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator,
        "customerOrchestrationCode" .= creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrchestrationCode,
        "customerOrganizationCode" .= creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrganizationCode,
        "dataProviderTag" .= creditReportRequestExternalDataSourcesAlternateDataSourcesDataProviderTag
      ]

-- | Construct a value of type 'CreditReportRequestExternalDataSourcesAlternateDataSources' (by applying it's required fields, if any)
mkCreditReportRequestExternalDataSourcesAlternateDataSources ::
  -- | 'creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator'
  Bool ->
  CreditReportRequestExternalDataSourcesAlternateDataSources
mkCreditReportRequestExternalDataSourcesAlternateDataSources creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator =
  CreditReportRequestExternalDataSourcesAlternateDataSources
    { creditReportRequestExternalDataSourcesAlternateDataSourcesConsumerReportIndicator,
      creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrchestrationCode = Nothing,
      creditReportRequestExternalDataSourcesAlternateDataSourcesCustomerOrganizationCode = Nothing,
      creditReportRequestExternalDataSourcesAlternateDataSourcesDataProviderTag = Nothing
    }

-- ** EquifaxUSConsumerCreditRequest

-- | EquifaxUSConsumerCreditRequest
-- Configuration related to the customer request
data EquifaxUSConsumerCreditRequest = EquifaxUSConsumerCreditRequest
  { -- | /Required/ "memberNumber" - This is your Equifax Customer Number. This number is used to both access and invoice for Equifax data, products and services. Please contact your Equifax Sales Associate for additional information and activation.
    equifaxUSConsumerCreditRequestMemberNumber :: !(Text),
    -- | /Required/ "securityCode" - Security code
    equifaxUSConsumerCreditRequestSecurityCode :: !(Text),
    -- | "codeDescriptionRequired" - Request code descriptions
    equifaxUSConsumerCreditRequestCodeDescriptionRequired :: !(Maybe Bool),
    -- | "endUserInformation"
    equifaxUSConsumerCreditRequestEndUserInformation :: !(Maybe EquifaxUSConsumerCreditRequestEndUserInformation),
    -- | "productCodes" - Codes related to the optional Equifax products \\: Please contact your Equifax Sales Associate for additional information and activation of the desired optional services. Product code values include:   - 01: Equifax Fraud Advisor 2.0 and up to 4 warning codes with Consumer report   - N1: Equifax Fraud Advisor 2.0 and up to 4 warning codes without Consumer report   - 03: Equifax ID Advisor Plus Raw Data returned with Consumer report   - N3: Equifax ID Advisor Plus Raw Data returned without Consumer report   - 08: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on high \\# risk group only (scores of 1-5) with Consumer report   - N8: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on high \\# risk group only (1-5) without Consumer report   - 10: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on all \\# risk groups (scores of 1-9) with Consumer report   - NA: Fraud Advisor 2.0 &#x3D; Fraud Advisor with ID Advisor Plus Raw Data returned on all \\# risk groups (scores of 1-9) without Consumer report   - MM: MarketMax with a Consumer Report   - NZ: MarketMax without a Consumer Report   - 31: ID Score® - Risk with Consumer report   - 32: ID Score® - Risk without Consumer report
    equifaxUSConsumerCreditRequestProductCodes :: !(Maybe [Text]),
    -- | "productInformation"
    equifaxUSConsumerCreditRequestProductInformation :: !(Maybe EquifaxUSConsumerCreditRequestProductInformation),
    -- | "models" - Model Score
    equifaxUSConsumerCreditRequestModels :: !(Maybe [EquifaxUSConsumerCreditRequestModels]),
    -- | "customerCode" - Assigned customer code
    equifaxUSConsumerCreditRequestCustomerCode :: !(Maybe Text),
    -- | "multipleReportIndicator" - Indicates if the report allows more than 1 credit report   - 1: one report   - F: multiple reports (Puerto Rico only)
    equifaxUSConsumerCreditRequestMultipleReportIndicator :: !(Maybe Text),
    -- | "ECOAInquiryType" - Type of inquiry
    equifaxUSConsumerCreditRequestEcoaInquiryType :: !(Maybe Text),
    -- | "optionalFeatureCode" - The optional features requested in the credit report. Please contact your Equifax Sales Associate for additional information and activation Optional feature code:   - B: Military Lending Act with Credit Data   - D: ON-LINE DIRECTORY or ON-LINE DIRECTORY w/Address   - G: Dimensions Data   - M: Return Risk-Based Pricing score information in the FICO and Model Segments   - Q: Return Risk-Based Pricing score information in the FICO segment only   - O: Equifax Model(s) that are set up as Default or Multiple returned   - V: Enhanced Delinquency Alert System (EDAS) &amp; FICO Score based on Equifax Data   - X: FICO Score based on Equifax Data   - Z: Enhanced Delinquency Alert System (EDAS)   - &amp;: FraudIQ Synthetic ID Alerts
    equifaxUSConsumerCreditRequestOptionalFeatureCode :: !(Maybe [Text]),
    -- | "pdfComboIndicator" - Optional indicator to request a PDF version of the report. PDF may be retrieved using the resulting links for up to 2 hours after the initial request is made. If ECOAInquiryType is &#39;Co-applicant&#39;, a separate link is returned for each applicant.     - N: No PDF link is returned in the response (default behavior when indicator not present)     - Y: PDF Link(s) are included with the JSON credit report response.      - S: Standalone PDF, only the PDF links are returned in the JSON response.
    equifaxUSConsumerCreditRequestPdfComboIndicator :: !(Maybe Text),
    -- | "vendorIdentificationCode" - Required for all third-party channel partners and vendors who support end-customer access to Equifax products and services
    equifaxUSConsumerCreditRequestVendorIdentificationCode :: !(Maybe Text),
    -- | "riskModelCodeOnly" - It can be one of the following indicators:     Pre-screen of One model request  - ^: For a single prescreen model          - %: For multiple prescreen models  In-Person rules require that 3 or more items in the request match to a consumer&#39;s file to be considered a hit/match.  - P: In Person rules apply based on the state code in the request          - Q: In Person rules apply based on the state code in the Current Address on the file  Mortgage Reissue   - M: if Mortgage Reissue is requested this indicator is required. Used by the mortgage industry when a consumer’s credit report is reissued to another company for additional services.
    equifaxUSConsumerCreditRequestRiskModelCodeOnly :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequest
instance A.FromJSON EquifaxUSConsumerCreditRequest where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequest" $ \o ->
    EquifaxUSConsumerCreditRequest
      <$> (o .: "memberNumber")
      <*> (o .: "securityCode")
      <*> (o .:? "codeDescriptionRequired")
      <*> (o .:? "endUserInformation")
      <*> (o .:? "productCodes")
      <*> (o .:? "productInformation")
      <*> (o .:? "models")
      <*> (o .:? "customerCode")
      <*> (o .:? "multipleReportIndicator")
      <*> (o .:? "ECOAInquiryType")
      <*> (o .:? "optionalFeatureCode")
      <*> (o .:? "pdfComboIndicator")
      <*> (o .:? "vendorIdentificationCode")
      <*> (o .:? "riskModelCodeOnly")

-- | ToJSON EquifaxUSConsumerCreditRequest
instance A.ToJSON EquifaxUSConsumerCreditRequest where
  toJSON EquifaxUSConsumerCreditRequest {..} =
    _omitNulls
      [ "memberNumber" .= equifaxUSConsumerCreditRequestMemberNumber,
        "securityCode" .= equifaxUSConsumerCreditRequestSecurityCode,
        "codeDescriptionRequired" .= equifaxUSConsumerCreditRequestCodeDescriptionRequired,
        "endUserInformation" .= equifaxUSConsumerCreditRequestEndUserInformation,
        "productCodes" .= equifaxUSConsumerCreditRequestProductCodes,
        "productInformation" .= equifaxUSConsumerCreditRequestProductInformation,
        "models" .= equifaxUSConsumerCreditRequestModels,
        "customerCode" .= equifaxUSConsumerCreditRequestCustomerCode,
        "multipleReportIndicator" .= equifaxUSConsumerCreditRequestMultipleReportIndicator,
        "ECOAInquiryType" .= equifaxUSConsumerCreditRequestEcoaInquiryType,
        "optionalFeatureCode" .= equifaxUSConsumerCreditRequestOptionalFeatureCode,
        "pdfComboIndicator" .= equifaxUSConsumerCreditRequestPdfComboIndicator,
        "vendorIdentificationCode" .= equifaxUSConsumerCreditRequestVendorIdentificationCode,
        "riskModelCodeOnly" .= equifaxUSConsumerCreditRequestRiskModelCodeOnly
      ]

-- | Construct a value of type 'EquifaxUSConsumerCreditRequest' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequest ::
  -- | 'equifaxUSConsumerCreditRequestMemberNumber': This is your Equifax Customer Number. This number is used to both access and invoice for Equifax data, products and services. Please contact your Equifax Sales Associate for additional information and activation.
  Text ->
  -- | 'equifaxUSConsumerCreditRequestSecurityCode': Security code
  Text ->
  EquifaxUSConsumerCreditRequest
mkEquifaxUSConsumerCreditRequest equifaxUSConsumerCreditRequestMemberNumber equifaxUSConsumerCreditRequestSecurityCode =
  EquifaxUSConsumerCreditRequest
    { equifaxUSConsumerCreditRequestMemberNumber,
      equifaxUSConsumerCreditRequestSecurityCode,
      equifaxUSConsumerCreditRequestCodeDescriptionRequired = Nothing,
      equifaxUSConsumerCreditRequestEndUserInformation = Nothing,
      equifaxUSConsumerCreditRequestProductCodes = Nothing,
      equifaxUSConsumerCreditRequestProductInformation = Nothing,
      equifaxUSConsumerCreditRequestModels = Nothing,
      equifaxUSConsumerCreditRequestCustomerCode = Nothing,
      equifaxUSConsumerCreditRequestMultipleReportIndicator = Nothing,
      equifaxUSConsumerCreditRequestEcoaInquiryType = Nothing,
      equifaxUSConsumerCreditRequestOptionalFeatureCode = Nothing,
      equifaxUSConsumerCreditRequestPdfComboIndicator = Nothing,
      equifaxUSConsumerCreditRequestVendorIdentificationCode = Nothing,
      equifaxUSConsumerCreditRequestRiskModelCodeOnly = Nothing
    }

-- ** EquifaxUSConsumerCreditRequestEndUserInformation

-- | EquifaxUSConsumerCreditRequestEndUserInformation
-- Customers using an \"IG\", \"IL\", \"IZ\" or \"RT\" Industry Code are only required to send the appropriate Permissible Purpose Code. Customers using a \"ZB\" or \"ZT\" Industry Code must include both the \"End Users Name\" and the applicable Permissible Purpose code.
data EquifaxUSConsumerCreditRequestEndUserInformation = EquifaxUSConsumerCreditRequestEndUserInformation
  { -- | /Required/ "endUsersName" - Company name of the final recipient of the consumer report making the request
    equifaxUSConsumerCreditRequestEndUserInformationEndUsersName :: !(Text),
    -- | /Required/ "permissiblePurposeCode" - Code to audit the purposes for which Equifax consumer information is furnished thus providing continued compliance with the FCRA   - 01: Intends to use the information as a potential investor servicer or current insurer in connection with a valuation of or assessment of the credit or prepayment risks.   - 03: In accordance with written instructions of the consumer to whom it relates.   - 04: In connection with a collection transaction involving a credit account of the consumer.   - 05: In response to an agency administering a state plan under Section 454 of the Social Security Act (42 U.S.C. 654) for use to set an initial or modified child support award.   - 06: In accordance with written instructions of the consumer through a reseller.   - 07: In response to a request by the head of a state or local child support enforcement agency (or a state or local government official authorized by the head of such an agency) that has met all requirements of Section 604(a)(4)(ABCD).   - 08: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer. For use only when the transaction cannot be described with a more specific code.   - 09: For employment purposes (Only PERSONA is available with this code)   - 10: In connection with a determination of eligibility for a license or other benefit granted by a governmental instrument required by law to consider financial responsibility or status.   - 11: In connection with the underwriting of insurance.   - 12: In connection with the review of existing policy holders for insurance underwriting purposes.   - 13: A legitimate business need to review an account to determine whether the consumer continues to meet the terms of the account.   - 14: In response to the order of a court having jurisdiction or a subpoena issued by a federal grand jury.   - 15: In connection with a tenant screen application involving the consumer.   - 16: For use by a governmental agency pursuant to FCRA Section 608.   - 17: To protect against or prevent actual or potential fraud unauthorized transactions claims or other liability.   - 18: For required institutional risk control or for resolving consumer disputes or inquiries.   - 19: Due to holding a legal or beneficial interest relating to the consumer.   - 20: To law enforcement agencies or for an investigation on a matter related to public safety.   - 21: As necessary to effect administer or enforce a transaction; to underwrite insurance at the consumer’s request for reinsurance purposes or for the following purposes related to the consumer’s insurance;  account administration reporting investigating fraud prevention premium payment processing claim processing benefit administration or research projects.   - 22: To persons acting in a fiduciary or representative capacity on behalf of and with the consent of the consumer.   - 23: As necessary to effect administer or enforce a transaction requested or authorized by the consumer including location for collection of a delinquent account.   - 24: In conjunction with access to a commercial file on a sole proprietorship.   - 25: In conjunction with access to a commercial file on a corporation where specific consumer consent is given.   - 26: In connection with a credit transaction involving the extension of credit to or review or collection of an account of the consumer where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use of which the medical information will be furnished.   - 27: For employment purposes where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use for which the medical information will be furnished.    - 28: In connection with the underwriting of insurance. Specific consumer consent was given for the release of medical information contained within the consumer report.   - 29: In connection with a transaction where the credit file including any medical information in it is only to be provided directly to the individual consumer to whom the information relates and specific consumer consent was received for the receipt and furnishing of the consumer report including medical information to the consumer.   - 51: In accordance with written instructions of the consumer providing consent for use related to bankruptcy filing purposes.   - 52: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to an automobile or truck.   - 53: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive repair.   - 54: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive parts tires etc.   - 55: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a boat or recreational vehicle.   - 56: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to farm equipment.   - 57: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan origination.   - 58: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan refinancing.   - 59: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a home equity loan line of credit.   - 60: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a personal loan.   - 61: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a credit card.   - 62: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home furnishings.   - 63: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to general contracting / home improvement.   - 64: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to air conditioning / heating / plumbing or electrical.   - 65: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to lumber / building materials / hardware.   - 66: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to hospitalization / medical care / dental care.   - 67: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to personal services.   - 68: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home heating oil / fuel.   - 69: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to telephone / electrical / gas / water utilities or household garbage removal.   - 70: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to wholesale goods.   - 71: For the purpose of providing a consumer with a copy of his/her consumer report or credit score upon the consumer’s request.   - 72: For the purpose of administering a credit file or credit score monitoring service to which the consumer has subscribed.   - 73: For use by a housing counseling agency where the consumer has provided his / her specific consent.
    equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode :: !(Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestEndUserInformation
instance A.FromJSON EquifaxUSConsumerCreditRequestEndUserInformation where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestEndUserInformation" $ \o ->
    EquifaxUSConsumerCreditRequestEndUserInformation
      <$> (o .: "endUsersName")
      <*> (o .: "permissiblePurposeCode")

-- | ToJSON EquifaxUSConsumerCreditRequestEndUserInformation
instance A.ToJSON EquifaxUSConsumerCreditRequestEndUserInformation where
  toJSON EquifaxUSConsumerCreditRequestEndUserInformation {..} =
    _omitNulls
      [ "endUsersName" .= equifaxUSConsumerCreditRequestEndUserInformationEndUsersName,
        "permissiblePurposeCode" .= equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode
      ]

-- | Construct a value of type 'EquifaxUSConsumerCreditRequestEndUserInformation' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestEndUserInformation ::
  -- | 'equifaxUSConsumerCreditRequestEndUserInformationEndUsersName': Company name of the final recipient of the consumer report making the request
  Text ->
  -- | 'equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode': Code to audit the purposes for which Equifax consumer information is furnished thus providing continued compliance with the FCRA   - 01: Intends to use the information as a potential investor servicer or current insurer in connection with a valuation of or assessment of the credit or prepayment risks.   - 03: In accordance with written instructions of the consumer to whom it relates.   - 04: In connection with a collection transaction involving a credit account of the consumer.   - 05: In response to an agency administering a state plan under Section 454 of the Social Security Act (42 U.S.C. 654) for use to set an initial or modified child support award.   - 06: In accordance with written instructions of the consumer through a reseller.   - 07: In response to a request by the head of a state or local child support enforcement agency (or a state or local government official authorized by the head of such an agency) that has met all requirements of Section 604(a)(4)(ABCD).   - 08: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer. For use only when the transaction cannot be described with a more specific code.   - 09: For employment purposes (Only PERSONA is available with this code)   - 10: In connection with a determination of eligibility for a license or other benefit granted by a governmental instrument required by law to consider financial responsibility or status.   - 11: In connection with the underwriting of insurance.   - 12: In connection with the review of existing policy holders for insurance underwriting purposes.   - 13: A legitimate business need to review an account to determine whether the consumer continues to meet the terms of the account.   - 14: In response to the order of a court having jurisdiction or a subpoena issued by a federal grand jury.   - 15: In connection with a tenant screen application involving the consumer.   - 16: For use by a governmental agency pursuant to FCRA Section 608.   - 17: To protect against or prevent actual or potential fraud unauthorized transactions claims or other liability.   - 18: For required institutional risk control or for resolving consumer disputes or inquiries.   - 19: Due to holding a legal or beneficial interest relating to the consumer.   - 20: To law enforcement agencies or for an investigation on a matter related to public safety.   - 21: As necessary to effect administer or enforce a transaction; to underwrite insurance at the consumer’s request for reinsurance purposes or for the following purposes related to the consumer’s insurance;  account administration reporting investigating fraud prevention premium payment processing claim processing benefit administration or research projects.   - 22: To persons acting in a fiduciary or representative capacity on behalf of and with the consent of the consumer.   - 23: As necessary to effect administer or enforce a transaction requested or authorized by the consumer including location for collection of a delinquent account.   - 24: In conjunction with access to a commercial file on a sole proprietorship.   - 25: In conjunction with access to a commercial file on a corporation where specific consumer consent is given.   - 26: In connection with a credit transaction involving the extension of credit to or review or collection of an account of the consumer where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use of which the medical information will be furnished.   - 27: For employment purposes where the medical information to be furnished is relevant to process or effect the transaction and specific consumer consent was provided for the furnishing of the consumer report that describes the use for which the medical information will be furnished.    - 28: In connection with the underwriting of insurance. Specific consumer consent was given for the release of medical information contained within the consumer report.   - 29: In connection with a transaction where the credit file including any medical information in it is only to be provided directly to the individual consumer to whom the information relates and specific consumer consent was received for the receipt and furnishing of the consumer report including medical information to the consumer.   - 51: In accordance with written instructions of the consumer providing consent for use related to bankruptcy filing purposes.   - 52: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to an automobile or truck.   - 53: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive repair.   - 54: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to automotive parts tires etc.   - 55: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a boat or recreational vehicle.   - 56: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to farm equipment.   - 57: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan origination.   - 58: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a mortgage loan refinancing.   - 59: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a home equity loan line of credit.   - 60: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a personal loan.   - 61: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to a credit card.   - 62: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home furnishings.   - 63: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to general contracting / home improvement.   - 64: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to air conditioning / heating / plumbing or electrical.   - 65: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to lumber / building materials / hardware.   - 66: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to hospitalization / medical care / dental care.   - 67: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to personal services.   - 68: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to home heating oil / fuel.   - 69: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to telephone / electrical / gas / water utilities or household garbage removal.   - 70: In connection with a credit transaction involving the consumer and for the extension of credit or review or collection of an account of the consumer related to wholesale goods.   - 71: For the purpose of providing a consumer with a copy of his/her consumer report or credit score upon the consumer’s request.   - 72: For the purpose of administering a credit file or credit score monitoring service to which the consumer has subscribed.   - 73: For use by a housing counseling agency where the consumer has provided his / her specific consent.
  Text ->
  EquifaxUSConsumerCreditRequestEndUserInformation
mkEquifaxUSConsumerCreditRequestEndUserInformation equifaxUSConsumerCreditRequestEndUserInformationEndUsersName equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode =
  EquifaxUSConsumerCreditRequestEndUserInformation
    { equifaxUSConsumerCreditRequestEndUserInformationEndUsersName,
      equifaxUSConsumerCreditRequestEndUserInformationPermissiblePurposeCode
    }

-- ** EquifaxUSConsumerCreditRequestModels

-- | EquifaxUSConsumerCreditRequestModels
data EquifaxUSConsumerCreditRequestModels = EquifaxUSConsumerCreditRequestModels
  { -- | "identifier" - Model number
    equifaxUSConsumerCreditRequestModelsIdentifier :: !(Maybe Text),
    -- | "modelField"
    equifaxUSConsumerCreditRequestModelsModelField :: !(Maybe [Text])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestModels
instance A.FromJSON EquifaxUSConsumerCreditRequestModels where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestModels" $ \o ->
    EquifaxUSConsumerCreditRequestModels
      <$> (o .:? "identifier")
      <*> (o .:? "modelField")

-- | ToJSON EquifaxUSConsumerCreditRequestModels
instance A.ToJSON EquifaxUSConsumerCreditRequestModels where
  toJSON EquifaxUSConsumerCreditRequestModels {..} =
    _omitNulls
      [ "identifier" .= equifaxUSConsumerCreditRequestModelsIdentifier,
        "modelField" .= equifaxUSConsumerCreditRequestModelsModelField
      ]

-- | Construct a value of type 'EquifaxUSConsumerCreditRequestModels' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestModels ::
  EquifaxUSConsumerCreditRequestModels
mkEquifaxUSConsumerCreditRequestModels =
  EquifaxUSConsumerCreditRequestModels
    { equifaxUSConsumerCreditRequestModelsIdentifier = Nothing,
      equifaxUSConsumerCreditRequestModelsModelField = Nothing
    }

-- ** EquifaxUSConsumerCreditRequestProductInformation

-- | EquifaxUSConsumerCreditRequestProductInformation
data EquifaxUSConsumerCreditRequestProductInformation = EquifaxUSConsumerCreditRequestProductInformation
  { -- | "driverLicenseNumber"
    equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber :: !(Maybe [EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber]),
    -- | "coApplicantDateOfBirth" - Co-applicant&#39;s birth date
    equifaxUSConsumerCreditRequestProductInformationCoApplicantDateOfBirth :: !(Maybe Date)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestProductInformation
instance A.FromJSON EquifaxUSConsumerCreditRequestProductInformation where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestProductInformation" $ \o ->
    EquifaxUSConsumerCreditRequestProductInformation
      <$> (o .:? "driverLicenseNumber")
      <*> (o .:? "coApplicantDateOfBirth")

-- | ToJSON EquifaxUSConsumerCreditRequestProductInformation
instance A.ToJSON EquifaxUSConsumerCreditRequestProductInformation where
  toJSON EquifaxUSConsumerCreditRequestProductInformation {..} =
    _omitNulls
      [ "driverLicenseNumber" .= equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber,
        "coApplicantDateOfBirth" .= equifaxUSConsumerCreditRequestProductInformationCoApplicantDateOfBirth
      ]

-- | Construct a value of type 'EquifaxUSConsumerCreditRequestProductInformation' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestProductInformation ::
  EquifaxUSConsumerCreditRequestProductInformation
mkEquifaxUSConsumerCreditRequestProductInformation =
  EquifaxUSConsumerCreditRequestProductInformation
    { equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber = Nothing,
      equifaxUSConsumerCreditRequestProductInformationCoApplicantDateOfBirth = Nothing
    }

-- ** EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber

-- | EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
data EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber = EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
  { -- | "identifier" - Owner of the drivers license
    equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberIdentifier :: !(Maybe Text),
    -- | "driverLicenseNumber" - Subject&#39;s drivers license number
    equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberDriverLicenseNumber :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
instance A.FromJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber where
  parseJSON = A.withObject "EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber" $ \o ->
    EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
      <$> (o .:? "identifier")
      <*> (o .:? "driverLicenseNumber")

-- | ToJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
instance A.ToJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber where
  toJSON EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber {..} =
    _omitNulls
      [ "identifier" .= equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberIdentifier,
        "driverLicenseNumber" .= equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberDriverLicenseNumber
      ]

-- | Construct a value of type 'EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber' (by applying it's required fields, if any)
mkEquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber ::
  EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
mkEquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber =
  EquifaxUSConsumerCreditRequestProductInformationDriverLicenseNumber
    { equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberIdentifier = Nothing,
      equifaxUSConsumerCreditRequestProductInformationDriverLicenseNumberDriverLicenseNumber = Nothing
    }

-- * Enums

-- ** E'ErrorType

-- | Enum of 'Text' .
-- Error type
data E'ErrorType
  = -- | @"CERR"@
    E'ErrorType'CERR
  | -- | @"MERR"@
    E'ErrorType'MERR
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ErrorType where toJSON = A.toJSON . fromE'ErrorType

instance A.FromJSON E'ErrorType where parseJSON o = P.either P.fail (pure . P.id) . toE'ErrorType =<< A.parseJSON o

instance WH.ToHttpApiData E'ErrorType where toQueryParam = WH.toQueryParam . fromE'ErrorType

instance WH.FromHttpApiData E'ErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ErrorType

instance MimeRender MimeMultipartFormData E'ErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ErrorType' enum
fromE'ErrorType :: E'ErrorType -> Text
fromE'ErrorType = \case
  E'ErrorType'CERR -> "CERR"
  E'ErrorType'MERR -> "MERR"

-- | parse 'E'ErrorType' enum
toE'ErrorType :: Text -> P.Either String E'ErrorType
toE'ErrorType = \case
  "CERR" -> P.Right E'ErrorType'CERR
  "MERR" -> P.Right E'ErrorType'MERR
  s -> P.Left $ "toE'ErrorType: enum parse failure: " P.++ P.show s

-- * Auth Methods

-- ** AuthBasicOAuth20

data AuthBasicOAuth20
  = -- | username password
    AuthBasicOAuth20 B.ByteString B.ByteString
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicOAuth20 where
  applyAuthMethod _ a@(AuthBasicOAuth20 user pw) req =
    P.pure $
      if (P.typeOf a `P.elem` rAuthTypes req)
        then
          req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
            & L.over rAuthTypesL (P.filter (/= P.typeOf a))
        else req
    where
      cred = BC.append "Basic " (B64.encode $ BC.concat [user, ":", pw])
