{-
   The Work Number ID API

   # Introduction The Work Number&reg; ID verifies that the applicant-provided Name and SSN match. By doing so, TWN ID helps mitigate the expense of manual review. Customers use TWN ID during the application process to make prompt, more informed decisions.  # Getting started 1. **<a href=\"/user/user-apps\" target=\"_blank\">Subscribe</a>** to get API credentials. 2. **<a href=\"/oauth\" target=\"_blank\">Get an access token</a>** using the credentials. 3. **[Identity verification](#tag/Identity-verification)** 

   OpenAPI Version: 3.0.0
   The Work Number ID API API version: v1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : WorkNumberID.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module TheEquifax.WorkNumberID.Model where

import TheEquifax.Core
import TheEquifax.Core.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** ApplicantsObject
-- | ApplicantsObject
-- Container to hold order information along with primary consumer details.
data ApplicantsObject = ApplicantsObject
  { applicantsObjectCustomerReferenceNumber :: !(Maybe Text) -- ^ "customerReferenceNumber" - Customer reference number.
  , applicantsObjectOrderInfo :: !(Maybe OrderInfo) -- ^ "orderInfo"
  , applicantsObjectPrimaryConsumer :: !(PrimaryConsumer) -- ^ /Required/ "primaryConsumer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicantsObject
instance A.FromJSON ApplicantsObject where
  parseJSON = A.withObject "ApplicantsObject" $ \o ->
    ApplicantsObject
      <$> (o .:? "customerReferenceNumber")
      <*> (o .:? "orderInfo")
      <*> (o .:  "primaryConsumer")

-- | ToJSON ApplicantsObject
instance A.ToJSON ApplicantsObject where
  toJSON ApplicantsObject {..} =
   A.object
      [ "customerReferenceNumber" .= applicantsObjectCustomerReferenceNumber
      , "orderInfo" .= applicantsObjectOrderInfo
      , "primaryConsumer" .= applicantsObjectPrimaryConsumer
      ]


-- | Construct a value of type 'ApplicantsObject' (by applying it's required fields, if any)
mkApplicantsObject
  :: PrimaryConsumer -- ^ 'applicantsObjectPrimaryConsumer' 
  -> ApplicantsObject
mkApplicantsObject applicantsObjectPrimaryConsumer =
  ApplicantsObject
  { applicantsObjectCustomerReferenceNumber = Nothing
  , applicantsObjectOrderInfo = Nothing
  , applicantsObjectPrimaryConsumer
  }

-- ** ErrorInfo
-- | ErrorInfo
-- This section could possibly be returned if there are errors returned by Employment Datasource. Applicable in case of errors in work number.
data ErrorInfo = ErrorInfo
  { errorInfoErrorCode :: !(Maybe Double) -- ^ "errorCode" - The  error codes returned by Employment datasource are returned as-is from the client.
  , errorInfoErrorMessage :: !(Maybe Text) -- ^ "errorMessage" - Error description.for errors returned by the Employment datasource. Some of these could provide additional details into the cause of the error. Internal consumers of client application (CSF) use some of these error codes to request additional information to correct the situation. For direct integrations, these are just informational.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorInfo
instance A.FromJSON ErrorInfo where
  parseJSON = A.withObject "ErrorInfo" $ \o ->
    ErrorInfo
      <$> (o .:? "errorCode")
      <*> (o .:? "errorMessage")

-- | ToJSON ErrorInfo
instance A.ToJSON ErrorInfo where
  toJSON ErrorInfo {..} =
   A.object
      [ "errorCode" .= errorInfoErrorCode
      , "errorMessage" .= errorInfoErrorMessage
      ]


-- | Construct a value of type 'ErrorInfo' (by applying it's required fields, if any)
mkErrorInfo
  :: ErrorInfo
mkErrorInfo =
  ErrorInfo
  { errorInfoErrorCode = Nothing
  , errorInfoErrorMessage = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseCode :: !(Maybe Double) -- ^ "code" - Code to indicate more specific cause of the error.
  , errorResponseDescription :: !(Maybe Text) -- ^ "description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:? "code")
      <*> (o .:? "description")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   A.object
      [ "code" .= errorResponseCode
      , "description" .= errorResponseDescription
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: ErrorResponse
mkErrorResponse =
  ErrorResponse
  { errorResponseCode = Nothing
  , errorResponseDescription = Nothing
  }

-- ** Name
-- | Name
data Name = Name
  { nameIdentifier :: !(Maybe Text) -- ^ "identifier" - Applicant&#39;s identifier. The only option currently supported is \&quot;current\&quot;.
  , nameFirstName :: !(Maybe Text) -- ^ "firstName" - Applicant&#39;s first name.
  , nameLastName :: !(Maybe Text) -- ^ "lastName" - Applicant&#39;s last name.
  , nameMiddleName :: !(Maybe Text) -- ^ "middleName" - Applicant&#39;s middle name.
  , nameSuffix :: !(Maybe Text) -- ^ "suffix" - Applicant&#39;s suffix.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Name
instance A.FromJSON Name where
  parseJSON = A.withObject "Name" $ \o ->
    Name
      <$> (o .:? "identifier")
      <*> (o .:? "firstName")
      <*> (o .:? "lastName")
      <*> (o .:? "middleName")
      <*> (o .:? "suffix")

-- | ToJSON Name
instance A.ToJSON Name where
  toJSON Name {..} =
   A.object
      [ "identifier" .= nameIdentifier
      , "firstName" .= nameFirstName
      , "lastName" .= nameLastName
      , "middleName" .= nameMiddleName
      , "suffix" .= nameSuffix
      ]


-- | Construct a value of type 'Name' (by applying it's required fields, if any)
mkName
  :: Name
mkName =
  Name
  { nameIdentifier = Nothing
  , nameFirstName = Nothing
  , nameLastName = Nothing
  , nameMiddleName = Nothing
  , nameSuffix = Nothing
  }

-- ** OrderInfo
-- | OrderInfo
-- Container to hold order information such as requestor, inquiry date, inquiry type, source details, etc.
data OrderInfo = OrderInfo
  { orderInfoOrganizationId :: !(Double) -- ^ /Required/ "organizationId" - Customer Organization ID as supplied by Equifax. This will be generated as part of customer onboarding on the Equifax side.
  , orderInfoLocationId :: !(Double) -- ^ /Required/ "locationId" - Customer Location ID is the department or product line the Customer is configured for in the Equifax system. This will be generated as part of customer onboarding on the Equifax side.
  , orderInfoOrganizationName :: !(Text) -- ^ /Required/ "organizationName" - Customer Organization Name corresponding to the ID as supplied by Equifax. This will be generated as part of customer onboarding on the Equifax side.
  , orderInfoPlatformName :: !(Maybe Text) -- ^ "platformName" - This will be the name of the Application being used to place the order.This is an optional element
  , orderInfoIntermediaryName :: !(Maybe Text) -- ^ "intermediaryName" - This will be the company name/connector name. This is an optional element
  , orderInfoResellerName :: !(Maybe Text) -- ^ "resellerName" - Reseller name
  , orderInfoLocationName :: !(Text) -- ^ /Required/ "locationName" - Location Name corresponding to the ID as supplied by Equifax. This will be generated as part of customer onboarding on the Equifax side.
  , orderInfoInquiryDate :: !(Maybe Text) -- ^ "inquiryDate" - Inquiry date in the format yyyy-mm-dd
  , orderInfoInquiryType :: !(Maybe Text) -- ^ "inquiryType" - This field can be used to denote the type of report requested. This is an optional element for this report and if provided it is just used for tracking.
  , orderInfoPermPurpose :: !(Text) -- ^ /Required/ "permPurpose" - Represents the permissible purpose code Only the following values are allowed &#x3D;[&#39;PPCHLDSPA&#39;,&#39;PPCREDIT&#39;,&#39;PPCRTORD&#39;,&#39;PPEMPLOY&#39;,&#39;PPGOVRNM&#39;,&#39;PPASSESS&#39;,&#39;PPBUSNSS&#39;,&#39;PPINSRNC&#39;,&#39;PPREVIEW&#39;,&#39;PPSECRTY&#39;,&#39;PPWRTTEN&#39;]
  , orderInfoTrackingId :: !(Maybe Text) -- ^ "trackingId" - This is an optional element for this report and if provided, it is just a passthrough.
  , orderInfoSourceSystemId :: !(Maybe Text) -- ^ "sourceSystemId" - This is used to capture the id of the source system from which the request is coming (if provided). This is a pass-through used for tracking.
  , orderInfoSourceName :: !(Maybe Text) -- ^ "sourceName" - This is used to capture the source system from which the request is coming (if provided). This is a pass-through and is just used for tracking.
  , orderInfoRequestor :: !(Maybe Requestor) -- ^ "requestor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderInfo
instance A.FromJSON OrderInfo where
  parseJSON = A.withObject "OrderInfo" $ \o ->
    OrderInfo
      <$> (o .:  "organizationId")
      <*> (o .:  "locationId")
      <*> (o .:  "organizationName")
      <*> (o .:? "platformName")
      <*> (o .:? "intermediaryName")
      <*> (o .:? "resellerName")
      <*> (o .:  "locationName")
      <*> (o .:? "inquiryDate")
      <*> (o .:? "inquiryType")
      <*> (o .:  "permPurpose")
      <*> (o .:? "trackingId")
      <*> (o .:? "sourceSystemId")
      <*> (o .:? "sourceName")
      <*> (o .:? "requestor")

-- | ToJSON OrderInfo
instance A.ToJSON OrderInfo where
  toJSON OrderInfo {..} =
   A.object
      [ "organizationId" .= orderInfoOrganizationId
      , "locationId" .= orderInfoLocationId
      , "organizationName" .= orderInfoOrganizationName
      , "platformName" .= orderInfoPlatformName
      , "intermediaryName" .= orderInfoIntermediaryName
      , "resellerName" .= orderInfoResellerName
      , "locationName" .= orderInfoLocationName
      , "inquiryDate" .= orderInfoInquiryDate
      , "inquiryType" .= orderInfoInquiryType
      , "permPurpose" .= orderInfoPermPurpose
      , "trackingId" .= orderInfoTrackingId
      , "sourceSystemId" .= orderInfoSourceSystemId
      , "sourceName" .= orderInfoSourceName
      , "requestor" .= orderInfoRequestor
      ]


-- | Construct a value of type 'OrderInfo' (by applying it's required fields, if any)
mkOrderInfo
  :: Double -- ^ 'orderInfoOrganizationId': Customer Organization ID as supplied by Equifax. This will be generated as part of customer onboarding on the Equifax side.
  -> Double -- ^ 'orderInfoLocationId': Customer Location ID is the department or product line the Customer is configured for in the Equifax system. This will be generated as part of customer onboarding on the Equifax side.
  -> Text -- ^ 'orderInfoOrganizationName': Customer Organization Name corresponding to the ID as supplied by Equifax. This will be generated as part of customer onboarding on the Equifax side.
  -> Text -- ^ 'orderInfoLocationName': Location Name corresponding to the ID as supplied by Equifax. This will be generated as part of customer onboarding on the Equifax side.
  -> Text -- ^ 'orderInfoPermPurpose': Represents the permissible purpose code Only the following values are allowed =['PPCHLDSPA','PPCREDIT','PPCRTORD','PPEMPLOY','PPGOVRNM','PPASSESS','PPBUSNSS','PPINSRNC','PPREVIEW','PPSECRTY','PPWRTTEN']
  -> OrderInfo
mkOrderInfo orderInfoOrganizationId orderInfoLocationId orderInfoOrganizationName orderInfoLocationName orderInfoPermPurpose =
  OrderInfo
  { orderInfoOrganizationId
  , orderInfoLocationId
  , orderInfoOrganizationName
  , orderInfoPlatformName = Nothing
  , orderInfoIntermediaryName = Nothing
  , orderInfoResellerName = Nothing
  , orderInfoLocationName
  , orderInfoInquiryDate = Nothing
  , orderInfoInquiryType = Nothing
  , orderInfoPermPurpose
  , orderInfoTrackingId = Nothing
  , orderInfoSourceSystemId = Nothing
  , orderInfoSourceName = Nothing
  , orderInfoRequestor = Nothing
  }

-- ** OrderInfoResponse
-- | OrderInfoResponse
-- Container to hold  order information along with primary consumer details.
data OrderInfoResponse = OrderInfoResponse
  { orderInfoResponseInquiryDate :: !(Maybe Text) -- ^ "inquiryDate" - Inquiry date in the format yyyy-mm-dd.
  , orderInfoResponseInquiryType :: !(Maybe Text) -- ^ "inquiryType" - Inquiry type identifier.
  , orderInfoResponsePermPurpose :: !(Maybe Text) -- ^ "permPurpose" - Represents the permissible purpose code Only the following values are allowed &#x3D;[&#39;PPCHLDSPA&#39;,&#39;PPCREDIT&#39;,&#39;PPCRTORD&#39;,&#39;PPEMPLOY&#39;,&#39;PPGOVRNM&#39;,&#39;PPASSESS&#39;,&#39;PPBUSNSS&#39;,&#39;PPINSRNC&#39;,&#39;PPREVIEW&#39;,&#39;PPSECRTY&#39;,&#39;PPWRTTEN&#39;]
  , orderInfoResponseTrackingId :: !(Maybe Text) -- ^ "trackingId" - Tracking id is a customer provided reference number. The value if received in request will be echoed back in the response.
  , orderInfoResponseSourceSystemId :: !(Maybe Text) -- ^ "sourceSystemId" - Source system id is a customer provided system id. The value if received in request will be echoed back in the response.
  , orderInfoResponseSourceName :: !(Maybe Text) -- ^ "sourceName" - Source name is a customer provided system name. The value if received in request will be echoed back in the response.
  , orderInfoResponseInquirySsn :: !(Maybe Text) -- ^ "inquirySsn" - Social Security Number sourced from the Employment record.
  , orderInfoResponseRequestor :: !(Maybe Requestor) -- ^ "requestor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderInfoResponse
instance A.FromJSON OrderInfoResponse where
  parseJSON = A.withObject "OrderInfoResponse" $ \o ->
    OrderInfoResponse
      <$> (o .:? "inquiryDate")
      <*> (o .:? "inquiryType")
      <*> (o .:? "permPurpose")
      <*> (o .:? "trackingId")
      <*> (o .:? "sourceSystemId")
      <*> (o .:? "sourceName")
      <*> (o .:? "inquirySsn")
      <*> (o .:? "requestor")

-- | ToJSON OrderInfoResponse
instance A.ToJSON OrderInfoResponse where
  toJSON OrderInfoResponse {..} =
   A.object
      [ "inquiryDate" .= orderInfoResponseInquiryDate
      , "inquiryType" .= orderInfoResponseInquiryType
      , "permPurpose" .= orderInfoResponsePermPurpose
      , "trackingId" .= orderInfoResponseTrackingId
      , "sourceSystemId" .= orderInfoResponseSourceSystemId
      , "sourceName" .= orderInfoResponseSourceName
      , "inquirySsn" .= orderInfoResponseInquirySsn
      , "requestor" .= orderInfoResponseRequestor
      ]


-- | Construct a value of type 'OrderInfoResponse' (by applying it's required fields, if any)
mkOrderInfoResponse
  :: OrderInfoResponse
mkOrderInfoResponse =
  OrderInfoResponse
  { orderInfoResponseInquiryDate = Nothing
  , orderInfoResponseInquiryType = Nothing
  , orderInfoResponsePermPurpose = Nothing
  , orderInfoResponseTrackingId = Nothing
  , orderInfoResponseSourceSystemId = Nothing
  , orderInfoResponseSourceName = Nothing
  , orderInfoResponseInquirySsn = Nothing
  , orderInfoResponseRequestor = Nothing
  }

-- ** PersonalInformation
-- | PersonalInformation
-- Container to hold Personal Information of the Primary Consumer.
data PersonalInformation = PersonalInformation
  { personalInformationSocialSecurityNumber :: !(Text) -- ^ /Required/ "socialSecurityNumber" - Applicant&#39;s Social Security Number.
  , personalInformationCustomerReferenceIdentifier :: !(Maybe Text) -- ^ "customerReferenceIdentifier" - Customer&#39;s reference identifier.
  , personalInformationDateOfBirth :: !(Maybe Text) -- ^ "dateOfBirth" - Applicant&#39;s date of birth in the format yyyy-mm-dd.
  , personalInformationName :: !(Maybe [Name]) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PersonalInformation
instance A.FromJSON PersonalInformation where
  parseJSON = A.withObject "PersonalInformation" $ \o ->
    PersonalInformation
      <$> (o .:  "socialSecurityNumber")
      <*> (o .:? "customerReferenceIdentifier")
      <*> (o .:? "dateOfBirth")
      <*> (o .:? "name")

-- | ToJSON PersonalInformation
instance A.ToJSON PersonalInformation where
  toJSON PersonalInformation {..} =
   A.object
      [ "socialSecurityNumber" .= personalInformationSocialSecurityNumber
      , "customerReferenceIdentifier" .= personalInformationCustomerReferenceIdentifier
      , "dateOfBirth" .= personalInformationDateOfBirth
      , "name" .= personalInformationName
      ]


-- | Construct a value of type 'PersonalInformation' (by applying it's required fields, if any)
mkPersonalInformation
  :: Text -- ^ 'personalInformationSocialSecurityNumber': Applicant's Social Security Number.
  -> PersonalInformation
mkPersonalInformation personalInformationSocialSecurityNumber =
  PersonalInformation
  { personalInformationSocialSecurityNumber
  , personalInformationCustomerReferenceIdentifier = Nothing
  , personalInformationDateOfBirth = Nothing
  , personalInformationName = Nothing
  }

-- ** PhoneNumbers
-- | PhoneNumbers
data PhoneNumbers = PhoneNumbers
  { phoneNumbersIdentifier :: !(Maybe Text) -- ^ "identifier" - Requestor phone identifier. The only value supported currently is \&quot;primary\&quot;.
  , phoneNumbersNumber :: !(Maybe Text) -- ^ "number" - Requestor phone number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PhoneNumbers
instance A.FromJSON PhoneNumbers where
  parseJSON = A.withObject "PhoneNumbers" $ \o ->
    PhoneNumbers
      <$> (o .:? "identifier")
      <*> (o .:? "number")

-- | ToJSON PhoneNumbers
instance A.ToJSON PhoneNumbers where
  toJSON PhoneNumbers {..} =
   A.object
      [ "identifier" .= phoneNumbersIdentifier
      , "number" .= phoneNumbersNumber
      ]


-- | Construct a value of type 'PhoneNumbers' (by applying it's required fields, if any)
mkPhoneNumbers
  :: PhoneNumbers
mkPhoneNumbers =
  PhoneNumbers
  { phoneNumbersIdentifier = Nothing
  , phoneNumbersNumber = Nothing
  }

-- ** PrimaryConsumer
-- | PrimaryConsumer
-- Container section to hold details of the Primary Consumer.
data PrimaryConsumer = PrimaryConsumer
  { primaryConsumerPersonalInformation :: !(PersonalInformation) -- ^ /Required/ "personalInformation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrimaryConsumer
instance A.FromJSON PrimaryConsumer where
  parseJSON = A.withObject "PrimaryConsumer" $ \o ->
    PrimaryConsumer
      <$> (o .:  "personalInformation")

-- | ToJSON PrimaryConsumer
instance A.ToJSON PrimaryConsumer where
  toJSON PrimaryConsumer {..} =
   A.object
      [ "personalInformation" .= primaryConsumerPersonalInformation
      ]


-- | Construct a value of type 'PrimaryConsumer' (by applying it's required fields, if any)
mkPrimaryConsumer
  :: PersonalInformation -- ^ 'primaryConsumerPersonalInformation' 
  -> PrimaryConsumer
mkPrimaryConsumer primaryConsumerPersonalInformation =
  PrimaryConsumer
  { primaryConsumerPersonalInformation
  }

-- ** IdentityVerificationRequest
-- | IdentityVerificationRequest
data IdentityVerificationRequest = IdentityVerificationRequest
  { requestApplicants :: !(Maybe ApplicantsObject) -- ^ "applicants"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityVerificationRequest
instance A.FromJSON IdentityVerificationRequest where
  parseJSON = A.withObject "IdentityVerificationRequest" $ \o ->
    IdentityVerificationRequest
      <$> (o .:? "applicants")

-- | ToJSON IdentityVerificationRequest
instance A.ToJSON IdentityVerificationRequest where
  toJSON IdentityVerificationRequest {..} =
   A.object
      [ "applicants" .= requestApplicants
      ]


-- | Construct a value of type 'Request' (by applying it's required fields, if any)
mkRequest
  :: IdentityVerificationRequest
mkRequest =
  IdentityVerificationRequest
  { requestApplicants = Nothing
  }

-- ** Requestor
-- | Requestor
-- Container to hold requestor details such as name, organization, email, address, phone numbers. The value if received in request will be echoed back in the response.
data Requestor = Requestor
  { requestorName :: !(Maybe Text) -- ^ "name" - Requestor name.
  , requestorEndUser :: !(Maybe Text) -- ^ "endUser" - Requestor organization.
  , requestorEmail :: !(Maybe Text) -- ^ "email" - Requestor email.
  , requestorAddress :: !(Maybe Text) -- ^ "address" - Requestor address.
  , requestorPhoneNumbers :: !(Maybe [PhoneNumbers]) -- ^ "phoneNumbers" - Details of requestor&#39;s phone numbers.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Requestor
instance A.FromJSON Requestor where
  parseJSON = A.withObject "Requestor" $ \o ->
    Requestor
      <$> (o .:? "name")
      <*> (o .:? "endUser")
      <*> (o .:? "email")
      <*> (o .:? "address")
      <*> (o .:? "phoneNumbers")

-- | ToJSON Requestor
instance A.ToJSON Requestor where
  toJSON Requestor {..} =
   A.object
      [ "name" .= requestorName
      , "endUser" .= requestorEndUser
      , "email" .= requestorEmail
      , "address" .= requestorAddress
      , "phoneNumbers" .= requestorPhoneNumbers
      ]


-- | Construct a value of type 'Requestor' (by applying it's required fields, if any)
mkRequestor
  :: Requestor
mkRequestor =
  Requestor
  { requestorName = Nothing
  , requestorEndUser = Nothing
  , requestorEmail = Nothing
  , requestorAddress = Nothing
  , requestorPhoneNumbers = Nothing
  }

-- ** IdentityVerificationResponse
-- | IdentityVerificationResponse
data IdentityVerificationResponse = IdentityVerificationResponse
  { responseTransactionId :: !(Maybe Text) -- ^ "transactionId" - Equifax generated report ID.
  , responseOrderInfo :: !(Maybe OrderInfoResponse) -- ^ "orderInfo"
  , responseTwnIdentity :: !(Maybe TwnIdentity) -- ^ "twnIdentity"
  , responseErrorInfo :: !(Maybe ErrorInfo) -- ^ "errorInfo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityVerificationResponse
instance A.FromJSON IdentityVerificationResponse where
  parseJSON = A.withObject "IdentityVerificationResponse" $ \o ->
    IdentityVerificationResponse
      <$> (o .:? "transactionId")
      <*> (o .:? "orderInfo")
      <*> (o .:? "twnIdentity")
      <*> (o .:? "errorInfo")

-- | ToJSON IdentityVerificationResponse
instance A.ToJSON IdentityVerificationResponse where
  toJSON IdentityVerificationResponse {..} =
   A.object
      [ "transactionId" .= responseTransactionId
      , "orderInfo" .= responseOrderInfo
      , "twnIdentity" .= responseTwnIdentity
      , "errorInfo" .= responseErrorInfo
      ]


-- | Construct a value of type 'Response' (by applying it's required fields, if any)
mkResponse
  :: IdentityVerificationResponse
mkResponse =
  IdentityVerificationResponse
  { responseTransactionId = Nothing
  , responseOrderInfo = Nothing
  , responseTwnIdentity = Nothing
  , responseErrorInfo = Nothing
  }

-- ** TargetErrorResponse
-- | TargetErrorResponse
data TargetErrorResponse = TargetErrorResponse
  { targetErrorResponseCode :: !(Maybe Double) -- ^ "code" - Code to indicate more specific cause of the error.
  , targetErrorResponseDescription :: !(Maybe Text) -- ^ "description"
  , targetErrorResponseAdditionalErrorDetails :: !(Maybe A.Value) -- ^ "additionalErrorDetails" - Additional details about the error.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TargetErrorResponse
instance A.FromJSON TargetErrorResponse where
  parseJSON = A.withObject "TargetErrorResponse" $ \o ->
    TargetErrorResponse
      <$> (o .:? "code")
      <*> (o .:? "description")
      <*> (o .:? "additionalErrorDetails")

-- | ToJSON TargetErrorResponse
instance A.ToJSON TargetErrorResponse where
  toJSON TargetErrorResponse {..} =
   A.object
      [ "code" .= targetErrorResponseCode
      , "description" .= targetErrorResponseDescription
      , "additionalErrorDetails" .= targetErrorResponseAdditionalErrorDetails
      ]


-- | Construct a value of type 'TargetErrorResponse' (by applying it's required fields, if any)
mkTargetErrorResponse
  :: TargetErrorResponse
mkTargetErrorResponse =
  TargetErrorResponse
  { targetErrorResponseCode = Nothing
  , targetErrorResponseDescription = Nothing
  , targetErrorResponseAdditionalErrorDetails = Nothing
  }

-- ** TwnIdentity
-- | TwnIdentity
-- Container to hold Identity Match details returned by the Employment datasource (The Work Number&reg;).
data TwnIdentity = TwnIdentity
  { twnIdentityStatus :: !(Maybe E'Status) -- ^ "status" - Status of Identity Match request.
  , twnIdentityCode :: !(Maybe E'Code) -- ^ "code" - The Work Number&amp;reg; ID Code.
  , twnIdentityDescription :: !(Maybe E'Description) -- ^ "description" - The Work Number&amp;reg; ID Description.
  , twnIdentityDisclaimer :: !(Maybe Text) -- ^ "disclaimer" - This is an Equifax Disclaimer statement for the Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TwnIdentity
instance A.FromJSON TwnIdentity where
  parseJSON = A.withObject "TwnIdentity" $ \o ->
    TwnIdentity
      <$> (o .:? "status")
      <*> (o .:? "code")
      <*> (o .:? "description")
      <*> (o .:? "disclaimer")

-- | ToJSON TwnIdentity
instance A.ToJSON TwnIdentity where
  toJSON TwnIdentity {..} =
   A.object
      [ "status" .= twnIdentityStatus
      , "code" .= twnIdentityCode
      , "description" .= twnIdentityDescription
      , "disclaimer" .= twnIdentityDisclaimer
      ]


-- | Construct a value of type 'TwnIdentity' (by applying it's required fields, if any)
mkTwnIdentity
  :: TwnIdentity
mkTwnIdentity =
  TwnIdentity
  { twnIdentityStatus = Nothing
  , twnIdentityCode = Nothing
  , twnIdentityDescription = Nothing
  , twnIdentityDisclaimer = Nothing
  }


-- * Enums


-- ** E'Code

-- | Enum of 'Text' .
-- The Work Number&reg; ID Code.
data E'Code
  = E'Code'Y__Indicates_a_Match -- ^ @"Y (Indicates a Match)"@
  | E'Code'N__Indicates_a_No_Match -- ^ @"N (Indicates a No Match)"@
  | E'Code'X__Indicates_a_No_Hit -- ^ @"X (Indicates a No Hit)"@
  | E'Code'E__Indicates_an_Error -- ^ @"E (Indicates an Error)"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Code where toJSON = A.toJSON . fromE'Code
instance A.FromJSON E'Code where parseJSON o = P.either P.fail (pure . P.id) . toE'Code =<< A.parseJSON o
instance WH.ToHttpApiData E'Code where toQueryParam = WH.toQueryParam . fromE'Code
instance WH.FromHttpApiData E'Code where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Code
instance MimeRender MimeMultipartFormData E'Code where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Code' enum
fromE'Code :: E'Code -> Text
fromE'Code = \case
  E'Code'Y__Indicates_a_Match -> "Y"
  E'Code'N__Indicates_a_No_Match -> "N"
  E'Code'X__Indicates_a_No_Hit -> "X"
  E'Code'E__Indicates_an_Error -> "E"

-- | parse 'E'Code' enum
toE'Code :: Text -> P.Either String E'Code
toE'Code = \case
  "Y" -> P.Right E'Code'Y__Indicates_a_Match
  "N" -> P.Right E'Code'N__Indicates_a_No_Match
  "X" -> P.Right E'Code'X__Indicates_a_No_Hit
  "E" -> P.Right E'Code'E__Indicates_an_Error
  s -> P.Left $ "toE'Code: enum parse failure: " P.++ P.show s


-- ** E'Description

-- | Enum of 'Text' .
-- The Work Number&reg; ID Description.
data E'Description
  = E'Description'Match -- ^ @"Match"@
  | E'Description'No_Match -- ^ @"No Match"@
  | E'Description'No_Hit -- ^ @"No Hit"@
  | E'Description'Error -- ^ @"Error"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Description where toJSON = A.toJSON . fromE'Description
instance A.FromJSON E'Description where parseJSON o = P.either P.fail (pure . P.id) . toE'Description =<< A.parseJSON o
instance WH.ToHttpApiData E'Description where toQueryParam = WH.toQueryParam . fromE'Description
instance WH.FromHttpApiData E'Description where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Description
instance MimeRender MimeMultipartFormData E'Description where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Description' enum
fromE'Description :: E'Description -> Text
fromE'Description = \case
  E'Description'Match -> "Match"
  E'Description'No_Match -> "No Match"
  E'Description'No_Hit -> "No Hit"
  E'Description'Error -> "Error"

-- | parse 'E'Description' enum
toE'Description :: Text -> P.Either String E'Description
toE'Description = \case
  "Match" -> P.Right E'Description'Match
  "No Match" -> P.Right E'Description'No_Match
  "No Hit" -> P.Right E'Description'No_Hit
  "Error" -> P.Right E'Description'Error
  s -> P.Left $ "toE'Description: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- Status of Identity Match request.
data E'Status
  = E'Status'Completed -- ^ @"Completed"@
  | E'Status'Unable_To_Complete -- ^ @"Unable To Complete"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Completed -> "Completed"
  E'Status'Unable_To_Complete -> "Unable To Complete"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "Completed" -> P.Right E'Status'Completed
  "Unable To Complete" -> P.Right E'Status'Unable_To_Complete
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicOAuth20
data AuthBasicOAuth20 =
  AuthBasicOAuth20 B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicOAuth20 where
  applyAuthMethod _ a@(AuthBasicOAuth20 user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


